{{fbdoc item="title" value="SGN"}}----
Returns the sign part of a number

{{fbdoc item="syntax"}}##
	[[KeyPgDeclare declare]] [[KeyPgFunction function]] **Sgn** ( [[KeyPgByval byval]] //number// [[KeyPgAs as]] [[KeyPgInteger integer]] ) [[KeyPgAs as]] [[KeyPgInteger integer]]
	[[KeyPgDeclare declare]] [[KeyPgFunction function]] **Sgn** ( [[KeyPgByval byval]] //number// [[KeyPgAs as]] [[KeyPgLongint longint]] ) [[KeyPgAs as]] [[KeyPgLongint longint]]
	[[KeyPgDeclare declare]] [[KeyPgFunction function]] **Sgn** ( [[KeyPgByval byval]] //number// [[KeyPgAs as]] [[KeyPgDouble double]] ) [[KeyPgAs as]] [[KeyPgDouble double]]
##
{{fbdoc item="usage"}}##
	//result// = **Sgn**( //number// )
##
{{fbdoc item="param"}}
	##//number//##
		the number to find the sign of

{{fbdoc item="ret"}}
	Returns the sign part of ##//number//##.
	- If //number// is greater than zero, then ##**Sgn**## returns ##1##.
	- If //number// is equal to zero, then ##**Sgn**## returns ##0##.
	- If //number// is less than zero, then ##**Sgn**## returns ##-1##.

{{fbdoc item="desc"}}
	The required ##//number//## argument can be any valid numeric expression.  Unsigned numbers will be treated as if they were signed, i.e. if the highest bit is set the number will be treated as negative, and ##-1## will be returned.

	The ##**Sgn**## unary ##[[KeyPgOperator operator]]## can be overloaded with user defined types.

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/math/sgn.bas"}}%%(freebasic)
DIM N AS INTEGER = 0

PRINT SGN ( -1.87 )
PRINT SGN ( 0 )
PRINT SGN ( 42.658 )
PRINT SGN ( N )
%%

The output would look like:
%%
-1
0
1
0
%%

{{fbdoc item="lang"}}
	- In the //[[CompilerOptlang -lang qb]]// dialect, this operator cannot be overloaded.

{{fbdoc item="diff"}}
	- None

{{fbdoc item="see"}}
	- ##[[KeyPgAbs Abs]]##
	- ##[[KeyPgOperator Operator]]##

{{fbdoc item="back" value="CatPgMath|Math"}}