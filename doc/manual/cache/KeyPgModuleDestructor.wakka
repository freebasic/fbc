{{fbdoc item="title" value="DESTRUCTOR (Module)"}}----
Specifies execution of a procedure at program termination

{{fbdoc item="syntax"}}##
	[[[KeyPgPublic|Public]] | [[KeyPgPrivate|Private]]] [[KeyPgSub|Sub]] //identifier// [[[KeyPgAlias|Alias]] "//external_identifier//"] [()] **Destructor** [//priority//] [[[KeyPgStatic|Static]]]
		{ //procedure body// }
	[[KeyPgEnd|End]] [[KeyPgSub|Sub]]
##
{{fbdoc item="desc"}}
	Defines a procedure to be automatically called from a compiled program's end-code.  End-code is generated by the compiler and is executed when the program terminates normally.  Procedures defined as destructors may be used the same way as ordinary procedures, that is, they may be called from within module-level code, as well as other procedures.  

	The procedure must have an empty parameter list.  A compile-time error will be generated if the ##**Destructor**## keyword is used in a Sub definition having one or more parameters. In a set of overloaded procedures, only one (1) destructor may be defined because of the ambiguity of having multiple Subs which take no arguments.

	In a single module, destructors normally execute in the order in which they are defined.

	The ##//priority//## attribute, an integer between 101 and 65535, can be used to force destructors to be executed in a certain order.  The value of ##//priority//## has no specific meaning, only the relationship of the number with other destructor priorities. 101 is the lowest priority and is executed last.  All destructors having a ##//priority//## attribute are executed after destructors with no attribute.  The priority value of 65535 is the same as not assigning a priority value.

	A module may define multiple destructor procedures.  Destructor procedures may also appear in more than one module. All procedures defined with the syntax shown above will be added to the list of procedures to be called during the program's termination.
	
	The order in which destructors defined in multiple modules are executed is known only at link time.  Therefore, special care should be taken when using destructors that may call on a secondary module also defining a destructors.  In such a case it is advisable to use a single destructor that explicit calls termination procedures in multiple modules to ensure a graceful termination of the application.

	Destructors will be called if the program terminates normally or if error-checking is enabled and the program terminates abnormally.

{{fbdoc item="ex"}}
	{{fbdoc item="filename" value="examples/manual/procs/mod-dtor.bas"}}%%(freebasic)
sub pauseonexit destructor
	
	'' If the program reaches the end, or aborts with an error, 
	'' it will run this destructor before closing
	
	print "Press any key to end the program..."
	sleep
	
end sub

dim array(0 to 10, 0 to 10) as integer
dim as integer i = 0, j = 11

'' this next line will cause the program to abort with an 
'' error if you compile with array bounds checking enabled (fbc -exx ...)
print array(i, j)
%%

{{fbdoc item="diff"}}
	- New to ""FreeBASIC""

{{fbdoc item="see"}}
	- ##[[KeyPgDestructor|Destructor (Class)]]##
	- ##[[KeyPgModuleConstructor|Constructor (Module)]]##
	- ##[[KeyPgSub|Sub]]##

{{fbdoc item="back" value="CatPgProcedures|Procedures"}}