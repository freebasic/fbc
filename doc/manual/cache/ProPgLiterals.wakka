{{fbdoc item="title" value="Literals"}}----
Non-variable compile-time string and numeric values.

Literals are numbers or strings of characters specified directly in the source code.  Literal values may be used by assigning them to a variable or constant, passing them to a procedure, or using them in an expression.

Numeric literals come in two forms - integer and floating-point.  

{{fbdoc item="section" value="Integer Literals"}}

	__Decimal__
	Decimal digits ( ##0 1 2 3 4 5 6 7 8 9## ).
	//Note: to get negative values, a "##-##" sign (##[[KeyPgOpNegate Operator - (Negate)]]##) can be placed before a numeric literal//

{{fbdoc item="filename" value="examples/manual/proguide/literals/dec.bas"}}%%(freebasic)
Dim x as integer = 123456
Dim b as byte = -128
%%

	__Hexadecimal__
	"##&H##", followed by hexadecimal digits ( ##0 1 2 3 4 5 6 7 8 9 A B C D E F## ).

{{fbdoc item="filename" value="examples/manual/proguide/literals/hex.bas"}}%%(freebasic)
Dim x As Integer = &h1E240
Dim b As Byte = &H80
%%
		
	__Octal__
	"##&O##" ( O as in "Octal" ), followed by octal digits ( ##0 1 2 3 4 5 6 7## )

{{fbdoc item="filename" value="examples/manual/proguide/literals/oct.bas"}}%%(freebasic)
Dim x as integer = &O361100
Dim b as byte = &O200
%%
	__Binary__
	"##&B##", followed by binary digits ( ##0 1## )

{{fbdoc item="filename" value="examples/manual/proguide/literals/bin.bas"}}%%(freebasic)
Dim x as integer = &B11110001001000000
Dim b as byte = &B10000000
%%

{{fbdoc item="section" value="Integer size suffixes"}}
	If an integer literal suffix is not given, the number field size required to hold the literal is automatically calculated.  Specifying a size suffix guarantees that the compiler will consider a number as a specific integer size.

	Integer literals ending with:
	- "##L##", "##%##", are considered as signed 32 bit integers. (##[[KeyPgInteger Integer]]##)
	- "##&##", are considered as signed 32 bit long integers. (##[[KeyPgLong Long]]##)
	- "##U##", "##UL##", are considered as unsigned 32 bit integers. (##[[KeyPgUinteger Uinteger]]##)
	- "##LL##", are considered as signed 64 bit integers. (##[[KeyPgLongint Longint]]##)
	- "##ULL##", are considered as unsigned 64 bit integers. (##[[KeyPgUlongint Ulongint]]##)

	The prefixes, suffixes, and hexadecimal letter digits are all case-insensitive.
	
{{fbdoc item="filename" value="examples/manual/proguide/literals/intsuff.bas"}}%%(freebasic)
Dim a as integer = 123L
Dim b as uinteger = &h1234u
Dim c as longint = 76543LL
Dim d as ulongint = &b1010101ULL
%%

{{fbdoc item="section" value="Floating Point Literals"}}
	Floating point numbers are specified in decimal digits, may be positive or negative, have a fractional portion, and optionally an exponent.  The format of a floating point literal is as follows:

	##""number[.[fraction]][((D|E) [+|-] exponent)|(D|E)|][suffix]""##
	//or//
	##"".fraction[((D|E) [+|-] exponent)|(D|E)|][suffix]""##
	
	By default, floating point numbers that do not have either an exponent or a suffix are considered as a double precision floating point value, except in the //[[CompilerOptlang -lang qb]]// dialect, where numbers of 7 digits or fewer are considered to be single precision.
{{fbdoc item="filename" value="examples/manual/proguide/literals/floats.bas"}}%%(freebasic)
Dim a as double = 123.456
Dim b as double = -123.0
%%

	The letter "##D##" or "##E##", placed after the number/fraction part, allows the number to be given an exponent.  The exponent may be specified as either positive or negative with a plus ("##+##") or minus ("##-##") sign.  Exponents that do not have a sign are positive.
	An exponent is not required after the letter, so the letter can be used on its own just to specify the type.  "##D##" specifies a double-precision floating-point number.  "##E##" specifies a floating-point number using the default precision. When the letter is used on its own in combination with a suffix (see below) the type denoted by the suffix overrules the type specified by the letter.

{{fbdoc item="filename" value="examples/manual/proguide/literals/dblsuff.bas"}}%%(freebasic)
Dim a as double = -123.0d
Dim b as double = -123e
Dim c as double = 743.1e+13
Dim d as double = 743.1D-13
Dim e as double = 743.1E13
Dim f as single = 743D! 
%%

	A suffix of "##!##" or "##F##" on a number specifies a single precision (32 bit total) floating point value.  A suffix of "##""#""##" specifies a double precision float.
	Note that the letter suffixes and exponent specifiers are all case-insensitive.

{{fbdoc item="filename" value="examples/manual/proguide/literals/singsuff.bas"}}%%(freebasic)
Dim a as single = 3.1!
Dim b as single = -123.456e-7f
Dim c as double = 0#
Dim d as double = 3.141592653589e3#
%%

{{fbdoc item="section" value="String Literals"}}
	String literals are a sequence of characters contained between two double quotes.  The sequence of characters escaped or non-escaped.

	Double quotes can be specified in the string literal by using two double quotes together.
{{fbdoc item="filename" value="examples/manual/proguide/literals/string.bas"}}%%(freebasic)
print "Hello World!"
print "That's right!"
print "See the ""word"" contained in double quotes."
%%

	String literals can contain escape sequences if the string literal is prefixed by the ##[[KeyPgOpPpEscape ! operator]]## (Escaped String Literal).  See [[TblEscapeSequences Escape Sequences]] for a list of accepted escape sequences.
{{fbdoc item="filename" value="examples/manual/proguide/literals/escape.bas"}}%%(freebasic)
print !"Hello\nWorld!"
%%

	By default, string literals are non-escaped unless ##[[KeyPgOptionescape Option Escape]]## was used in the source in which case all string literals following are by default escaped.

	A string may be explicitly specified as non-escaped when prefixed by the ##[[KeyPgOpPpEscape $ operator]]## (Non-Escaped String Literal).
{{fbdoc item="filename" value="examples/manual/proguide/literals/noescape.bas"}}%%(freebasic)
print $"C:\temp"
%%

	Besides ASCII files with Unicode escape sequences (##\u##), ""FreeBASIC"" can parse UTF-8, UTF-16LE, UTF-16BE, UTF-32LE and UTF-32BE source files allowing unicode characters directly in the string literal.

{{fbdoc item="see"}}
	- ##[[KeyPgTypeof Typeof]]##
	- ##[[KeyPgPpdefine #define]]##
	- ##[[KeyPgConst Const]]## 
	- ##[[CatPgStdDataTypes Standard Data Types]]##
	- ##[[TblVarTypes Table with variable types overview, limits and suffixes]]##

{{fbdoc item="back" value="CatPgProgrammer|Programmer's Guide"}}