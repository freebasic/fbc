{{fbdoc item="title" value="CVD"}}----
Converts a 64-bit integer or 8-byte string to a double-precision value

{{fbdoc item="syntax"}}##
	[[KeyPgDeclare|declare]] [[KeyPgFunction|function]] **Cvd** ( [[KeyPgByval|byval]] //l// [[KeyPgAs|as]] [[KeyPgLongint|longint]] ) [[KeyPgAs|as]] [[KeyPgDouble|double]]
	[[KeyPgDeclare|declare]] [[KeyPgFunction|function]] **Cvd** ( [[KeyPgByref|byref]] //str// [[KeyPgAs|as]] [[KeyPgConstQualifier|const]] [[KeyPgString|string]] ) [[KeyPgAs|as]] [[KeyPgDouble|double]]
##
{{fbdoc item="usage"}}##
	//result// = **Cvd**( //l// )
	//result// = **Cvd**( //str// )
##
{{fbdoc item="param"}}
	##//l//##
		A 64-bit ##[[KeyPgLongint|Longint]]## with a binary copy of a double-precision variable stored in it.
	##//str//##
		A ##[[KeyPgString|String]]## at least 8 bytes in length with a binary copy of a double-precision variable stored in it.

{{fbdoc item="ret"}}
		Returns a ##[[KeyPgDouble|Double]]## value holding a binary copy of the input value.

{{fbdoc item="desc"}}
	Does a binary copy from a 64-bit ##[[KeyPgLongint|Longint]]## or 8-byte ##[[KeyPgString|String]]## to a ##[[KeyPgDouble|Double]]## variable.  A value of zero (##0.0##) is returned if the string is less than 8 bytes in length.  The result will make sense only if the parameter contained a IEEE-754 formatted double-precision value, such as one generated by ##[[KeyPgCvlongint|Cvlongint]]## or ##[[KeyPgMkd|Mkd]]##.
	
	This function is useful to read numeric values from buffers without using a ##[[KeyPgType|Type]]## definition.

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/strings/cvd.bas"}}%%(freebasic)
dim d as double, l as longint
d = 1.125
l = cvlongint(d)

print using "l = _&H&"; hex(l)
print using "cvd(i) = &"; cvd(l)
%%

{{fbdoc item="diff"}}
	- QB did not support integer arguments.

{{fbdoc item="see"}}
	- ##[[KeyPgMkd|Mkd]]##
	- ##[[KeyPgCvs|Cvs]]##
	- ##[[KeyPgCvlongint|Cvlongint]]##

{{fbdoc item="back" value="CatPgString|String Functions"}}