{{fbdoc item="title" value="File I/O with FreeBASIC"}}----

In ""FreeBASIC"", there are 4 possible ways to perform file I/O:

1. Using the built-in BASIC commands like ##[[KeyPgOpen|Open]]## , ##[[KeyPgGetfileio|Get]]##, ##[[KeyPgPutfileio|Put]]##, and ##[[KeyPgClose|Close]]##. This way is mostly portable across all platforms supported by ""FreeBASIC"". Open files are identified by "file numbers", that are specific to ""FreeBASIC"" and can't be passed into functions from below.

2. Using the C stream I/O functions like fopen, fread, ftell, fclose (see Stream I/O in [[ProPgCruntime|C Standard Library Functions]]) of the C library ""FreeBASIC"" relies on. This is slightly faster than and adds a few features beyond method above, and still well portable. Open files are identified by file pointers, as in the C language, again unique to this access method.  The ##[[KeyPgFileattr|FileAttr]]## function can be used to return a stream I/O pointer from a file number as in 1. above.

3. Using the C low-level I/O functions like _open, _read, _write, _close (see Low Level I/O in [[ProPgCruntime|C Standard Library Functions]]). Those functions should be portable, but so far headers are available for ""Win32"" only, so code using them will not compile to any other platform by now.

4. Talk directly to the OS kernel (DOS: use DOS and DPMI INT's , ""Win32"": use API calls like ""CreateFile"", ""WriteFile""). This is no longer portable. Files are identified by handles generated by and specific to the OS kernel.

This example shows and compares methods 1. and 2. described above, and reports the values returned by the functions used. It expects 2 commandline arguments, providing names of 2 **different** files with same size allows to compare the reading performance (make sure the file cache is empty before starting test) :

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/fileio/basicvsc.bas"}}%%(freebasic)
DATA " File I/O example & test GET vs FREAD | (CL) 2008-10-12 Public Domain "
DATA " http://www.freebasic.net/wiki/wikka.php?wakka=ProPgFileIO "
REM
REM Compile with FB 0.20 or newer
REM
REM In the commandline supply preferably 2 different files of same big size
REM Default is "BLAH" for both (bad)
REM In both loops (GET and FREAD) the last read can be "empty" ... no problem

#include "crt\stdio.bi" '' Otherwise the "C"-stuff won't work

DIM AS FILE  PTR   QQ   '' This is the C-like file access pointer
DIM AS UBYTE PTR   BUF  '' Buffer used for both FB-like and C-like read
DIM AS UINTEGER    FILN '' FB-like "filenumber"

DIM AS UINTEGER    AA, BB, CC, DD, EE
DIM AS ULONGINT    II64 '' We do try to support files >= 4 GiB

DIM AS STRING      VGSTEMP, VGSFILE1, VGSFILE2

? : READ VGSTEMP : ? VGSTEMP : READ VGSTEMP : ? VGSTEMP : ?

VGSTEMP=COMMAND$(1) : VGSFILE1="BLAH"
IF (VGSTEMP<>"") THEN VGSFILE1=VGSTEMP
VGSTEMP=COMMAND$(2) : VGSFILE2=VGSFILE1
IF (VGSTEMP<>"") THEN VGSFILE2=VGSTEMP

BUF = ALLOCATE(32768) '' 32 KiB - hoping it won't fail, BUF could be 0 ...

? : ? "FB - OPEN - GET , """+VGSFILE1+"""": SLEEP 1000
FILN = FREEFILE : AA=0 : II64=0 '' AA counts blocks per 32 KiB already read
BB=OPEN (VGSFILE1 FOR BINARY ACCESS READ AS #FILN)
'' Result 0 is OK here, <>0 is evil
'' "ACCESS READ" should prevent file creation if it doesn't exist
? "OPEN result  : " ; BB
IF (BB=0) THEN '' BB will be "reused" for timer below
  BB=CAST(UINTEGER,(TIMER*100)) '' No UINTEGER TIMER in FB, make units 10 ms
  CC=GET (#FILN,,*BUF,32768,DD)
  '' CC has the success status, 0 is OK, <>0 is bad
  '' DD is the amount of data read
  '' EOF is __NOT__ considered as error here
  ? "0th GET      : ";CC;" ";DD
  ? "2 bytes read : ";BUF[0];" ";BUF[1]
  DO
	AA=AA+1 : II64=II64+CAST(ULONGINT,DD)
	IF (DD<32768) OR (CC<>0) THEN EXIT DO '' Give up
	CC=GET (#FILN,,*BUF,32768,DD)
  LOOP
  EE=CAST(UINTEGER,(TIMER*100))-BB
  ? "Time         : ";(EE+1)*10;" ms"
  IF (AA>1) THEN ? "Last GET     : ";CC;" ";DD
  ? "Got __EXACTLY__ ";II64;" bytes in ";AA;" calls"
  CLOSE #FILN
ENDIF

? : ? "C - FOPEN - FREAD , """+VGSFILE2+"""" : SLEEP 1000
AA=0 : II64=0 '' AA counts blocks per 32 KiB already read
QQ=FOPEN(VGSFILE2,"rb")
'' Here 0 is evil and <>0 good, opposite from above !!!
'' File will not be created if it doesn't exist (good)
'' "rb" is case sensitive and must be lowercase, STRPTR seems not necessary
? "FOPEN result : " ; QQ
IF (QQ<>0) THEN
  BB=CAST(UINTEGER,(TIMER*100)) '' No UINTEGER TIMER in FB, make units 10 ms
  DD=FREAD(BUF,1,32768,QQ) '' 1 is size of byte - can't live without :-D
  '' Returns size of data read, <32768 on EOF, 0 after EOF, or "-1" on error
  ? "0th FREAD    : ";DD
  ? "2 bytes read : ";BUF[0];" ";BUF[1]
  DO
	AA=AA+1
	IF (DD<=32768) THEN II64=II64+CAST(ULONGINT,DD)
	IF (DD<>32768) THEN EXIT DO '' ERR or EOF
	DD=FREAD(BUF,1,32768,QQ)
  LOOP
  EE=CAST(UINTEGER,(TIMER*100))-BB
  ? "Time         : ";(EE+1)*10;" ms"
  IF (AA>1) THEN ? "Last FREAD   : ";DD
  ? "Got __EXACTLY__ ";II64;" bytes in ";AA;" calls"
  FCLOSE(QQ)
ENDIF

DEALLOCATE(BUF): SLEEP 1000 '' Crucial

END
%% 

{{fbdoc item="see"}}
	- [[CatPgFile|File I/O Functions]]
	- [[ProPgCruntime|C Standard Library Functions]]
	- [[KeyPgGetfileio|Get (File I/O command)]]

{{fbdoc item="back" value="CatPgProgrammer|Programmer's Guide"}}