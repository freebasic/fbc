{{fbdoc item="title" value="Internal graphics formats"}}----
When a graphics mode is set via the [[KeyPgScreengraphics Screen]] or [[KeyPgScreenres ScreenRes]] functions, GfxLib creates also a framebuffer in standard system memory and sets an appropriate internal pixel format for the mode. There are basically three internal pixel formats, selected depending on the screen depth, as described in the following table:

{{table columns="4" cellpadding="1" cells="Screen depth;Internal bytes per pixel;Range bitmask;Pixel format;1bpp; 1; &h1;palette color index;2bpp; 1; &h3;palette color index;4bpp; 1; &hF;palette color index;8bpp; 1; &hFF;palette color index;15/16bpp; 2; &hFFFF;RRRRRGGGGGGBBBBB;24/32bpp; 4; &hFFFFFFFF;AAAAAAAARRRRRRRRGGGGGGGGBBBBBBBB"}}

All drawing operations work on this RAM framebuffer; when the actual display needs to be updated, GfxLib copies the contents of the framebuffer to the real display memory, automatically converting in the process from the current internal pixel format to whatever pixel format the real display uses. By limiting the internal pixel formats to 3, the library let you not care about the plethora of real display formats.

**Color values**

	When calling a graphics primitive that accepts a color, this can be specified in two ways. In 8bpp or less modes, the color value must be a direct 8 bits color index in the current palette, and this matches the internal pixel format for those modes. In higher color depths, the color value should always have the form &hAARRGGBB; this is what the ##[[KeyPgRgb RGB]]## and ##[[KeyPgRgba RGBA]]## macros return, and is equivalent to the 24/32bpp internal pixel format representation. If the current color depth is 24 or 32bpp, this means the color value passes in unaltered. If a 15/16bpp mode is in use, internally each primitive automatically converts the color from the ##&hAARRGGBB## form into the ##RRRRRGGGGGGBBBBB## internal pixel format (note that in this process the alpha channel is lost, as 15/16bpp modes do not support it). Once the color value is in one of the three pixel formats, the primitive limits its range to the range supported by the current color depth, by using a bitwise AND operation with a range bitmask. So if in 8bpp, the color value passed is ANDed by ##&hFF## for example.

**Notes on transparency**

	For 8bpp or less modes, color index 0 is always treated as the transparent color for the ##[[KeyPgPutgraphics Put]]## modes that support transparency. For higher depths, ##[[KeyPgRgb RGB]]##(255, 0, 255) always represents the transparent color. In 15/16bpp modes, this translates to the internal value ##&hF81F##, whereas in 24/32bpp modes it becomes ##&hFFFF00FF##. Note that in 24/32bpp modes, ##[[KeyPgPutgraphics Put]]## identifies the transparent color by looking just at the red, green and blue components of the color value, while the alpha value can assume any value. This means that in 24/32bpp modes, ##&h00FF00FF##, ##&h10FF00FF##, ##&hABFF00FF## and ##&hFFFF00FF## for example all represent the transparent color, since the lower 24 bits are always ##&hFF00FF##.

{{fbdoc item="see"}}
	- ##[[KeyPgScreengraphics Screen (Graphics)]]##
	- ##[[KeyPgScreenres ScreenRes]]##
	- ##[[KeyPgGetgraphics Get (Graphics)]]##
	- ##[[KeyPgPutgraphics Put (Graphics)]]##
	- ##[[KeyPgImagecreate ImageCreate]]##
	- ##[[KeyPgTransGfx Trans]]##
	- ##[[KeyPgAlphaGfx Alpha]]##

{{fbdoc item="back" value="CatPgProgrammer|Programmer's Guide"}}