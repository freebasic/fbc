
----------------------------------------------------------------------
integers/floats:
----------------------------------------------------------------------


----- b -----------------------------------------------------


math ops (b, b):

b + b = max =
INTEGER
b - b = max =
INTEGER
b * b = max =
INTEGER
b / b = float =
DOUBLE
b ^ b = float =
DOUBLE
b \ b = non-float =
INTEGER
b mod b = non-float =
INTEGER

bitops (b, b):

b shl b = non-float =
INTEGER
b shr b = non-float =
INTEGER
b and b = non-float =
INTEGER
b or b = non-float =
INTEGER
b xor b = non-float =
INTEGER
b eqv b = non-float =
INTEGER
b imp b = non-float =
INTEGER

relational ops (b, b):

b = b = integer =
INTEGER
b > b = integer =
INTEGER
b < b = integer =
INTEGER
b <> b = integer =
INTEGER
b <= b = integer =
INTEGER
b >= b = integer =
INTEGER
b andalso b = integer =
INTEGER
b orelse b = integer =
INTEGER

math ops (b, ub):

b + ub = max =
INTEGER
b - ub = max =
INTEGER
b * ub = max =
INTEGER
b / ub = float =
DOUBLE
b ^ ub = float =
DOUBLE
b \ ub = non-float =
INTEGER
b mod ub = non-float =
INTEGER

bitops (b, ub):

b shl ub = non-float =
INTEGER
b shr ub = non-float =
INTEGER
b and ub = non-float =
INTEGER
b or ub = non-float =
INTEGER
b xor ub = non-float =
INTEGER
b eqv ub = non-float =
INTEGER
b imp ub = non-float =
INTEGER

relational ops (b, ub):

b = ub = integer =
INTEGER
b > ub = integer =
INTEGER
b < ub = integer =
INTEGER
b <> ub = integer =
INTEGER
b <= ub = integer =
INTEGER
b >= ub = integer =
INTEGER
b andalso ub = integer =
INTEGER
b orelse ub = integer =
INTEGER

math ops (b, sh):

b + sh = max =
INTEGER
b - sh = max =
INTEGER
b * sh = max =
INTEGER
b / sh = float =
DOUBLE
b ^ sh = float =
DOUBLE
b \ sh = non-float =
INTEGER
b mod sh = non-float =
INTEGER

bitops (b, sh):

b shl sh = non-float =
INTEGER
b shr sh = non-float =
INTEGER
b and sh = non-float =
INTEGER
b or sh = non-float =
INTEGER
b xor sh = non-float =
INTEGER
b eqv sh = non-float =
INTEGER
b imp sh = non-float =
INTEGER

relational ops (b, sh):

b = sh = integer =
INTEGER
b > sh = integer =
INTEGER
b < sh = integer =
INTEGER
b <> sh = integer =
INTEGER
b <= sh = integer =
INTEGER
b >= sh = integer =
INTEGER
b andalso sh = integer =
INTEGER
b orelse sh = integer =
INTEGER

math ops (b, ush):

b + ush = max =
INTEGER
b - ush = max =
INTEGER
b * ush = max =
INTEGER
b / ush = float =
DOUBLE
b ^ ush = float =
DOUBLE
b \ ush = non-float =
INTEGER
b mod ush = non-float =
INTEGER

bitops (b, ush):

b shl ush = non-float =
INTEGER
b shr ush = non-float =
INTEGER
b and ush = non-float =
INTEGER
b or ush = non-float =
INTEGER
b xor ush = non-float =
INTEGER
b eqv ush = non-float =
INTEGER
b imp ush = non-float =
INTEGER

relational ops (b, ush):

b = ush = integer =
INTEGER
b > ush = integer =
INTEGER
b < ush = integer =
INTEGER
b <> ush = integer =
INTEGER
b <= ush = integer =
INTEGER
b >= ush = integer =
INTEGER
b andalso ush = integer =
INTEGER
b orelse ush = integer =
INTEGER

math ops (b, i):

b + i = max =
INTEGER
b - i = max =
INTEGER
b * i = max =
INTEGER
b / i = float =
DOUBLE
b ^ i = float =
DOUBLE
b \ i = non-float =
INTEGER
b mod i = non-float =
INTEGER

bitops (b, i):

b shl i = non-float =
INTEGER
b shr i = non-float =
INTEGER
b and i = non-float =
INTEGER
b or i = non-float =
INTEGER
b xor i = non-float =
INTEGER
b eqv i = non-float =
INTEGER
b imp i = non-float =
INTEGER

relational ops (b, i):

b = i = integer =
INTEGER
b > i = integer =
INTEGER
b < i = integer =
INTEGER
b <> i = integer =
INTEGER
b <= i = integer =
INTEGER
b >= i = integer =
INTEGER
b andalso i = integer =
INTEGER
b orelse i = integer =
INTEGER

math ops (b, ui):

b + ui = max =
UINTEGER
b - ui = max =
UINTEGER
b * ui = max =
UINTEGER
b / ui = float =
DOUBLE
b ^ ui = float =
DOUBLE
b \ ui = non-float =
UINTEGER
b mod ui = non-float =
UINTEGER

bitops (b, ui):

b shl ui = non-float =
UINTEGER
b shr ui = non-float =
UINTEGER
b and ui = non-float =
UINTEGER
b or ui = non-float =
UINTEGER
b xor ui = non-float =
UINTEGER
b eqv ui = non-float =
UINTEGER
b imp ui = non-float =
UINTEGER

relational ops (b, ui):

b = ui = integer =
INTEGER
b > ui = integer =
INTEGER
b < ui = integer =
INTEGER
b <> ui = integer =
INTEGER
b <= ui = integer =
INTEGER
b >= ui = integer =
INTEGER
b andalso ui = integer =
INTEGER
b orelse ui = integer =
INTEGER

math ops (b, l):

b + l = max =
INTEGER
b - l = max =
INTEGER
b * l = max =
INTEGER
b / l = float =
DOUBLE
b ^ l = float =
DOUBLE
b \ l = non-float =
INTEGER
b mod l = non-float =
INTEGER

bitops (b, l):

b shl l = non-float =
INTEGER
b shr l = non-float =
INTEGER
b and l = non-float =
INTEGER
b or l = non-float =
INTEGER
b xor l = non-float =
INTEGER
b eqv l = non-float =
INTEGER
b imp l = non-float =
INTEGER

relational ops (b, l):

b = l = integer =
INTEGER
b > l = integer =
INTEGER
b < l = integer =
INTEGER
b <> l = integer =
INTEGER
b <= l = integer =
INTEGER
b >= l = integer =
INTEGER
b andalso l = integer =
INTEGER
b orelse l = integer =
INTEGER

math ops (b, ul):

b + ul = max =
INTEGER
b - ul = max =
INTEGER
b * ul = max =
INTEGER
b / ul = float =
DOUBLE
b ^ ul = float =
DOUBLE
b \ ul = non-float =
INTEGER
b mod ul = non-float =
INTEGER

bitops (b, ul):

b shl ul = non-float =
INTEGER
b shr ul = non-float =
INTEGER
b and ul = non-float =
INTEGER
b or ul = non-float =
INTEGER
b xor ul = non-float =
INTEGER
b eqv ul = non-float =
INTEGER
b imp ul = non-float =
INTEGER

relational ops (b, ul):

b = ul = integer =
INTEGER
b > ul = integer =
INTEGER
b < ul = integer =
INTEGER
b <> ul = integer =
INTEGER
b <= ul = integer =
INTEGER
b >= ul = integer =
INTEGER
b andalso ul = integer =
INTEGER
b orelse ul = integer =
INTEGER

math ops (b, ll):

b + ll = max =
INTEGER
b - ll = max =
INTEGER
b * ll = max =
INTEGER
b / ll = float =
DOUBLE
b ^ ll = float =
DOUBLE
b \ ll = non-float =
INTEGER
b mod ll = non-float =
INTEGER

bitops (b, ll):

b shl ll = non-float =
INTEGER
b shr ll = non-float =
INTEGER
b and ll = non-float =
INTEGER
b or ll = non-float =
INTEGER
b xor ll = non-float =
INTEGER
b eqv ll = non-float =
INTEGER
b imp ll = non-float =
INTEGER

relational ops (b, ll):

b = ll = integer =
INTEGER
b > ll = integer =
INTEGER
b < ll = integer =
INTEGER
b <> ll = integer =
INTEGER
b <= ll = integer =
INTEGER
b >= ll = integer =
INTEGER
b andalso ll = integer =
INTEGER
b orelse ll = integer =
INTEGER

math ops (b, ull):

b + ull = max =
UINTEGER
b - ull = max =
UINTEGER
b * ull = max =
UINTEGER
b / ull = float =
DOUBLE
b ^ ull = float =
DOUBLE
b \ ull = non-float =
UINTEGER
b mod ull = non-float =
UINTEGER

bitops (b, ull):

b shl ull = non-float =
UINTEGER
b shr ull = non-float =
UINTEGER
b and ull = non-float =
UINTEGER
b or ull = non-float =
UINTEGER
b xor ull = non-float =
UINTEGER
b eqv ull = non-float =
UINTEGER
b imp ull = non-float =
UINTEGER

relational ops (b, ull):

b = ull = integer =
INTEGER
b > ull = integer =
INTEGER
b < ull = integer =
INTEGER
b <> ull = integer =
INTEGER
b <= ull = integer =
INTEGER
b >= ull = integer =
INTEGER
b andalso ull = integer =
INTEGER
b orelse ull = integer =
INTEGER

math ops (b, enum1a):

b + enum1a = max =
INTEGER
b - enum1a = max =
INTEGER
b * enum1a = max =
INTEGER
b / enum1a = float =
DOUBLE
b ^ enum1a = float =
DOUBLE
b \ enum1a = non-float =
INTEGER
b mod enum1a = non-float =
INTEGER

bitops (b, enum1a):

b shl enum1a = non-float =
INTEGER
b shr enum1a = non-float =
INTEGER
b and enum1a = non-float =
INTEGER
b or enum1a = non-float =
INTEGER
b xor enum1a = non-float =
INTEGER
b eqv enum1a = non-float =
INTEGER
b imp enum1a = non-float =
INTEGER

relational ops (b, enum1a):

b = enum1a = integer =
INTEGER
b > enum1a = integer =
INTEGER
b < enum1a = integer =
INTEGER
b <> enum1a = integer =
INTEGER
b <= enum1a = integer =
INTEGER
b >= enum1a = integer =
INTEGER
b andalso enum1a = integer =
INTEGER
b orelse enum1a = integer =
INTEGER

math ops (b, b):

b + b = max =
INTEGER
b - b = max =
INTEGER
b * b = max =
INTEGER
b / b = float =
DOUBLE
b ^ b = float =
DOUBLE
b \ b = non-float =
INTEGER
b mod b = non-float =
INTEGER

bitops (b, b):

b shl b = non-float =
INTEGER
b shr b = non-float =
INTEGER
b and b = non-float =
INTEGER
b or b = non-float =
INTEGER
b xor b = non-float =
INTEGER
b eqv b = non-float =
INTEGER
b imp b = non-float =
INTEGER

relational ops (b, b):

b = b = integer =
INTEGER
b > b = integer =
INTEGER
b < b = integer =
INTEGER
b <> b = integer =
INTEGER
b <= b = integer =
INTEGER
b >= b = integer =
INTEGER
b andalso b = integer =
INTEGER
b orelse b = integer =
INTEGER

math ops (ub, b):

ub + b = max =
INTEGER
ub - b = max =
INTEGER
ub * b = max =
INTEGER
ub / b = float =
DOUBLE
ub ^ b = float =
DOUBLE
ub \ b = non-float =
INTEGER
ub mod b = non-float =
INTEGER

bitops (ub, b):

ub shl b = non-float =
INTEGER
ub shr b = non-float =
INTEGER
ub and b = non-float =
INTEGER
ub or b = non-float =
INTEGER
ub xor b = non-float =
INTEGER
ub eqv b = non-float =
INTEGER
ub imp b = non-float =
INTEGER

relational ops (ub, b):

ub = b = integer =
INTEGER
ub > b = integer =
INTEGER
ub < b = integer =
INTEGER
ub <> b = integer =
INTEGER
ub <= b = integer =
INTEGER
ub >= b = integer =
INTEGER
ub andalso b = integer =
INTEGER
ub orelse b = integer =
INTEGER

math ops (sh, b):

sh + b = max =
INTEGER
sh - b = max =
INTEGER
sh * b = max =
INTEGER
sh / b = float =
DOUBLE
sh ^ b = float =
DOUBLE
sh \ b = non-float =
INTEGER
sh mod b = non-float =
INTEGER

bitops (sh, b):

sh shl b = non-float =
INTEGER
sh shr b = non-float =
INTEGER
sh and b = non-float =
INTEGER
sh or b = non-float =
INTEGER
sh xor b = non-float =
INTEGER
sh eqv b = non-float =
INTEGER
sh imp b = non-float =
INTEGER

relational ops (sh, b):

sh = b = integer =
INTEGER
sh > b = integer =
INTEGER
sh < b = integer =
INTEGER
sh <> b = integer =
INTEGER
sh <= b = integer =
INTEGER
sh >= b = integer =
INTEGER
sh andalso b = integer =
INTEGER
sh orelse b = integer =
INTEGER

math ops (ush, b):

ush + b = max =
INTEGER
ush - b = max =
INTEGER
ush * b = max =
INTEGER
ush / b = float =
DOUBLE
ush ^ b = float =
DOUBLE
ush \ b = non-float =
INTEGER
ush mod b = non-float =
INTEGER

bitops (ush, b):

ush shl b = non-float =
INTEGER
ush shr b = non-float =
INTEGER
ush and b = non-float =
INTEGER
ush or b = non-float =
INTEGER
ush xor b = non-float =
INTEGER
ush eqv b = non-float =
INTEGER
ush imp b = non-float =
INTEGER

relational ops (ush, b):

ush = b = integer =
INTEGER
ush > b = integer =
INTEGER
ush < b = integer =
INTEGER
ush <> b = integer =
INTEGER
ush <= b = integer =
INTEGER
ush >= b = integer =
INTEGER
ush andalso b = integer =
INTEGER
ush orelse b = integer =
INTEGER

math ops (i, b):

i + b = max =
INTEGER
i - b = max =
INTEGER
i * b = max =
INTEGER
i / b = float =
DOUBLE
i ^ b = float =
DOUBLE
i \ b = non-float =
INTEGER
i mod b = non-float =
INTEGER

bitops (i, b):

i shl b = non-float =
INTEGER
i shr b = non-float =
INTEGER
i and b = non-float =
INTEGER
i or b = non-float =
INTEGER
i xor b = non-float =
INTEGER
i eqv b = non-float =
INTEGER
i imp b = non-float =
INTEGER

relational ops (i, b):

i = b = integer =
INTEGER
i > b = integer =
INTEGER
i < b = integer =
INTEGER
i <> b = integer =
INTEGER
i <= b = integer =
INTEGER
i >= b = integer =
INTEGER
i andalso b = integer =
INTEGER
i orelse b = integer =
INTEGER

math ops (ui, b):

ui + b = max =
UINTEGER
ui - b = max =
UINTEGER
ui * b = max =
UINTEGER
ui / b = float =
DOUBLE
ui ^ b = float =
DOUBLE
ui \ b = non-float =
UINTEGER
ui mod b = non-float =
UINTEGER

bitops (ui, b):

ui shl b = non-float =
UINTEGER
ui shr b = non-float =
UINTEGER
ui and b = non-float =
UINTEGER
ui or b = non-float =
UINTEGER
ui xor b = non-float =
UINTEGER
ui eqv b = non-float =
UINTEGER
ui imp b = non-float =
UINTEGER

relational ops (ui, b):

ui = b = integer =
INTEGER
ui > b = integer =
INTEGER
ui < b = integer =
INTEGER
ui <> b = integer =
INTEGER
ui <= b = integer =
INTEGER
ui >= b = integer =
INTEGER
ui andalso b = integer =
INTEGER
ui orelse b = integer =
INTEGER

math ops (l, b):

l + b = max =
INTEGER
l - b = max =
INTEGER
l * b = max =
INTEGER
l / b = float =
DOUBLE
l ^ b = float =
DOUBLE
l \ b = non-float =
INTEGER
l mod b = non-float =
INTEGER

bitops (l, b):

l shl b = non-float =
INTEGER
l shr b = non-float =
INTEGER
l and b = non-float =
INTEGER
l or b = non-float =
INTEGER
l xor b = non-float =
INTEGER
l eqv b = non-float =
INTEGER
l imp b = non-float =
INTEGER

relational ops (l, b):

l = b = integer =
INTEGER
l > b = integer =
INTEGER
l < b = integer =
INTEGER
l <> b = integer =
INTEGER
l <= b = integer =
INTEGER
l >= b = integer =
INTEGER
l andalso b = integer =
INTEGER
l orelse b = integer =
INTEGER

math ops (ul, b):

ul + b = max =
INTEGER
ul - b = max =
INTEGER
ul * b = max =
INTEGER
ul / b = float =
DOUBLE
ul ^ b = float =
DOUBLE
ul \ b = non-float =
INTEGER
ul mod b = non-float =
INTEGER

bitops (ul, b):

ul shl b = non-float =
INTEGER
ul shr b = non-float =
INTEGER
ul and b = non-float =
INTEGER
ul or b = non-float =
INTEGER
ul xor b = non-float =
INTEGER
ul eqv b = non-float =
INTEGER
ul imp b = non-float =
INTEGER

relational ops (ul, b):

ul = b = integer =
INTEGER
ul > b = integer =
INTEGER
ul < b = integer =
INTEGER
ul <> b = integer =
INTEGER
ul <= b = integer =
INTEGER
ul >= b = integer =
INTEGER
ul andalso b = integer =
INTEGER
ul orelse b = integer =
INTEGER

math ops (ll, b):

ll + b = max =
INTEGER
ll - b = max =
INTEGER
ll * b = max =
INTEGER
ll / b = float =
DOUBLE
ll ^ b = float =
DOUBLE
ll \ b = non-float =
INTEGER
ll mod b = non-float =
INTEGER

bitops (ll, b):

ll shl b = non-float =
INTEGER
ll shr b = non-float =
INTEGER
ll and b = non-float =
INTEGER
ll or b = non-float =
INTEGER
ll xor b = non-float =
INTEGER
ll eqv b = non-float =
INTEGER
ll imp b = non-float =
INTEGER

relational ops (ll, b):

ll = b = integer =
INTEGER
ll > b = integer =
INTEGER
ll < b = integer =
INTEGER
ll <> b = integer =
INTEGER
ll <= b = integer =
INTEGER
ll >= b = integer =
INTEGER
ll andalso b = integer =
INTEGER
ll orelse b = integer =
INTEGER

math ops (ull, b):

ull + b = max =
UINTEGER
ull - b = max =
UINTEGER
ull * b = max =
UINTEGER
ull / b = float =
DOUBLE
ull ^ b = float =
DOUBLE
ull \ b = non-float =
UINTEGER
ull mod b = non-float =
UINTEGER

bitops (ull, b):

ull shl b = non-float =
UINTEGER
ull shr b = non-float =
UINTEGER
ull and b = non-float =
UINTEGER
ull or b = non-float =
UINTEGER
ull xor b = non-float =
UINTEGER
ull eqv b = non-float =
UINTEGER
ull imp b = non-float =
UINTEGER

relational ops (ull, b):

ull = b = integer =
INTEGER
ull > b = integer =
INTEGER
ull < b = integer =
INTEGER
ull <> b = integer =
INTEGER
ull <= b = integer =
INTEGER
ull >= b = integer =
INTEGER
ull andalso b = integer =
INTEGER
ull orelse b = integer =
INTEGER

math ops (enum1a, b):

enum1a + b = max =
INTEGER
enum1a - b = max =
INTEGER
enum1a * b = max =
INTEGER
enum1a / b = float =
DOUBLE
enum1a ^ b = float =
DOUBLE
enum1a \ b = non-float =
INTEGER
enum1a mod b = non-float =
INTEGER

bitops (enum1a, b):

enum1a shl b = non-float =
INTEGER
enum1a shr b = non-float =
INTEGER
enum1a and b = non-float =
INTEGER
enum1a or b = non-float =
INTEGER
enum1a xor b = non-float =
INTEGER
enum1a eqv b = non-float =
INTEGER
enum1a imp b = non-float =
INTEGER

relational ops (enum1a, b):

enum1a = b = integer =
INTEGER
enum1a > b = integer =
INTEGER
enum1a < b = integer =
INTEGER
enum1a <> b = integer =
INTEGER
enum1a <= b = integer =
INTEGER
enum1a >= b = integer =
INTEGER
enum1a andalso b = integer =
INTEGER
enum1a orelse b = integer =
INTEGER

math ops (b, f):

b + f = max =
SINGLE
b - f = max =
SINGLE
b * f = max =
SINGLE
b / f = float =
DOUBLE
b ^ f = float =
DOUBLE
b \ f = non-float =
INTEGER
b mod f = non-float =
INTEGER

bitops (b, f):

b shl f = non-float =
INTEGER
b shr f = non-float =
INTEGER
b and f = non-float =
INTEGER
b or f = non-float =
INTEGER
b xor f = non-float =
INTEGER
b eqv f = non-float =
INTEGER
b imp f = non-float =
INTEGER

relational ops (b, f):

b = f = integer =
INTEGER
b > f = integer =
INTEGER
b < f = integer =
INTEGER
b <> f = integer =
INTEGER
b <= f = integer =
INTEGER
b >= f = integer =
INTEGER
b andalso f = integer =
INTEGER
b orelse f = integer =
INTEGER

math ops (b, d):

b + d = max =
DOUBLE
b - d = max =
DOUBLE
b * d = max =
DOUBLE
b / d = float =
DOUBLE
b ^ d = float =
DOUBLE
b \ d = non-float =
INTEGER
b mod d = non-float =
INTEGER

bitops (b, d):

b shl d = non-float =
INTEGER
b shr d = non-float =
INTEGER
b and d = non-float =
INTEGER
b or d = non-float =
INTEGER
b xor d = non-float =
INTEGER
b eqv d = non-float =
INTEGER
b imp d = non-float =
INTEGER

relational ops (b, d):

b = d = integer =
INTEGER
b > d = integer =
INTEGER
b < d = integer =
INTEGER
b <> d = integer =
INTEGER
b <= d = integer =
INTEGER
b >= d = integer =
INTEGER
b andalso d = integer =
INTEGER
b orelse d = integer =
INTEGER

math ops (f, b):

f + b = max =
SINGLE
f - b = max =
SINGLE
f * b = max =
SINGLE
f / b = float =
DOUBLE
f ^ b = float =
DOUBLE
f \ b = non-float =
INTEGER
f mod b = non-float =
INTEGER

bitops (f, b):

f shl b = non-float =
INTEGER
f shr b = non-float =
INTEGER
f and b = non-float =
INTEGER
f or b = non-float =
INTEGER
f xor b = non-float =
INTEGER
f eqv b = non-float =
INTEGER
f imp b = non-float =
INTEGER

relational ops (f, b):

f = b = integer =
INTEGER
f > b = integer =
INTEGER
f < b = integer =
INTEGER
f <> b = integer =
INTEGER
f <= b = integer =
INTEGER
f >= b = integer =
INTEGER
f andalso b = integer =
INTEGER
f orelse b = integer =
INTEGER

math ops (d, b):

d + b = max =
DOUBLE
d - b = max =
DOUBLE
d * b = max =
DOUBLE
d / b = float =
DOUBLE
d ^ b = float =
DOUBLE
d \ b = non-float =
INTEGER
d mod b = non-float =
INTEGER

bitops (d, b):

d shl b = non-float =
INTEGER
d shr b = non-float =
INTEGER
d and b = non-float =
INTEGER
d or b = non-float =
INTEGER
d xor b = non-float =
INTEGER
d eqv b = non-float =
INTEGER
d imp b = non-float =
INTEGER

relational ops (d, b):

d = b = integer =
INTEGER
d > b = integer =
INTEGER
d < b = integer =
INTEGER
d <> b = integer =
INTEGER
d <= b = integer =
INTEGER
d >= b = integer =
INTEGER
d andalso b = integer =
INTEGER
d orelse b = integer =
INTEGER

----- ub -----------------------------------------------------


math ops (ub, b):

ub + b = max =
INTEGER
ub - b = max =
INTEGER
ub * b = max =
INTEGER
ub / b = float =
DOUBLE
ub ^ b = float =
DOUBLE
ub \ b = non-float =
INTEGER
ub mod b = non-float =
INTEGER

bitops (ub, b):

ub shl b = non-float =
INTEGER
ub shr b = non-float =
INTEGER
ub and b = non-float =
INTEGER
ub or b = non-float =
INTEGER
ub xor b = non-float =
INTEGER
ub eqv b = non-float =
INTEGER
ub imp b = non-float =
INTEGER

relational ops (ub, b):

ub = b = integer =
INTEGER
ub > b = integer =
INTEGER
ub < b = integer =
INTEGER
ub <> b = integer =
INTEGER
ub <= b = integer =
INTEGER
ub >= b = integer =
INTEGER
ub andalso b = integer =
INTEGER
ub orelse b = integer =
INTEGER

math ops (ub, ub):

ub + ub = max =
INTEGER
ub - ub = max =
INTEGER
ub * ub = max =
INTEGER
ub / ub = float =
DOUBLE
ub ^ ub = float =
DOUBLE
ub \ ub = non-float =
INTEGER
ub mod ub = non-float =
INTEGER

bitops (ub, ub):

ub shl ub = non-float =
INTEGER
ub shr ub = non-float =
INTEGER
ub and ub = non-float =
INTEGER
ub or ub = non-float =
INTEGER
ub xor ub = non-float =
INTEGER
ub eqv ub = non-float =
INTEGER
ub imp ub = non-float =
INTEGER

relational ops (ub, ub):

ub = ub = integer =
INTEGER
ub > ub = integer =
INTEGER
ub < ub = integer =
INTEGER
ub <> ub = integer =
INTEGER
ub <= ub = integer =
INTEGER
ub >= ub = integer =
INTEGER
ub andalso ub = integer =
INTEGER
ub orelse ub = integer =
INTEGER

math ops (ub, sh):

ub + sh = max =
INTEGER
ub - sh = max =
INTEGER
ub * sh = max =
INTEGER
ub / sh = float =
DOUBLE
ub ^ sh = float =
DOUBLE
ub \ sh = non-float =
INTEGER
ub mod sh = non-float =
INTEGER

bitops (ub, sh):

ub shl sh = non-float =
INTEGER
ub shr sh = non-float =
INTEGER
ub and sh = non-float =
INTEGER
ub or sh = non-float =
INTEGER
ub xor sh = non-float =
INTEGER
ub eqv sh = non-float =
INTEGER
ub imp sh = non-float =
INTEGER

relational ops (ub, sh):

ub = sh = integer =
INTEGER
ub > sh = integer =
INTEGER
ub < sh = integer =
INTEGER
ub <> sh = integer =
INTEGER
ub <= sh = integer =
INTEGER
ub >= sh = integer =
INTEGER
ub andalso sh = integer =
INTEGER
ub orelse sh = integer =
INTEGER

math ops (ub, ush):

ub + ush = max =
INTEGER
ub - ush = max =
INTEGER
ub * ush = max =
INTEGER
ub / ush = float =
DOUBLE
ub ^ ush = float =
DOUBLE
ub \ ush = non-float =
INTEGER
ub mod ush = non-float =
INTEGER

bitops (ub, ush):

ub shl ush = non-float =
INTEGER
ub shr ush = non-float =
INTEGER
ub and ush = non-float =
INTEGER
ub or ush = non-float =
INTEGER
ub xor ush = non-float =
INTEGER
ub eqv ush = non-float =
INTEGER
ub imp ush = non-float =
INTEGER

relational ops (ub, ush):

ub = ush = integer =
INTEGER
ub > ush = integer =
INTEGER
ub < ush = integer =
INTEGER
ub <> ush = integer =
INTEGER
ub <= ush = integer =
INTEGER
ub >= ush = integer =
INTEGER
ub andalso ush = integer =
INTEGER
ub orelse ush = integer =
INTEGER

math ops (ub, i):

ub + i = max =
INTEGER
ub - i = max =
INTEGER
ub * i = max =
INTEGER
ub / i = float =
DOUBLE
ub ^ i = float =
DOUBLE
ub \ i = non-float =
INTEGER
ub mod i = non-float =
INTEGER

bitops (ub, i):

ub shl i = non-float =
INTEGER
ub shr i = non-float =
INTEGER
ub and i = non-float =
INTEGER
ub or i = non-float =
INTEGER
ub xor i = non-float =
INTEGER
ub eqv i = non-float =
INTEGER
ub imp i = non-float =
INTEGER

relational ops (ub, i):

ub = i = integer =
INTEGER
ub > i = integer =
INTEGER
ub < i = integer =
INTEGER
ub <> i = integer =
INTEGER
ub <= i = integer =
INTEGER
ub >= i = integer =
INTEGER
ub andalso i = integer =
INTEGER
ub orelse i = integer =
INTEGER

math ops (ub, ui):

ub + ui = max =
UINTEGER
ub - ui = max =
UINTEGER
ub * ui = max =
UINTEGER
ub / ui = float =
DOUBLE
ub ^ ui = float =
DOUBLE
ub \ ui = non-float =
UINTEGER
ub mod ui = non-float =
UINTEGER

bitops (ub, ui):

ub shl ui = non-float =
UINTEGER
ub shr ui = non-float =
UINTEGER
ub and ui = non-float =
UINTEGER
ub or ui = non-float =
UINTEGER
ub xor ui = non-float =
UINTEGER
ub eqv ui = non-float =
UINTEGER
ub imp ui = non-float =
UINTEGER

relational ops (ub, ui):

ub = ui = integer =
INTEGER
ub > ui = integer =
INTEGER
ub < ui = integer =
INTEGER
ub <> ui = integer =
INTEGER
ub <= ui = integer =
INTEGER
ub >= ui = integer =
INTEGER
ub andalso ui = integer =
INTEGER
ub orelse ui = integer =
INTEGER

math ops (ub, l):

ub + l = max =
INTEGER
ub - l = max =
INTEGER
ub * l = max =
INTEGER
ub / l = float =
DOUBLE
ub ^ l = float =
DOUBLE
ub \ l = non-float =
INTEGER
ub mod l = non-float =
INTEGER

bitops (ub, l):

ub shl l = non-float =
INTEGER
ub shr l = non-float =
INTEGER
ub and l = non-float =
INTEGER
ub or l = non-float =
INTEGER
ub xor l = non-float =
INTEGER
ub eqv l = non-float =
INTEGER
ub imp l = non-float =
INTEGER

relational ops (ub, l):

ub = l = integer =
INTEGER
ub > l = integer =
INTEGER
ub < l = integer =
INTEGER
ub <> l = integer =
INTEGER
ub <= l = integer =
INTEGER
ub >= l = integer =
INTEGER
ub andalso l = integer =
INTEGER
ub orelse l = integer =
INTEGER

math ops (ub, ul):

ub + ul = max =
INTEGER
ub - ul = max =
INTEGER
ub * ul = max =
INTEGER
ub / ul = float =
DOUBLE
ub ^ ul = float =
DOUBLE
ub \ ul = non-float =
INTEGER
ub mod ul = non-float =
INTEGER

bitops (ub, ul):

ub shl ul = non-float =
INTEGER
ub shr ul = non-float =
INTEGER
ub and ul = non-float =
INTEGER
ub or ul = non-float =
INTEGER
ub xor ul = non-float =
INTEGER
ub eqv ul = non-float =
INTEGER
ub imp ul = non-float =
INTEGER

relational ops (ub, ul):

ub = ul = integer =
INTEGER
ub > ul = integer =
INTEGER
ub < ul = integer =
INTEGER
ub <> ul = integer =
INTEGER
ub <= ul = integer =
INTEGER
ub >= ul = integer =
INTEGER
ub andalso ul = integer =
INTEGER
ub orelse ul = integer =
INTEGER

math ops (ub, ll):

ub + ll = max =
INTEGER
ub - ll = max =
INTEGER
ub * ll = max =
INTEGER
ub / ll = float =
DOUBLE
ub ^ ll = float =
DOUBLE
ub \ ll = non-float =
INTEGER
ub mod ll = non-float =
INTEGER

bitops (ub, ll):

ub shl ll = non-float =
INTEGER
ub shr ll = non-float =
INTEGER
ub and ll = non-float =
INTEGER
ub or ll = non-float =
INTEGER
ub xor ll = non-float =
INTEGER
ub eqv ll = non-float =
INTEGER
ub imp ll = non-float =
INTEGER

relational ops (ub, ll):

ub = ll = integer =
INTEGER
ub > ll = integer =
INTEGER
ub < ll = integer =
INTEGER
ub <> ll = integer =
INTEGER
ub <= ll = integer =
INTEGER
ub >= ll = integer =
INTEGER
ub andalso ll = integer =
INTEGER
ub orelse ll = integer =
INTEGER

math ops (ub, ull):

ub + ull = max =
UINTEGER
ub - ull = max =
UINTEGER
ub * ull = max =
UINTEGER
ub / ull = float =
DOUBLE
ub ^ ull = float =
DOUBLE
ub \ ull = non-float =
UINTEGER
ub mod ull = non-float =
UINTEGER

bitops (ub, ull):

ub shl ull = non-float =
UINTEGER
ub shr ull = non-float =
UINTEGER
ub and ull = non-float =
UINTEGER
ub or ull = non-float =
UINTEGER
ub xor ull = non-float =
UINTEGER
ub eqv ull = non-float =
UINTEGER
ub imp ull = non-float =
UINTEGER

relational ops (ub, ull):

ub = ull = integer =
INTEGER
ub > ull = integer =
INTEGER
ub < ull = integer =
INTEGER
ub <> ull = integer =
INTEGER
ub <= ull = integer =
INTEGER
ub >= ull = integer =
INTEGER
ub andalso ull = integer =
INTEGER
ub orelse ull = integer =
INTEGER

math ops (ub, enum1a):

ub + enum1a = max =
INTEGER
ub - enum1a = max =
INTEGER
ub * enum1a = max =
INTEGER
ub / enum1a = float =
DOUBLE
ub ^ enum1a = float =
DOUBLE
ub \ enum1a = non-float =
INTEGER
ub mod enum1a = non-float =
INTEGER

bitops (ub, enum1a):

ub shl enum1a = non-float =
INTEGER
ub shr enum1a = non-float =
INTEGER
ub and enum1a = non-float =
INTEGER
ub or enum1a = non-float =
INTEGER
ub xor enum1a = non-float =
INTEGER
ub eqv enum1a = non-float =
INTEGER
ub imp enum1a = non-float =
INTEGER

relational ops (ub, enum1a):

ub = enum1a = integer =
INTEGER
ub > enum1a = integer =
INTEGER
ub < enum1a = integer =
INTEGER
ub <> enum1a = integer =
INTEGER
ub <= enum1a = integer =
INTEGER
ub >= enum1a = integer =
INTEGER
ub andalso enum1a = integer =
INTEGER
ub orelse enum1a = integer =
INTEGER

math ops (b, ub):

b + ub = max =
INTEGER
b - ub = max =
INTEGER
b * ub = max =
INTEGER
b / ub = float =
DOUBLE
b ^ ub = float =
DOUBLE
b \ ub = non-float =
INTEGER
b mod ub = non-float =
INTEGER

bitops (b, ub):

b shl ub = non-float =
INTEGER
b shr ub = non-float =
INTEGER
b and ub = non-float =
INTEGER
b or ub = non-float =
INTEGER
b xor ub = non-float =
INTEGER
b eqv ub = non-float =
INTEGER
b imp ub = non-float =
INTEGER

relational ops (b, ub):

b = ub = integer =
INTEGER
b > ub = integer =
INTEGER
b < ub = integer =
INTEGER
b <> ub = integer =
INTEGER
b <= ub = integer =
INTEGER
b >= ub = integer =
INTEGER
b andalso ub = integer =
INTEGER
b orelse ub = integer =
INTEGER

math ops (ub, ub):

ub + ub = max =
INTEGER
ub - ub = max =
INTEGER
ub * ub = max =
INTEGER
ub / ub = float =
DOUBLE
ub ^ ub = float =
DOUBLE
ub \ ub = non-float =
INTEGER
ub mod ub = non-float =
INTEGER

bitops (ub, ub):

ub shl ub = non-float =
INTEGER
ub shr ub = non-float =
INTEGER
ub and ub = non-float =
INTEGER
ub or ub = non-float =
INTEGER
ub xor ub = non-float =
INTEGER
ub eqv ub = non-float =
INTEGER
ub imp ub = non-float =
INTEGER

relational ops (ub, ub):

ub = ub = integer =
INTEGER
ub > ub = integer =
INTEGER
ub < ub = integer =
INTEGER
ub <> ub = integer =
INTEGER
ub <= ub = integer =
INTEGER
ub >= ub = integer =
INTEGER
ub andalso ub = integer =
INTEGER
ub orelse ub = integer =
INTEGER

math ops (sh, ub):

sh + ub = max =
INTEGER
sh - ub = max =
INTEGER
sh * ub = max =
INTEGER
sh / ub = float =
DOUBLE
sh ^ ub = float =
DOUBLE
sh \ ub = non-float =
INTEGER
sh mod ub = non-float =
INTEGER

bitops (sh, ub):

sh shl ub = non-float =
INTEGER
sh shr ub = non-float =
INTEGER
sh and ub = non-float =
INTEGER
sh or ub = non-float =
INTEGER
sh xor ub = non-float =
INTEGER
sh eqv ub = non-float =
INTEGER
sh imp ub = non-float =
INTEGER

relational ops (sh, ub):

sh = ub = integer =
INTEGER
sh > ub = integer =
INTEGER
sh < ub = integer =
INTEGER
sh <> ub = integer =
INTEGER
sh <= ub = integer =
INTEGER
sh >= ub = integer =
INTEGER
sh andalso ub = integer =
INTEGER
sh orelse ub = integer =
INTEGER

math ops (ush, ub):

ush + ub = max =
INTEGER
ush - ub = max =
INTEGER
ush * ub = max =
INTEGER
ush / ub = float =
DOUBLE
ush ^ ub = float =
DOUBLE
ush \ ub = non-float =
INTEGER
ush mod ub = non-float =
INTEGER

bitops (ush, ub):

ush shl ub = non-float =
INTEGER
ush shr ub = non-float =
INTEGER
ush and ub = non-float =
INTEGER
ush or ub = non-float =
INTEGER
ush xor ub = non-float =
INTEGER
ush eqv ub = non-float =
INTEGER
ush imp ub = non-float =
INTEGER

relational ops (ush, ub):

ush = ub = integer =
INTEGER
ush > ub = integer =
INTEGER
ush < ub = integer =
INTEGER
ush <> ub = integer =
INTEGER
ush <= ub = integer =
INTEGER
ush >= ub = integer =
INTEGER
ush andalso ub = integer =
INTEGER
ush orelse ub = integer =
INTEGER

math ops (i, ub):

i + ub = max =
INTEGER
i - ub = max =
INTEGER
i * ub = max =
INTEGER
i / ub = float =
DOUBLE
i ^ ub = float =
DOUBLE
i \ ub = non-float =
INTEGER
i mod ub = non-float =
INTEGER

bitops (i, ub):

i shl ub = non-float =
INTEGER
i shr ub = non-float =
INTEGER
i and ub = non-float =
INTEGER
i or ub = non-float =
INTEGER
i xor ub = non-float =
INTEGER
i eqv ub = non-float =
INTEGER
i imp ub = non-float =
INTEGER

relational ops (i, ub):

i = ub = integer =
INTEGER
i > ub = integer =
INTEGER
i < ub = integer =
INTEGER
i <> ub = integer =
INTEGER
i <= ub = integer =
INTEGER
i >= ub = integer =
INTEGER
i andalso ub = integer =
INTEGER
i orelse ub = integer =
INTEGER

math ops (ui, ub):

ui + ub = max =
UINTEGER
ui - ub = max =
UINTEGER
ui * ub = max =
UINTEGER
ui / ub = float =
DOUBLE
ui ^ ub = float =
DOUBLE
ui \ ub = non-float =
UINTEGER
ui mod ub = non-float =
UINTEGER

bitops (ui, ub):

ui shl ub = non-float =
UINTEGER
ui shr ub = non-float =
UINTEGER
ui and ub = non-float =
UINTEGER
ui or ub = non-float =
UINTEGER
ui xor ub = non-float =
UINTEGER
ui eqv ub = non-float =
UINTEGER
ui imp ub = non-float =
UINTEGER

relational ops (ui, ub):

ui = ub = integer =
INTEGER
ui > ub = integer =
INTEGER
ui < ub = integer =
INTEGER
ui <> ub = integer =
INTEGER
ui <= ub = integer =
INTEGER
ui >= ub = integer =
INTEGER
ui andalso ub = integer =
INTEGER
ui orelse ub = integer =
INTEGER

math ops (l, ub):

l + ub = max =
INTEGER
l - ub = max =
INTEGER
l * ub = max =
INTEGER
l / ub = float =
DOUBLE
l ^ ub = float =
DOUBLE
l \ ub = non-float =
INTEGER
l mod ub = non-float =
INTEGER

bitops (l, ub):

l shl ub = non-float =
INTEGER
l shr ub = non-float =
INTEGER
l and ub = non-float =
INTEGER
l or ub = non-float =
INTEGER
l xor ub = non-float =
INTEGER
l eqv ub = non-float =
INTEGER
l imp ub = non-float =
INTEGER

relational ops (l, ub):

l = ub = integer =
INTEGER
l > ub = integer =
INTEGER
l < ub = integer =
INTEGER
l <> ub = integer =
INTEGER
l <= ub = integer =
INTEGER
l >= ub = integer =
INTEGER
l andalso ub = integer =
INTEGER
l orelse ub = integer =
INTEGER

math ops (ul, ub):

ul + ub = max =
INTEGER
ul - ub = max =
INTEGER
ul * ub = max =
INTEGER
ul / ub = float =
DOUBLE
ul ^ ub = float =
DOUBLE
ul \ ub = non-float =
INTEGER
ul mod ub = non-float =
INTEGER

bitops (ul, ub):

ul shl ub = non-float =
INTEGER
ul shr ub = non-float =
INTEGER
ul and ub = non-float =
INTEGER
ul or ub = non-float =
INTEGER
ul xor ub = non-float =
INTEGER
ul eqv ub = non-float =
INTEGER
ul imp ub = non-float =
INTEGER

relational ops (ul, ub):

ul = ub = integer =
INTEGER
ul > ub = integer =
INTEGER
ul < ub = integer =
INTEGER
ul <> ub = integer =
INTEGER
ul <= ub = integer =
INTEGER
ul >= ub = integer =
INTEGER
ul andalso ub = integer =
INTEGER
ul orelse ub = integer =
INTEGER

math ops (ll, ub):

ll + ub = max =
INTEGER
ll - ub = max =
INTEGER
ll * ub = max =
INTEGER
ll / ub = float =
DOUBLE
ll ^ ub = float =
DOUBLE
ll \ ub = non-float =
INTEGER
ll mod ub = non-float =
INTEGER

bitops (ll, ub):

ll shl ub = non-float =
INTEGER
ll shr ub = non-float =
INTEGER
ll and ub = non-float =
INTEGER
ll or ub = non-float =
INTEGER
ll xor ub = non-float =
INTEGER
ll eqv ub = non-float =
INTEGER
ll imp ub = non-float =
INTEGER

relational ops (ll, ub):

ll = ub = integer =
INTEGER
ll > ub = integer =
INTEGER
ll < ub = integer =
INTEGER
ll <> ub = integer =
INTEGER
ll <= ub = integer =
INTEGER
ll >= ub = integer =
INTEGER
ll andalso ub = integer =
INTEGER
ll orelse ub = integer =
INTEGER

math ops (ull, ub):

ull + ub = max =
UINTEGER
ull - ub = max =
UINTEGER
ull * ub = max =
UINTEGER
ull / ub = float =
DOUBLE
ull ^ ub = float =
DOUBLE
ull \ ub = non-float =
UINTEGER
ull mod ub = non-float =
UINTEGER

bitops (ull, ub):

ull shl ub = non-float =
UINTEGER
ull shr ub = non-float =
UINTEGER
ull and ub = non-float =
UINTEGER
ull or ub = non-float =
UINTEGER
ull xor ub = non-float =
UINTEGER
ull eqv ub = non-float =
UINTEGER
ull imp ub = non-float =
UINTEGER

relational ops (ull, ub):

ull = ub = integer =
INTEGER
ull > ub = integer =
INTEGER
ull < ub = integer =
INTEGER
ull <> ub = integer =
INTEGER
ull <= ub = integer =
INTEGER
ull >= ub = integer =
INTEGER
ull andalso ub = integer =
INTEGER
ull orelse ub = integer =
INTEGER

math ops (enum1a, ub):

enum1a + ub = max =
INTEGER
enum1a - ub = max =
INTEGER
enum1a * ub = max =
INTEGER
enum1a / ub = float =
DOUBLE
enum1a ^ ub = float =
DOUBLE
enum1a \ ub = non-float =
INTEGER
enum1a mod ub = non-float =
INTEGER

bitops (enum1a, ub):

enum1a shl ub = non-float =
INTEGER
enum1a shr ub = non-float =
INTEGER
enum1a and ub = non-float =
INTEGER
enum1a or ub = non-float =
INTEGER
enum1a xor ub = non-float =
INTEGER
enum1a eqv ub = non-float =
INTEGER
enum1a imp ub = non-float =
INTEGER

relational ops (enum1a, ub):

enum1a = ub = integer =
INTEGER
enum1a > ub = integer =
INTEGER
enum1a < ub = integer =
INTEGER
enum1a <> ub = integer =
INTEGER
enum1a <= ub = integer =
INTEGER
enum1a >= ub = integer =
INTEGER
enum1a andalso ub = integer =
INTEGER
enum1a orelse ub = integer =
INTEGER

math ops (ub, f):

ub + f = max =
SINGLE
ub - f = max =
SINGLE
ub * f = max =
SINGLE
ub / f = float =
DOUBLE
ub ^ f = float =
DOUBLE
ub \ f = non-float =
INTEGER
ub mod f = non-float =
INTEGER

bitops (ub, f):

ub shl f = non-float =
INTEGER
ub shr f = non-float =
INTEGER
ub and f = non-float =
INTEGER
ub or f = non-float =
INTEGER
ub xor f = non-float =
INTEGER
ub eqv f = non-float =
INTEGER
ub imp f = non-float =
INTEGER

relational ops (ub, f):

ub = f = integer =
INTEGER
ub > f = integer =
INTEGER
ub < f = integer =
INTEGER
ub <> f = integer =
INTEGER
ub <= f = integer =
INTEGER
ub >= f = integer =
INTEGER
ub andalso f = integer =
INTEGER
ub orelse f = integer =
INTEGER

math ops (ub, d):

ub + d = max =
DOUBLE
ub - d = max =
DOUBLE
ub * d = max =
DOUBLE
ub / d = float =
DOUBLE
ub ^ d = float =
DOUBLE
ub \ d = non-float =
INTEGER
ub mod d = non-float =
INTEGER

bitops (ub, d):

ub shl d = non-float =
INTEGER
ub shr d = non-float =
INTEGER
ub and d = non-float =
INTEGER
ub or d = non-float =
INTEGER
ub xor d = non-float =
INTEGER
ub eqv d = non-float =
INTEGER
ub imp d = non-float =
INTEGER

relational ops (ub, d):

ub = d = integer =
INTEGER
ub > d = integer =
INTEGER
ub < d = integer =
INTEGER
ub <> d = integer =
INTEGER
ub <= d = integer =
INTEGER
ub >= d = integer =
INTEGER
ub andalso d = integer =
INTEGER
ub orelse d = integer =
INTEGER

math ops (f, ub):

f + ub = max =
SINGLE
f - ub = max =
SINGLE
f * ub = max =
SINGLE
f / ub = float =
DOUBLE
f ^ ub = float =
DOUBLE
f \ ub = non-float =
INTEGER
f mod ub = non-float =
INTEGER

bitops (f, ub):

f shl ub = non-float =
INTEGER
f shr ub = non-float =
INTEGER
f and ub = non-float =
INTEGER
f or ub = non-float =
INTEGER
f xor ub = non-float =
INTEGER
f eqv ub = non-float =
INTEGER
f imp ub = non-float =
INTEGER

relational ops (f, ub):

f = ub = integer =
INTEGER
f > ub = integer =
INTEGER
f < ub = integer =
INTEGER
f <> ub = integer =
INTEGER
f <= ub = integer =
INTEGER
f >= ub = integer =
INTEGER
f andalso ub = integer =
INTEGER
f orelse ub = integer =
INTEGER

math ops (d, ub):

d + ub = max =
DOUBLE
d - ub = max =
DOUBLE
d * ub = max =
DOUBLE
d / ub = float =
DOUBLE
d ^ ub = float =
DOUBLE
d \ ub = non-float =
INTEGER
d mod ub = non-float =
INTEGER

bitops (d, ub):

d shl ub = non-float =
INTEGER
d shr ub = non-float =
INTEGER
d and ub = non-float =
INTEGER
d or ub = non-float =
INTEGER
d xor ub = non-float =
INTEGER
d eqv ub = non-float =
INTEGER
d imp ub = non-float =
INTEGER

relational ops (d, ub):

d = ub = integer =
INTEGER
d > ub = integer =
INTEGER
d < ub = integer =
INTEGER
d <> ub = integer =
INTEGER
d <= ub = integer =
INTEGER
d >= ub = integer =
INTEGER
d andalso ub = integer =
INTEGER
d orelse ub = integer =
INTEGER

----- sh -----------------------------------------------------


math ops (sh, b):

sh + b = max =
INTEGER
sh - b = max =
INTEGER
sh * b = max =
INTEGER
sh / b = float =
DOUBLE
sh ^ b = float =
DOUBLE
sh \ b = non-float =
INTEGER
sh mod b = non-float =
INTEGER

bitops (sh, b):

sh shl b = non-float =
INTEGER
sh shr b = non-float =
INTEGER
sh and b = non-float =
INTEGER
sh or b = non-float =
INTEGER
sh xor b = non-float =
INTEGER
sh eqv b = non-float =
INTEGER
sh imp b = non-float =
INTEGER

relational ops (sh, b):

sh = b = integer =
INTEGER
sh > b = integer =
INTEGER
sh < b = integer =
INTEGER
sh <> b = integer =
INTEGER
sh <= b = integer =
INTEGER
sh >= b = integer =
INTEGER
sh andalso b = integer =
INTEGER
sh orelse b = integer =
INTEGER

math ops (sh, ub):

sh + ub = max =
INTEGER
sh - ub = max =
INTEGER
sh * ub = max =
INTEGER
sh / ub = float =
DOUBLE
sh ^ ub = float =
DOUBLE
sh \ ub = non-float =
INTEGER
sh mod ub = non-float =
INTEGER

bitops (sh, ub):

sh shl ub = non-float =
INTEGER
sh shr ub = non-float =
INTEGER
sh and ub = non-float =
INTEGER
sh or ub = non-float =
INTEGER
sh xor ub = non-float =
INTEGER
sh eqv ub = non-float =
INTEGER
sh imp ub = non-float =
INTEGER

relational ops (sh, ub):

sh = ub = integer =
INTEGER
sh > ub = integer =
INTEGER
sh < ub = integer =
INTEGER
sh <> ub = integer =
INTEGER
sh <= ub = integer =
INTEGER
sh >= ub = integer =
INTEGER
sh andalso ub = integer =
INTEGER
sh orelse ub = integer =
INTEGER

math ops (sh, sh):

sh + sh = max =
INTEGER
sh - sh = max =
INTEGER
sh * sh = max =
INTEGER
sh / sh = float =
DOUBLE
sh ^ sh = float =
DOUBLE
sh \ sh = non-float =
INTEGER
sh mod sh = non-float =
INTEGER

bitops (sh, sh):

sh shl sh = non-float =
INTEGER
sh shr sh = non-float =
INTEGER
sh and sh = non-float =
INTEGER
sh or sh = non-float =
INTEGER
sh xor sh = non-float =
INTEGER
sh eqv sh = non-float =
INTEGER
sh imp sh = non-float =
INTEGER

relational ops (sh, sh):

sh = sh = integer =
INTEGER
sh > sh = integer =
INTEGER
sh < sh = integer =
INTEGER
sh <> sh = integer =
INTEGER
sh <= sh = integer =
INTEGER
sh >= sh = integer =
INTEGER
sh andalso sh = integer =
INTEGER
sh orelse sh = integer =
INTEGER

math ops (sh, ush):

sh + ush = max =
INTEGER
sh - ush = max =
INTEGER
sh * ush = max =
INTEGER
sh / ush = float =
DOUBLE
sh ^ ush = float =
DOUBLE
sh \ ush = non-float =
INTEGER
sh mod ush = non-float =
INTEGER

bitops (sh, ush):

sh shl ush = non-float =
INTEGER
sh shr ush = non-float =
INTEGER
sh and ush = non-float =
INTEGER
sh or ush = non-float =
INTEGER
sh xor ush = non-float =
INTEGER
sh eqv ush = non-float =
INTEGER
sh imp ush = non-float =
INTEGER

relational ops (sh, ush):

sh = ush = integer =
INTEGER
sh > ush = integer =
INTEGER
sh < ush = integer =
INTEGER
sh <> ush = integer =
INTEGER
sh <= ush = integer =
INTEGER
sh >= ush = integer =
INTEGER
sh andalso ush = integer =
INTEGER
sh orelse ush = integer =
INTEGER

math ops (sh, i):

sh + i = max =
INTEGER
sh - i = max =
INTEGER
sh * i = max =
INTEGER
sh / i = float =
DOUBLE
sh ^ i = float =
DOUBLE
sh \ i = non-float =
INTEGER
sh mod i = non-float =
INTEGER

bitops (sh, i):

sh shl i = non-float =
INTEGER
sh shr i = non-float =
INTEGER
sh and i = non-float =
INTEGER
sh or i = non-float =
INTEGER
sh xor i = non-float =
INTEGER
sh eqv i = non-float =
INTEGER
sh imp i = non-float =
INTEGER

relational ops (sh, i):

sh = i = integer =
INTEGER
sh > i = integer =
INTEGER
sh < i = integer =
INTEGER
sh <> i = integer =
INTEGER
sh <= i = integer =
INTEGER
sh >= i = integer =
INTEGER
sh andalso i = integer =
INTEGER
sh orelse i = integer =
INTEGER

math ops (sh, ui):

sh + ui = max =
UINTEGER
sh - ui = max =
UINTEGER
sh * ui = max =
UINTEGER
sh / ui = float =
DOUBLE
sh ^ ui = float =
DOUBLE
sh \ ui = non-float =
UINTEGER
sh mod ui = non-float =
UINTEGER

bitops (sh, ui):

sh shl ui = non-float =
UINTEGER
sh shr ui = non-float =
UINTEGER
sh and ui = non-float =
UINTEGER
sh or ui = non-float =
UINTEGER
sh xor ui = non-float =
UINTEGER
sh eqv ui = non-float =
UINTEGER
sh imp ui = non-float =
UINTEGER

relational ops (sh, ui):

sh = ui = integer =
INTEGER
sh > ui = integer =
INTEGER
sh < ui = integer =
INTEGER
sh <> ui = integer =
INTEGER
sh <= ui = integer =
INTEGER
sh >= ui = integer =
INTEGER
sh andalso ui = integer =
INTEGER
sh orelse ui = integer =
INTEGER

math ops (sh, l):

sh + l = max =
INTEGER
sh - l = max =
INTEGER
sh * l = max =
INTEGER
sh / l = float =
DOUBLE
sh ^ l = float =
DOUBLE
sh \ l = non-float =
INTEGER
sh mod l = non-float =
INTEGER

bitops (sh, l):

sh shl l = non-float =
INTEGER
sh shr l = non-float =
INTEGER
sh and l = non-float =
INTEGER
sh or l = non-float =
INTEGER
sh xor l = non-float =
INTEGER
sh eqv l = non-float =
INTEGER
sh imp l = non-float =
INTEGER

relational ops (sh, l):

sh = l = integer =
INTEGER
sh > l = integer =
INTEGER
sh < l = integer =
INTEGER
sh <> l = integer =
INTEGER
sh <= l = integer =
INTEGER
sh >= l = integer =
INTEGER
sh andalso l = integer =
INTEGER
sh orelse l = integer =
INTEGER

math ops (sh, ul):

sh + ul = max =
INTEGER
sh - ul = max =
INTEGER
sh * ul = max =
INTEGER
sh / ul = float =
DOUBLE
sh ^ ul = float =
DOUBLE
sh \ ul = non-float =
INTEGER
sh mod ul = non-float =
INTEGER

bitops (sh, ul):

sh shl ul = non-float =
INTEGER
sh shr ul = non-float =
INTEGER
sh and ul = non-float =
INTEGER
sh or ul = non-float =
INTEGER
sh xor ul = non-float =
INTEGER
sh eqv ul = non-float =
INTEGER
sh imp ul = non-float =
INTEGER

relational ops (sh, ul):

sh = ul = integer =
INTEGER
sh > ul = integer =
INTEGER
sh < ul = integer =
INTEGER
sh <> ul = integer =
INTEGER
sh <= ul = integer =
INTEGER
sh >= ul = integer =
INTEGER
sh andalso ul = integer =
INTEGER
sh orelse ul = integer =
INTEGER

math ops (sh, ll):

sh + ll = max =
INTEGER
sh - ll = max =
INTEGER
sh * ll = max =
INTEGER
sh / ll = float =
DOUBLE
sh ^ ll = float =
DOUBLE
sh \ ll = non-float =
INTEGER
sh mod ll = non-float =
INTEGER

bitops (sh, ll):

sh shl ll = non-float =
INTEGER
sh shr ll = non-float =
INTEGER
sh and ll = non-float =
INTEGER
sh or ll = non-float =
INTEGER
sh xor ll = non-float =
INTEGER
sh eqv ll = non-float =
INTEGER
sh imp ll = non-float =
INTEGER

relational ops (sh, ll):

sh = ll = integer =
INTEGER
sh > ll = integer =
INTEGER
sh < ll = integer =
INTEGER
sh <> ll = integer =
INTEGER
sh <= ll = integer =
INTEGER
sh >= ll = integer =
INTEGER
sh andalso ll = integer =
INTEGER
sh orelse ll = integer =
INTEGER

math ops (sh, ull):

sh + ull = max =
UINTEGER
sh - ull = max =
UINTEGER
sh * ull = max =
UINTEGER
sh / ull = float =
DOUBLE
sh ^ ull = float =
DOUBLE
sh \ ull = non-float =
UINTEGER
sh mod ull = non-float =
UINTEGER

bitops (sh, ull):

sh shl ull = non-float =
UINTEGER
sh shr ull = non-float =
UINTEGER
sh and ull = non-float =
UINTEGER
sh or ull = non-float =
UINTEGER
sh xor ull = non-float =
UINTEGER
sh eqv ull = non-float =
UINTEGER
sh imp ull = non-float =
UINTEGER

relational ops (sh, ull):

sh = ull = integer =
INTEGER
sh > ull = integer =
INTEGER
sh < ull = integer =
INTEGER
sh <> ull = integer =
INTEGER
sh <= ull = integer =
INTEGER
sh >= ull = integer =
INTEGER
sh andalso ull = integer =
INTEGER
sh orelse ull = integer =
INTEGER

math ops (sh, enum1a):

sh + enum1a = max =
INTEGER
sh - enum1a = max =
INTEGER
sh * enum1a = max =
INTEGER
sh / enum1a = float =
DOUBLE
sh ^ enum1a = float =
DOUBLE
sh \ enum1a = non-float =
INTEGER
sh mod enum1a = non-float =
INTEGER

bitops (sh, enum1a):

sh shl enum1a = non-float =
INTEGER
sh shr enum1a = non-float =
INTEGER
sh and enum1a = non-float =
INTEGER
sh or enum1a = non-float =
INTEGER
sh xor enum1a = non-float =
INTEGER
sh eqv enum1a = non-float =
INTEGER
sh imp enum1a = non-float =
INTEGER

relational ops (sh, enum1a):

sh = enum1a = integer =
INTEGER
sh > enum1a = integer =
INTEGER
sh < enum1a = integer =
INTEGER
sh <> enum1a = integer =
INTEGER
sh <= enum1a = integer =
INTEGER
sh >= enum1a = integer =
INTEGER
sh andalso enum1a = integer =
INTEGER
sh orelse enum1a = integer =
INTEGER

math ops (b, sh):

b + sh = max =
INTEGER
b - sh = max =
INTEGER
b * sh = max =
INTEGER
b / sh = float =
DOUBLE
b ^ sh = float =
DOUBLE
b \ sh = non-float =
INTEGER
b mod sh = non-float =
INTEGER

bitops (b, sh):

b shl sh = non-float =
INTEGER
b shr sh = non-float =
INTEGER
b and sh = non-float =
INTEGER
b or sh = non-float =
INTEGER
b xor sh = non-float =
INTEGER
b eqv sh = non-float =
INTEGER
b imp sh = non-float =
INTEGER

relational ops (b, sh):

b = sh = integer =
INTEGER
b > sh = integer =
INTEGER
b < sh = integer =
INTEGER
b <> sh = integer =
INTEGER
b <= sh = integer =
INTEGER
b >= sh = integer =
INTEGER
b andalso sh = integer =
INTEGER
b orelse sh = integer =
INTEGER

math ops (ub, sh):

ub + sh = max =
INTEGER
ub - sh = max =
INTEGER
ub * sh = max =
INTEGER
ub / sh = float =
DOUBLE
ub ^ sh = float =
DOUBLE
ub \ sh = non-float =
INTEGER
ub mod sh = non-float =
INTEGER

bitops (ub, sh):

ub shl sh = non-float =
INTEGER
ub shr sh = non-float =
INTEGER
ub and sh = non-float =
INTEGER
ub or sh = non-float =
INTEGER
ub xor sh = non-float =
INTEGER
ub eqv sh = non-float =
INTEGER
ub imp sh = non-float =
INTEGER

relational ops (ub, sh):

ub = sh = integer =
INTEGER
ub > sh = integer =
INTEGER
ub < sh = integer =
INTEGER
ub <> sh = integer =
INTEGER
ub <= sh = integer =
INTEGER
ub >= sh = integer =
INTEGER
ub andalso sh = integer =
INTEGER
ub orelse sh = integer =
INTEGER

math ops (sh, sh):

sh + sh = max =
INTEGER
sh - sh = max =
INTEGER
sh * sh = max =
INTEGER
sh / sh = float =
DOUBLE
sh ^ sh = float =
DOUBLE
sh \ sh = non-float =
INTEGER
sh mod sh = non-float =
INTEGER

bitops (sh, sh):

sh shl sh = non-float =
INTEGER
sh shr sh = non-float =
INTEGER
sh and sh = non-float =
INTEGER
sh or sh = non-float =
INTEGER
sh xor sh = non-float =
INTEGER
sh eqv sh = non-float =
INTEGER
sh imp sh = non-float =
INTEGER

relational ops (sh, sh):

sh = sh = integer =
INTEGER
sh > sh = integer =
INTEGER
sh < sh = integer =
INTEGER
sh <> sh = integer =
INTEGER
sh <= sh = integer =
INTEGER
sh >= sh = integer =
INTEGER
sh andalso sh = integer =
INTEGER
sh orelse sh = integer =
INTEGER

math ops (ush, sh):

ush + sh = max =
INTEGER
ush - sh = max =
INTEGER
ush * sh = max =
INTEGER
ush / sh = float =
DOUBLE
ush ^ sh = float =
DOUBLE
ush \ sh = non-float =
INTEGER
ush mod sh = non-float =
INTEGER

bitops (ush, sh):

ush shl sh = non-float =
INTEGER
ush shr sh = non-float =
INTEGER
ush and sh = non-float =
INTEGER
ush or sh = non-float =
INTEGER
ush xor sh = non-float =
INTEGER
ush eqv sh = non-float =
INTEGER
ush imp sh = non-float =
INTEGER

relational ops (ush, sh):

ush = sh = integer =
INTEGER
ush > sh = integer =
INTEGER
ush < sh = integer =
INTEGER
ush <> sh = integer =
INTEGER
ush <= sh = integer =
INTEGER
ush >= sh = integer =
INTEGER
ush andalso sh = integer =
INTEGER
ush orelse sh = integer =
INTEGER

math ops (i, sh):

i + sh = max =
INTEGER
i - sh = max =
INTEGER
i * sh = max =
INTEGER
i / sh = float =
DOUBLE
i ^ sh = float =
DOUBLE
i \ sh = non-float =
INTEGER
i mod sh = non-float =
INTEGER

bitops (i, sh):

i shl sh = non-float =
INTEGER
i shr sh = non-float =
INTEGER
i and sh = non-float =
INTEGER
i or sh = non-float =
INTEGER
i xor sh = non-float =
INTEGER
i eqv sh = non-float =
INTEGER
i imp sh = non-float =
INTEGER

relational ops (i, sh):

i = sh = integer =
INTEGER
i > sh = integer =
INTEGER
i < sh = integer =
INTEGER
i <> sh = integer =
INTEGER
i <= sh = integer =
INTEGER
i >= sh = integer =
INTEGER
i andalso sh = integer =
INTEGER
i orelse sh = integer =
INTEGER

math ops (ui, sh):

ui + sh = max =
UINTEGER
ui - sh = max =
UINTEGER
ui * sh = max =
UINTEGER
ui / sh = float =
DOUBLE
ui ^ sh = float =
DOUBLE
ui \ sh = non-float =
UINTEGER
ui mod sh = non-float =
UINTEGER

bitops (ui, sh):

ui shl sh = non-float =
UINTEGER
ui shr sh = non-float =
UINTEGER
ui and sh = non-float =
UINTEGER
ui or sh = non-float =
UINTEGER
ui xor sh = non-float =
UINTEGER
ui eqv sh = non-float =
UINTEGER
ui imp sh = non-float =
UINTEGER

relational ops (ui, sh):

ui = sh = integer =
INTEGER
ui > sh = integer =
INTEGER
ui < sh = integer =
INTEGER
ui <> sh = integer =
INTEGER
ui <= sh = integer =
INTEGER
ui >= sh = integer =
INTEGER
ui andalso sh = integer =
INTEGER
ui orelse sh = integer =
INTEGER

math ops (l, sh):

l + sh = max =
INTEGER
l - sh = max =
INTEGER
l * sh = max =
INTEGER
l / sh = float =
DOUBLE
l ^ sh = float =
DOUBLE
l \ sh = non-float =
INTEGER
l mod sh = non-float =
INTEGER

bitops (l, sh):

l shl sh = non-float =
INTEGER
l shr sh = non-float =
INTEGER
l and sh = non-float =
INTEGER
l or sh = non-float =
INTEGER
l xor sh = non-float =
INTEGER
l eqv sh = non-float =
INTEGER
l imp sh = non-float =
INTEGER

relational ops (l, sh):

l = sh = integer =
INTEGER
l > sh = integer =
INTEGER
l < sh = integer =
INTEGER
l <> sh = integer =
INTEGER
l <= sh = integer =
INTEGER
l >= sh = integer =
INTEGER
l andalso sh = integer =
INTEGER
l orelse sh = integer =
INTEGER

math ops (ul, sh):

ul + sh = max =
INTEGER
ul - sh = max =
INTEGER
ul * sh = max =
INTEGER
ul / sh = float =
DOUBLE
ul ^ sh = float =
DOUBLE
ul \ sh = non-float =
INTEGER
ul mod sh = non-float =
INTEGER

bitops (ul, sh):

ul shl sh = non-float =
INTEGER
ul shr sh = non-float =
INTEGER
ul and sh = non-float =
INTEGER
ul or sh = non-float =
INTEGER
ul xor sh = non-float =
INTEGER
ul eqv sh = non-float =
INTEGER
ul imp sh = non-float =
INTEGER

relational ops (ul, sh):

ul = sh = integer =
INTEGER
ul > sh = integer =
INTEGER
ul < sh = integer =
INTEGER
ul <> sh = integer =
INTEGER
ul <= sh = integer =
INTEGER
ul >= sh = integer =
INTEGER
ul andalso sh = integer =
INTEGER
ul orelse sh = integer =
INTEGER

math ops (ll, sh):

ll + sh = max =
INTEGER
ll - sh = max =
INTEGER
ll * sh = max =
INTEGER
ll / sh = float =
DOUBLE
ll ^ sh = float =
DOUBLE
ll \ sh = non-float =
INTEGER
ll mod sh = non-float =
INTEGER

bitops (ll, sh):

ll shl sh = non-float =
INTEGER
ll shr sh = non-float =
INTEGER
ll and sh = non-float =
INTEGER
ll or sh = non-float =
INTEGER
ll xor sh = non-float =
INTEGER
ll eqv sh = non-float =
INTEGER
ll imp sh = non-float =
INTEGER

relational ops (ll, sh):

ll = sh = integer =
INTEGER
ll > sh = integer =
INTEGER
ll < sh = integer =
INTEGER
ll <> sh = integer =
INTEGER
ll <= sh = integer =
INTEGER
ll >= sh = integer =
INTEGER
ll andalso sh = integer =
INTEGER
ll orelse sh = integer =
INTEGER

math ops (ull, sh):

ull + sh = max =
UINTEGER
ull - sh = max =
UINTEGER
ull * sh = max =
UINTEGER
ull / sh = float =
DOUBLE
ull ^ sh = float =
DOUBLE
ull \ sh = non-float =
UINTEGER
ull mod sh = non-float =
UINTEGER

bitops (ull, sh):

ull shl sh = non-float =
UINTEGER
ull shr sh = non-float =
UINTEGER
ull and sh = non-float =
UINTEGER
ull or sh = non-float =
UINTEGER
ull xor sh = non-float =
UINTEGER
ull eqv sh = non-float =
UINTEGER
ull imp sh = non-float =
UINTEGER

relational ops (ull, sh):

ull = sh = integer =
INTEGER
ull > sh = integer =
INTEGER
ull < sh = integer =
INTEGER
ull <> sh = integer =
INTEGER
ull <= sh = integer =
INTEGER
ull >= sh = integer =
INTEGER
ull andalso sh = integer =
INTEGER
ull orelse sh = integer =
INTEGER

math ops (enum1a, sh):

enum1a + sh = max =
INTEGER
enum1a - sh = max =
INTEGER
enum1a * sh = max =
INTEGER
enum1a / sh = float =
DOUBLE
enum1a ^ sh = float =
DOUBLE
enum1a \ sh = non-float =
INTEGER
enum1a mod sh = non-float =
INTEGER

bitops (enum1a, sh):

enum1a shl sh = non-float =
INTEGER
enum1a shr sh = non-float =
INTEGER
enum1a and sh = non-float =
INTEGER
enum1a or sh = non-float =
INTEGER
enum1a xor sh = non-float =
INTEGER
enum1a eqv sh = non-float =
INTEGER
enum1a imp sh = non-float =
INTEGER

relational ops (enum1a, sh):

enum1a = sh = integer =
INTEGER
enum1a > sh = integer =
INTEGER
enum1a < sh = integer =
INTEGER
enum1a <> sh = integer =
INTEGER
enum1a <= sh = integer =
INTEGER
enum1a >= sh = integer =
INTEGER
enum1a andalso sh = integer =
INTEGER
enum1a orelse sh = integer =
INTEGER

math ops (sh, f):

sh + f = max =
SINGLE
sh - f = max =
SINGLE
sh * f = max =
SINGLE
sh / f = float =
DOUBLE
sh ^ f = float =
DOUBLE
sh \ f = non-float =
INTEGER
sh mod f = non-float =
INTEGER

bitops (sh, f):

sh shl f = non-float =
INTEGER
sh shr f = non-float =
INTEGER
sh and f = non-float =
INTEGER
sh or f = non-float =
INTEGER
sh xor f = non-float =
INTEGER
sh eqv f = non-float =
INTEGER
sh imp f = non-float =
INTEGER

relational ops (sh, f):

sh = f = integer =
INTEGER
sh > f = integer =
INTEGER
sh < f = integer =
INTEGER
sh <> f = integer =
INTEGER
sh <= f = integer =
INTEGER
sh >= f = integer =
INTEGER
sh andalso f = integer =
INTEGER
sh orelse f = integer =
INTEGER

math ops (sh, d):

sh + d = max =
DOUBLE
sh - d = max =
DOUBLE
sh * d = max =
DOUBLE
sh / d = float =
DOUBLE
sh ^ d = float =
DOUBLE
sh \ d = non-float =
INTEGER
sh mod d = non-float =
INTEGER

bitops (sh, d):

sh shl d = non-float =
INTEGER
sh shr d = non-float =
INTEGER
sh and d = non-float =
INTEGER
sh or d = non-float =
INTEGER
sh xor d = non-float =
INTEGER
sh eqv d = non-float =
INTEGER
sh imp d = non-float =
INTEGER

relational ops (sh, d):

sh = d = integer =
INTEGER
sh > d = integer =
INTEGER
sh < d = integer =
INTEGER
sh <> d = integer =
INTEGER
sh <= d = integer =
INTEGER
sh >= d = integer =
INTEGER
sh andalso d = integer =
INTEGER
sh orelse d = integer =
INTEGER

math ops (f, sh):

f + sh = max =
SINGLE
f - sh = max =
SINGLE
f * sh = max =
SINGLE
f / sh = float =
DOUBLE
f ^ sh = float =
DOUBLE
f \ sh = non-float =
INTEGER
f mod sh = non-float =
INTEGER

bitops (f, sh):

f shl sh = non-float =
INTEGER
f shr sh = non-float =
INTEGER
f and sh = non-float =
INTEGER
f or sh = non-float =
INTEGER
f xor sh = non-float =
INTEGER
f eqv sh = non-float =
INTEGER
f imp sh = non-float =
INTEGER

relational ops (f, sh):

f = sh = integer =
INTEGER
f > sh = integer =
INTEGER
f < sh = integer =
INTEGER
f <> sh = integer =
INTEGER
f <= sh = integer =
INTEGER
f >= sh = integer =
INTEGER
f andalso sh = integer =
INTEGER
f orelse sh = integer =
INTEGER

math ops (d, sh):

d + sh = max =
DOUBLE
d - sh = max =
DOUBLE
d * sh = max =
DOUBLE
d / sh = float =
DOUBLE
d ^ sh = float =
DOUBLE
d \ sh = non-float =
INTEGER
d mod sh = non-float =
INTEGER

bitops (d, sh):

d shl sh = non-float =
INTEGER
d shr sh = non-float =
INTEGER
d and sh = non-float =
INTEGER
d or sh = non-float =
INTEGER
d xor sh = non-float =
INTEGER
d eqv sh = non-float =
INTEGER
d imp sh = non-float =
INTEGER

relational ops (d, sh):

d = sh = integer =
INTEGER
d > sh = integer =
INTEGER
d < sh = integer =
INTEGER
d <> sh = integer =
INTEGER
d <= sh = integer =
INTEGER
d >= sh = integer =
INTEGER
d andalso sh = integer =
INTEGER
d orelse sh = integer =
INTEGER

----- ush -----------------------------------------------------


math ops (ush, b):

ush + b = max =
INTEGER
ush - b = max =
INTEGER
ush * b = max =
INTEGER
ush / b = float =
DOUBLE
ush ^ b = float =
DOUBLE
ush \ b = non-float =
INTEGER
ush mod b = non-float =
INTEGER

bitops (ush, b):

ush shl b = non-float =
INTEGER
ush shr b = non-float =
INTEGER
ush and b = non-float =
INTEGER
ush or b = non-float =
INTEGER
ush xor b = non-float =
INTEGER
ush eqv b = non-float =
INTEGER
ush imp b = non-float =
INTEGER

relational ops (ush, b):

ush = b = integer =
INTEGER
ush > b = integer =
INTEGER
ush < b = integer =
INTEGER
ush <> b = integer =
INTEGER
ush <= b = integer =
INTEGER
ush >= b = integer =
INTEGER
ush andalso b = integer =
INTEGER
ush orelse b = integer =
INTEGER

math ops (ush, ub):

ush + ub = max =
INTEGER
ush - ub = max =
INTEGER
ush * ub = max =
INTEGER
ush / ub = float =
DOUBLE
ush ^ ub = float =
DOUBLE
ush \ ub = non-float =
INTEGER
ush mod ub = non-float =
INTEGER

bitops (ush, ub):

ush shl ub = non-float =
INTEGER
ush shr ub = non-float =
INTEGER
ush and ub = non-float =
INTEGER
ush or ub = non-float =
INTEGER
ush xor ub = non-float =
INTEGER
ush eqv ub = non-float =
INTEGER
ush imp ub = non-float =
INTEGER

relational ops (ush, ub):

ush = ub = integer =
INTEGER
ush > ub = integer =
INTEGER
ush < ub = integer =
INTEGER
ush <> ub = integer =
INTEGER
ush <= ub = integer =
INTEGER
ush >= ub = integer =
INTEGER
ush andalso ub = integer =
INTEGER
ush orelse ub = integer =
INTEGER

math ops (ush, sh):

ush + sh = max =
INTEGER
ush - sh = max =
INTEGER
ush * sh = max =
INTEGER
ush / sh = float =
DOUBLE
ush ^ sh = float =
DOUBLE
ush \ sh = non-float =
INTEGER
ush mod sh = non-float =
INTEGER

bitops (ush, sh):

ush shl sh = non-float =
INTEGER
ush shr sh = non-float =
INTEGER
ush and sh = non-float =
INTEGER
ush or sh = non-float =
INTEGER
ush xor sh = non-float =
INTEGER
ush eqv sh = non-float =
INTEGER
ush imp sh = non-float =
INTEGER

relational ops (ush, sh):

ush = sh = integer =
INTEGER
ush > sh = integer =
INTEGER
ush < sh = integer =
INTEGER
ush <> sh = integer =
INTEGER
ush <= sh = integer =
INTEGER
ush >= sh = integer =
INTEGER
ush andalso sh = integer =
INTEGER
ush orelse sh = integer =
INTEGER

math ops (ush, ush):

ush + ush = max =
INTEGER
ush - ush = max =
INTEGER
ush * ush = max =
INTEGER
ush / ush = float =
DOUBLE
ush ^ ush = float =
DOUBLE
ush \ ush = non-float =
INTEGER
ush mod ush = non-float =
INTEGER

bitops (ush, ush):

ush shl ush = non-float =
INTEGER
ush shr ush = non-float =
INTEGER
ush and ush = non-float =
INTEGER
ush or ush = non-float =
INTEGER
ush xor ush = non-float =
INTEGER
ush eqv ush = non-float =
INTEGER
ush imp ush = non-float =
INTEGER

relational ops (ush, ush):

ush = ush = integer =
INTEGER
ush > ush = integer =
INTEGER
ush < ush = integer =
INTEGER
ush <> ush = integer =
INTEGER
ush <= ush = integer =
INTEGER
ush >= ush = integer =
INTEGER
ush andalso ush = integer =
INTEGER
ush orelse ush = integer =
INTEGER

math ops (ush, i):

ush + i = max =
INTEGER
ush - i = max =
INTEGER
ush * i = max =
INTEGER
ush / i = float =
DOUBLE
ush ^ i = float =
DOUBLE
ush \ i = non-float =
INTEGER
ush mod i = non-float =
INTEGER

bitops (ush, i):

ush shl i = non-float =
INTEGER
ush shr i = non-float =
INTEGER
ush and i = non-float =
INTEGER
ush or i = non-float =
INTEGER
ush xor i = non-float =
INTEGER
ush eqv i = non-float =
INTEGER
ush imp i = non-float =
INTEGER

relational ops (ush, i):

ush = i = integer =
INTEGER
ush > i = integer =
INTEGER
ush < i = integer =
INTEGER
ush <> i = integer =
INTEGER
ush <= i = integer =
INTEGER
ush >= i = integer =
INTEGER
ush andalso i = integer =
INTEGER
ush orelse i = integer =
INTEGER

math ops (ush, ui):

ush + ui = max =
UINTEGER
ush - ui = max =
UINTEGER
ush * ui = max =
UINTEGER
ush / ui = float =
DOUBLE
ush ^ ui = float =
DOUBLE
ush \ ui = non-float =
UINTEGER
ush mod ui = non-float =
UINTEGER

bitops (ush, ui):

ush shl ui = non-float =
UINTEGER
ush shr ui = non-float =
UINTEGER
ush and ui = non-float =
UINTEGER
ush or ui = non-float =
UINTEGER
ush xor ui = non-float =
UINTEGER
ush eqv ui = non-float =
UINTEGER
ush imp ui = non-float =
UINTEGER

relational ops (ush, ui):

ush = ui = integer =
INTEGER
ush > ui = integer =
INTEGER
ush < ui = integer =
INTEGER
ush <> ui = integer =
INTEGER
ush <= ui = integer =
INTEGER
ush >= ui = integer =
INTEGER
ush andalso ui = integer =
INTEGER
ush orelse ui = integer =
INTEGER

math ops (ush, l):

ush + l = max =
INTEGER
ush - l = max =
INTEGER
ush * l = max =
INTEGER
ush / l = float =
DOUBLE
ush ^ l = float =
DOUBLE
ush \ l = non-float =
INTEGER
ush mod l = non-float =
INTEGER

bitops (ush, l):

ush shl l = non-float =
INTEGER
ush shr l = non-float =
INTEGER
ush and l = non-float =
INTEGER
ush or l = non-float =
INTEGER
ush xor l = non-float =
INTEGER
ush eqv l = non-float =
INTEGER
ush imp l = non-float =
INTEGER

relational ops (ush, l):

ush = l = integer =
INTEGER
ush > l = integer =
INTEGER
ush < l = integer =
INTEGER
ush <> l = integer =
INTEGER
ush <= l = integer =
INTEGER
ush >= l = integer =
INTEGER
ush andalso l = integer =
INTEGER
ush orelse l = integer =
INTEGER

math ops (ush, ul):

ush + ul = max =
INTEGER
ush - ul = max =
INTEGER
ush * ul = max =
INTEGER
ush / ul = float =
DOUBLE
ush ^ ul = float =
DOUBLE
ush \ ul = non-float =
INTEGER
ush mod ul = non-float =
INTEGER

bitops (ush, ul):

ush shl ul = non-float =
INTEGER
ush shr ul = non-float =
INTEGER
ush and ul = non-float =
INTEGER
ush or ul = non-float =
INTEGER
ush xor ul = non-float =
INTEGER
ush eqv ul = non-float =
INTEGER
ush imp ul = non-float =
INTEGER

relational ops (ush, ul):

ush = ul = integer =
INTEGER
ush > ul = integer =
INTEGER
ush < ul = integer =
INTEGER
ush <> ul = integer =
INTEGER
ush <= ul = integer =
INTEGER
ush >= ul = integer =
INTEGER
ush andalso ul = integer =
INTEGER
ush orelse ul = integer =
INTEGER

math ops (ush, ll):

ush + ll = max =
INTEGER
ush - ll = max =
INTEGER
ush * ll = max =
INTEGER
ush / ll = float =
DOUBLE
ush ^ ll = float =
DOUBLE
ush \ ll = non-float =
INTEGER
ush mod ll = non-float =
INTEGER

bitops (ush, ll):

ush shl ll = non-float =
INTEGER
ush shr ll = non-float =
INTEGER
ush and ll = non-float =
INTEGER
ush or ll = non-float =
INTEGER
ush xor ll = non-float =
INTEGER
ush eqv ll = non-float =
INTEGER
ush imp ll = non-float =
INTEGER

relational ops (ush, ll):

ush = ll = integer =
INTEGER
ush > ll = integer =
INTEGER
ush < ll = integer =
INTEGER
ush <> ll = integer =
INTEGER
ush <= ll = integer =
INTEGER
ush >= ll = integer =
INTEGER
ush andalso ll = integer =
INTEGER
ush orelse ll = integer =
INTEGER

math ops (ush, ull):

ush + ull = max =
UINTEGER
ush - ull = max =
UINTEGER
ush * ull = max =
UINTEGER
ush / ull = float =
DOUBLE
ush ^ ull = float =
DOUBLE
ush \ ull = non-float =
UINTEGER
ush mod ull = non-float =
UINTEGER

bitops (ush, ull):

ush shl ull = non-float =
UINTEGER
ush shr ull = non-float =
UINTEGER
ush and ull = non-float =
UINTEGER
ush or ull = non-float =
UINTEGER
ush xor ull = non-float =
UINTEGER
ush eqv ull = non-float =
UINTEGER
ush imp ull = non-float =
UINTEGER

relational ops (ush, ull):

ush = ull = integer =
INTEGER
ush > ull = integer =
INTEGER
ush < ull = integer =
INTEGER
ush <> ull = integer =
INTEGER
ush <= ull = integer =
INTEGER
ush >= ull = integer =
INTEGER
ush andalso ull = integer =
INTEGER
ush orelse ull = integer =
INTEGER

math ops (ush, enum1a):

ush + enum1a = max =
INTEGER
ush - enum1a = max =
INTEGER
ush * enum1a = max =
INTEGER
ush / enum1a = float =
DOUBLE
ush ^ enum1a = float =
DOUBLE
ush \ enum1a = non-float =
INTEGER
ush mod enum1a = non-float =
INTEGER

bitops (ush, enum1a):

ush shl enum1a = non-float =
INTEGER
ush shr enum1a = non-float =
INTEGER
ush and enum1a = non-float =
INTEGER
ush or enum1a = non-float =
INTEGER
ush xor enum1a = non-float =
INTEGER
ush eqv enum1a = non-float =
INTEGER
ush imp enum1a = non-float =
INTEGER

relational ops (ush, enum1a):

ush = enum1a = integer =
INTEGER
ush > enum1a = integer =
INTEGER
ush < enum1a = integer =
INTEGER
ush <> enum1a = integer =
INTEGER
ush <= enum1a = integer =
INTEGER
ush >= enum1a = integer =
INTEGER
ush andalso enum1a = integer =
INTEGER
ush orelse enum1a = integer =
INTEGER

math ops (b, ush):

b + ush = max =
INTEGER
b - ush = max =
INTEGER
b * ush = max =
INTEGER
b / ush = float =
DOUBLE
b ^ ush = float =
DOUBLE
b \ ush = non-float =
INTEGER
b mod ush = non-float =
INTEGER

bitops (b, ush):

b shl ush = non-float =
INTEGER
b shr ush = non-float =
INTEGER
b and ush = non-float =
INTEGER
b or ush = non-float =
INTEGER
b xor ush = non-float =
INTEGER
b eqv ush = non-float =
INTEGER
b imp ush = non-float =
INTEGER

relational ops (b, ush):

b = ush = integer =
INTEGER
b > ush = integer =
INTEGER
b < ush = integer =
INTEGER
b <> ush = integer =
INTEGER
b <= ush = integer =
INTEGER
b >= ush = integer =
INTEGER
b andalso ush = integer =
INTEGER
b orelse ush = integer =
INTEGER

math ops (ub, ush):

ub + ush = max =
INTEGER
ub - ush = max =
INTEGER
ub * ush = max =
INTEGER
ub / ush = float =
DOUBLE
ub ^ ush = float =
DOUBLE
ub \ ush = non-float =
INTEGER
ub mod ush = non-float =
INTEGER

bitops (ub, ush):

ub shl ush = non-float =
INTEGER
ub shr ush = non-float =
INTEGER
ub and ush = non-float =
INTEGER
ub or ush = non-float =
INTEGER
ub xor ush = non-float =
INTEGER
ub eqv ush = non-float =
INTEGER
ub imp ush = non-float =
INTEGER

relational ops (ub, ush):

ub = ush = integer =
INTEGER
ub > ush = integer =
INTEGER
ub < ush = integer =
INTEGER
ub <> ush = integer =
INTEGER
ub <= ush = integer =
INTEGER
ub >= ush = integer =
INTEGER
ub andalso ush = integer =
INTEGER
ub orelse ush = integer =
INTEGER

math ops (sh, ush):

sh + ush = max =
INTEGER
sh - ush = max =
INTEGER
sh * ush = max =
INTEGER
sh / ush = float =
DOUBLE
sh ^ ush = float =
DOUBLE
sh \ ush = non-float =
INTEGER
sh mod ush = non-float =
INTEGER

bitops (sh, ush):

sh shl ush = non-float =
INTEGER
sh shr ush = non-float =
INTEGER
sh and ush = non-float =
INTEGER
sh or ush = non-float =
INTEGER
sh xor ush = non-float =
INTEGER
sh eqv ush = non-float =
INTEGER
sh imp ush = non-float =
INTEGER

relational ops (sh, ush):

sh = ush = integer =
INTEGER
sh > ush = integer =
INTEGER
sh < ush = integer =
INTEGER
sh <> ush = integer =
INTEGER
sh <= ush = integer =
INTEGER
sh >= ush = integer =
INTEGER
sh andalso ush = integer =
INTEGER
sh orelse ush = integer =
INTEGER

math ops (ush, ush):

ush + ush = max =
INTEGER
ush - ush = max =
INTEGER
ush * ush = max =
INTEGER
ush / ush = float =
DOUBLE
ush ^ ush = float =
DOUBLE
ush \ ush = non-float =
INTEGER
ush mod ush = non-float =
INTEGER

bitops (ush, ush):

ush shl ush = non-float =
INTEGER
ush shr ush = non-float =
INTEGER
ush and ush = non-float =
INTEGER
ush or ush = non-float =
INTEGER
ush xor ush = non-float =
INTEGER
ush eqv ush = non-float =
INTEGER
ush imp ush = non-float =
INTEGER

relational ops (ush, ush):

ush = ush = integer =
INTEGER
ush > ush = integer =
INTEGER
ush < ush = integer =
INTEGER
ush <> ush = integer =
INTEGER
ush <= ush = integer =
INTEGER
ush >= ush = integer =
INTEGER
ush andalso ush = integer =
INTEGER
ush orelse ush = integer =
INTEGER

math ops (i, ush):

i + ush = max =
INTEGER
i - ush = max =
INTEGER
i * ush = max =
INTEGER
i / ush = float =
DOUBLE
i ^ ush = float =
DOUBLE
i \ ush = non-float =
INTEGER
i mod ush = non-float =
INTEGER

bitops (i, ush):

i shl ush = non-float =
INTEGER
i shr ush = non-float =
INTEGER
i and ush = non-float =
INTEGER
i or ush = non-float =
INTEGER
i xor ush = non-float =
INTEGER
i eqv ush = non-float =
INTEGER
i imp ush = non-float =
INTEGER

relational ops (i, ush):

i = ush = integer =
INTEGER
i > ush = integer =
INTEGER
i < ush = integer =
INTEGER
i <> ush = integer =
INTEGER
i <= ush = integer =
INTEGER
i >= ush = integer =
INTEGER
i andalso ush = integer =
INTEGER
i orelse ush = integer =
INTEGER

math ops (ui, ush):

ui + ush = max =
UINTEGER
ui - ush = max =
UINTEGER
ui * ush = max =
UINTEGER
ui / ush = float =
DOUBLE
ui ^ ush = float =
DOUBLE
ui \ ush = non-float =
UINTEGER
ui mod ush = non-float =
UINTEGER

bitops (ui, ush):

ui shl ush = non-float =
UINTEGER
ui shr ush = non-float =
UINTEGER
ui and ush = non-float =
UINTEGER
ui or ush = non-float =
UINTEGER
ui xor ush = non-float =
UINTEGER
ui eqv ush = non-float =
UINTEGER
ui imp ush = non-float =
UINTEGER

relational ops (ui, ush):

ui = ush = integer =
INTEGER
ui > ush = integer =
INTEGER
ui < ush = integer =
INTEGER
ui <> ush = integer =
INTEGER
ui <= ush = integer =
INTEGER
ui >= ush = integer =
INTEGER
ui andalso ush = integer =
INTEGER
ui orelse ush = integer =
INTEGER

math ops (l, ush):

l + ush = max =
INTEGER
l - ush = max =
INTEGER
l * ush = max =
INTEGER
l / ush = float =
DOUBLE
l ^ ush = float =
DOUBLE
l \ ush = non-float =
INTEGER
l mod ush = non-float =
INTEGER

bitops (l, ush):

l shl ush = non-float =
INTEGER
l shr ush = non-float =
INTEGER
l and ush = non-float =
INTEGER
l or ush = non-float =
INTEGER
l xor ush = non-float =
INTEGER
l eqv ush = non-float =
INTEGER
l imp ush = non-float =
INTEGER

relational ops (l, ush):

l = ush = integer =
INTEGER
l > ush = integer =
INTEGER
l < ush = integer =
INTEGER
l <> ush = integer =
INTEGER
l <= ush = integer =
INTEGER
l >= ush = integer =
INTEGER
l andalso ush = integer =
INTEGER
l orelse ush = integer =
INTEGER

math ops (ul, ush):

ul + ush = max =
INTEGER
ul - ush = max =
INTEGER
ul * ush = max =
INTEGER
ul / ush = float =
DOUBLE
ul ^ ush = float =
DOUBLE
ul \ ush = non-float =
INTEGER
ul mod ush = non-float =
INTEGER

bitops (ul, ush):

ul shl ush = non-float =
INTEGER
ul shr ush = non-float =
INTEGER
ul and ush = non-float =
INTEGER
ul or ush = non-float =
INTEGER
ul xor ush = non-float =
INTEGER
ul eqv ush = non-float =
INTEGER
ul imp ush = non-float =
INTEGER

relational ops (ul, ush):

ul = ush = integer =
INTEGER
ul > ush = integer =
INTEGER
ul < ush = integer =
INTEGER
ul <> ush = integer =
INTEGER
ul <= ush = integer =
INTEGER
ul >= ush = integer =
INTEGER
ul andalso ush = integer =
INTEGER
ul orelse ush = integer =
INTEGER

math ops (ll, ush):

ll + ush = max =
INTEGER
ll - ush = max =
INTEGER
ll * ush = max =
INTEGER
ll / ush = float =
DOUBLE
ll ^ ush = float =
DOUBLE
ll \ ush = non-float =
INTEGER
ll mod ush = non-float =
INTEGER

bitops (ll, ush):

ll shl ush = non-float =
INTEGER
ll shr ush = non-float =
INTEGER
ll and ush = non-float =
INTEGER
ll or ush = non-float =
INTEGER
ll xor ush = non-float =
INTEGER
ll eqv ush = non-float =
INTEGER
ll imp ush = non-float =
INTEGER

relational ops (ll, ush):

ll = ush = integer =
INTEGER
ll > ush = integer =
INTEGER
ll < ush = integer =
INTEGER
ll <> ush = integer =
INTEGER
ll <= ush = integer =
INTEGER
ll >= ush = integer =
INTEGER
ll andalso ush = integer =
INTEGER
ll orelse ush = integer =
INTEGER

math ops (ull, ush):

ull + ush = max =
UINTEGER
ull - ush = max =
UINTEGER
ull * ush = max =
UINTEGER
ull / ush = float =
DOUBLE
ull ^ ush = float =
DOUBLE
ull \ ush = non-float =
UINTEGER
ull mod ush = non-float =
UINTEGER

bitops (ull, ush):

ull shl ush = non-float =
UINTEGER
ull shr ush = non-float =
UINTEGER
ull and ush = non-float =
UINTEGER
ull or ush = non-float =
UINTEGER
ull xor ush = non-float =
UINTEGER
ull eqv ush = non-float =
UINTEGER
ull imp ush = non-float =
UINTEGER

relational ops (ull, ush):

ull = ush = integer =
INTEGER
ull > ush = integer =
INTEGER
ull < ush = integer =
INTEGER
ull <> ush = integer =
INTEGER
ull <= ush = integer =
INTEGER
ull >= ush = integer =
INTEGER
ull andalso ush = integer =
INTEGER
ull orelse ush = integer =
INTEGER

math ops (enum1a, ush):

enum1a + ush = max =
INTEGER
enum1a - ush = max =
INTEGER
enum1a * ush = max =
INTEGER
enum1a / ush = float =
DOUBLE
enum1a ^ ush = float =
DOUBLE
enum1a \ ush = non-float =
INTEGER
enum1a mod ush = non-float =
INTEGER

bitops (enum1a, ush):

enum1a shl ush = non-float =
INTEGER
enum1a shr ush = non-float =
INTEGER
enum1a and ush = non-float =
INTEGER
enum1a or ush = non-float =
INTEGER
enum1a xor ush = non-float =
INTEGER
enum1a eqv ush = non-float =
INTEGER
enum1a imp ush = non-float =
INTEGER

relational ops (enum1a, ush):

enum1a = ush = integer =
INTEGER
enum1a > ush = integer =
INTEGER
enum1a < ush = integer =
INTEGER
enum1a <> ush = integer =
INTEGER
enum1a <= ush = integer =
INTEGER
enum1a >= ush = integer =
INTEGER
enum1a andalso ush = integer =
INTEGER
enum1a orelse ush = integer =
INTEGER

math ops (ush, f):

ush + f = max =
SINGLE
ush - f = max =
SINGLE
ush * f = max =
SINGLE
ush / f = float =
DOUBLE
ush ^ f = float =
DOUBLE
ush \ f = non-float =
INTEGER
ush mod f = non-float =
INTEGER

bitops (ush, f):

ush shl f = non-float =
INTEGER
ush shr f = non-float =
INTEGER
ush and f = non-float =
INTEGER
ush or f = non-float =
INTEGER
ush xor f = non-float =
INTEGER
ush eqv f = non-float =
INTEGER
ush imp f = non-float =
INTEGER

relational ops (ush, f):

ush = f = integer =
INTEGER
ush > f = integer =
INTEGER
ush < f = integer =
INTEGER
ush <> f = integer =
INTEGER
ush <= f = integer =
INTEGER
ush >= f = integer =
INTEGER
ush andalso f = integer =
INTEGER
ush orelse f = integer =
INTEGER

math ops (ush, d):

ush + d = max =
DOUBLE
ush - d = max =
DOUBLE
ush * d = max =
DOUBLE
ush / d = float =
DOUBLE
ush ^ d = float =
DOUBLE
ush \ d = non-float =
INTEGER
ush mod d = non-float =
INTEGER

bitops (ush, d):

ush shl d = non-float =
INTEGER
ush shr d = non-float =
INTEGER
ush and d = non-float =
INTEGER
ush or d = non-float =
INTEGER
ush xor d = non-float =
INTEGER
ush eqv d = non-float =
INTEGER
ush imp d = non-float =
INTEGER

relational ops (ush, d):

ush = d = integer =
INTEGER
ush > d = integer =
INTEGER
ush < d = integer =
INTEGER
ush <> d = integer =
INTEGER
ush <= d = integer =
INTEGER
ush >= d = integer =
INTEGER
ush andalso d = integer =
INTEGER
ush orelse d = integer =
INTEGER

math ops (f, ush):

f + ush = max =
SINGLE
f - ush = max =
SINGLE
f * ush = max =
SINGLE
f / ush = float =
DOUBLE
f ^ ush = float =
DOUBLE
f \ ush = non-float =
INTEGER
f mod ush = non-float =
INTEGER

bitops (f, ush):

f shl ush = non-float =
INTEGER
f shr ush = non-float =
INTEGER
f and ush = non-float =
INTEGER
f or ush = non-float =
INTEGER
f xor ush = non-float =
INTEGER
f eqv ush = non-float =
INTEGER
f imp ush = non-float =
INTEGER

relational ops (f, ush):

f = ush = integer =
INTEGER
f > ush = integer =
INTEGER
f < ush = integer =
INTEGER
f <> ush = integer =
INTEGER
f <= ush = integer =
INTEGER
f >= ush = integer =
INTEGER
f andalso ush = integer =
INTEGER
f orelse ush = integer =
INTEGER

math ops (d, ush):

d + ush = max =
DOUBLE
d - ush = max =
DOUBLE
d * ush = max =
DOUBLE
d / ush = float =
DOUBLE
d ^ ush = float =
DOUBLE
d \ ush = non-float =
INTEGER
d mod ush = non-float =
INTEGER

bitops (d, ush):

d shl ush = non-float =
INTEGER
d shr ush = non-float =
INTEGER
d and ush = non-float =
INTEGER
d or ush = non-float =
INTEGER
d xor ush = non-float =
INTEGER
d eqv ush = non-float =
INTEGER
d imp ush = non-float =
INTEGER

relational ops (d, ush):

d = ush = integer =
INTEGER
d > ush = integer =
INTEGER
d < ush = integer =
INTEGER
d <> ush = integer =
INTEGER
d <= ush = integer =
INTEGER
d >= ush = integer =
INTEGER
d andalso ush = integer =
INTEGER
d orelse ush = integer =
INTEGER

----- i -----------------------------------------------------


math ops (i, b):

i + b = max =
INTEGER
i - b = max =
INTEGER
i * b = max =
INTEGER
i / b = float =
DOUBLE
i ^ b = float =
DOUBLE
i \ b = non-float =
INTEGER
i mod b = non-float =
INTEGER

bitops (i, b):

i shl b = non-float =
INTEGER
i shr b = non-float =
INTEGER
i and b = non-float =
INTEGER
i or b = non-float =
INTEGER
i xor b = non-float =
INTEGER
i eqv b = non-float =
INTEGER
i imp b = non-float =
INTEGER

relational ops (i, b):

i = b = integer =
INTEGER
i > b = integer =
INTEGER
i < b = integer =
INTEGER
i <> b = integer =
INTEGER
i <= b = integer =
INTEGER
i >= b = integer =
INTEGER
i andalso b = integer =
INTEGER
i orelse b = integer =
INTEGER

math ops (i, ub):

i + ub = max =
INTEGER
i - ub = max =
INTEGER
i * ub = max =
INTEGER
i / ub = float =
DOUBLE
i ^ ub = float =
DOUBLE
i \ ub = non-float =
INTEGER
i mod ub = non-float =
INTEGER

bitops (i, ub):

i shl ub = non-float =
INTEGER
i shr ub = non-float =
INTEGER
i and ub = non-float =
INTEGER
i or ub = non-float =
INTEGER
i xor ub = non-float =
INTEGER
i eqv ub = non-float =
INTEGER
i imp ub = non-float =
INTEGER

relational ops (i, ub):

i = ub = integer =
INTEGER
i > ub = integer =
INTEGER
i < ub = integer =
INTEGER
i <> ub = integer =
INTEGER
i <= ub = integer =
INTEGER
i >= ub = integer =
INTEGER
i andalso ub = integer =
INTEGER
i orelse ub = integer =
INTEGER

math ops (i, sh):

i + sh = max =
INTEGER
i - sh = max =
INTEGER
i * sh = max =
INTEGER
i / sh = float =
DOUBLE
i ^ sh = float =
DOUBLE
i \ sh = non-float =
INTEGER
i mod sh = non-float =
INTEGER

bitops (i, sh):

i shl sh = non-float =
INTEGER
i shr sh = non-float =
INTEGER
i and sh = non-float =
INTEGER
i or sh = non-float =
INTEGER
i xor sh = non-float =
INTEGER
i eqv sh = non-float =
INTEGER
i imp sh = non-float =
INTEGER

relational ops (i, sh):

i = sh = integer =
INTEGER
i > sh = integer =
INTEGER
i < sh = integer =
INTEGER
i <> sh = integer =
INTEGER
i <= sh = integer =
INTEGER
i >= sh = integer =
INTEGER
i andalso sh = integer =
INTEGER
i orelse sh = integer =
INTEGER

math ops (i, ush):

i + ush = max =
INTEGER
i - ush = max =
INTEGER
i * ush = max =
INTEGER
i / ush = float =
DOUBLE
i ^ ush = float =
DOUBLE
i \ ush = non-float =
INTEGER
i mod ush = non-float =
INTEGER

bitops (i, ush):

i shl ush = non-float =
INTEGER
i shr ush = non-float =
INTEGER
i and ush = non-float =
INTEGER
i or ush = non-float =
INTEGER
i xor ush = non-float =
INTEGER
i eqv ush = non-float =
INTEGER
i imp ush = non-float =
INTEGER

relational ops (i, ush):

i = ush = integer =
INTEGER
i > ush = integer =
INTEGER
i < ush = integer =
INTEGER
i <> ush = integer =
INTEGER
i <= ush = integer =
INTEGER
i >= ush = integer =
INTEGER
i andalso ush = integer =
INTEGER
i orelse ush = integer =
INTEGER

math ops (i, i):

i + i = max =
INTEGER
i - i = max =
INTEGER
i * i = max =
INTEGER
i / i = float =
DOUBLE
i ^ i = float =
DOUBLE
i \ i = non-float =
INTEGER
i mod i = non-float =
INTEGER

bitops (i, i):

i shl i = non-float =
INTEGER
i shr i = non-float =
INTEGER
i and i = non-float =
INTEGER
i or i = non-float =
INTEGER
i xor i = non-float =
INTEGER
i eqv i = non-float =
INTEGER
i imp i = non-float =
INTEGER

relational ops (i, i):

i = i = integer =
INTEGER
i > i = integer =
INTEGER
i < i = integer =
INTEGER
i <> i = integer =
INTEGER
i <= i = integer =
INTEGER
i >= i = integer =
INTEGER
i andalso i = integer =
INTEGER
i orelse i = integer =
INTEGER

math ops (i, ui):

i + ui = max =
UINTEGER
i - ui = max =
UINTEGER
i * ui = max =
UINTEGER
i / ui = float =
DOUBLE
i ^ ui = float =
DOUBLE
i \ ui = non-float =
UINTEGER
i mod ui = non-float =
UINTEGER

bitops (i, ui):

i shl ui = non-float =
UINTEGER
i shr ui = non-float =
UINTEGER
i and ui = non-float =
UINTEGER
i or ui = non-float =
UINTEGER
i xor ui = non-float =
UINTEGER
i eqv ui = non-float =
UINTEGER
i imp ui = non-float =
UINTEGER

relational ops (i, ui):

i = ui = integer =
INTEGER
i > ui = integer =
INTEGER
i < ui = integer =
INTEGER
i <> ui = integer =
INTEGER
i <= ui = integer =
INTEGER
i >= ui = integer =
INTEGER
i andalso ui = integer =
INTEGER
i orelse ui = integer =
INTEGER

math ops (i, l):

i + l = max =
INTEGER
i - l = max =
INTEGER
i * l = max =
INTEGER
i / l = float =
DOUBLE
i ^ l = float =
DOUBLE
i \ l = non-float =
INTEGER
i mod l = non-float =
INTEGER

bitops (i, l):

i shl l = non-float =
INTEGER
i shr l = non-float =
INTEGER
i and l = non-float =
INTEGER
i or l = non-float =
INTEGER
i xor l = non-float =
INTEGER
i eqv l = non-float =
INTEGER
i imp l = non-float =
INTEGER

relational ops (i, l):

i = l = integer =
INTEGER
i > l = integer =
INTEGER
i < l = integer =
INTEGER
i <> l = integer =
INTEGER
i <= l = integer =
INTEGER
i >= l = integer =
INTEGER
i andalso l = integer =
INTEGER
i orelse l = integer =
INTEGER

math ops (i, ul):

i + ul = max =
INTEGER
i - ul = max =
INTEGER
i * ul = max =
INTEGER
i / ul = float =
DOUBLE
i ^ ul = float =
DOUBLE
i \ ul = non-float =
INTEGER
i mod ul = non-float =
INTEGER

bitops (i, ul):

i shl ul = non-float =
INTEGER
i shr ul = non-float =
INTEGER
i and ul = non-float =
INTEGER
i or ul = non-float =
INTEGER
i xor ul = non-float =
INTEGER
i eqv ul = non-float =
INTEGER
i imp ul = non-float =
INTEGER

relational ops (i, ul):

i = ul = integer =
INTEGER
i > ul = integer =
INTEGER
i < ul = integer =
INTEGER
i <> ul = integer =
INTEGER
i <= ul = integer =
INTEGER
i >= ul = integer =
INTEGER
i andalso ul = integer =
INTEGER
i orelse ul = integer =
INTEGER

math ops (i, ll):

i + ll = max =
INTEGER
i - ll = max =
INTEGER
i * ll = max =
INTEGER
i / ll = float =
DOUBLE
i ^ ll = float =
DOUBLE
i \ ll = non-float =
INTEGER
i mod ll = non-float =
INTEGER

bitops (i, ll):

i shl ll = non-float =
INTEGER
i shr ll = non-float =
INTEGER
i and ll = non-float =
INTEGER
i or ll = non-float =
INTEGER
i xor ll = non-float =
INTEGER
i eqv ll = non-float =
INTEGER
i imp ll = non-float =
INTEGER

relational ops (i, ll):

i = ll = integer =
INTEGER
i > ll = integer =
INTEGER
i < ll = integer =
INTEGER
i <> ll = integer =
INTEGER
i <= ll = integer =
INTEGER
i >= ll = integer =
INTEGER
i andalso ll = integer =
INTEGER
i orelse ll = integer =
INTEGER

math ops (i, ull):

i + ull = max =
UINTEGER
i - ull = max =
UINTEGER
i * ull = max =
UINTEGER
i / ull = float =
DOUBLE
i ^ ull = float =
DOUBLE
i \ ull = non-float =
UINTEGER
i mod ull = non-float =
UINTEGER

bitops (i, ull):

i shl ull = non-float =
UINTEGER
i shr ull = non-float =
UINTEGER
i and ull = non-float =
UINTEGER
i or ull = non-float =
UINTEGER
i xor ull = non-float =
UINTEGER
i eqv ull = non-float =
UINTEGER
i imp ull = non-float =
UINTEGER

relational ops (i, ull):

i = ull = integer =
INTEGER
i > ull = integer =
INTEGER
i < ull = integer =
INTEGER
i <> ull = integer =
INTEGER
i <= ull = integer =
INTEGER
i >= ull = integer =
INTEGER
i andalso ull = integer =
INTEGER
i orelse ull = integer =
INTEGER

math ops (i, enum1a):

i + enum1a = max =
INTEGER
i - enum1a = max =
INTEGER
i * enum1a = max =
INTEGER
i / enum1a = float =
DOUBLE
i ^ enum1a = float =
DOUBLE
i \ enum1a = non-float =
INTEGER
i mod enum1a = non-float =
INTEGER

bitops (i, enum1a):

i shl enum1a = non-float =
INTEGER
i shr enum1a = non-float =
INTEGER
i and enum1a = non-float =
INTEGER
i or enum1a = non-float =
INTEGER
i xor enum1a = non-float =
INTEGER
i eqv enum1a = non-float =
INTEGER
i imp enum1a = non-float =
INTEGER

relational ops (i, enum1a):

i = enum1a = integer =
INTEGER
i > enum1a = integer =
INTEGER
i < enum1a = integer =
INTEGER
i <> enum1a = integer =
INTEGER
i <= enum1a = integer =
INTEGER
i >= enum1a = integer =
INTEGER
i andalso enum1a = integer =
INTEGER
i orelse enum1a = integer =
INTEGER

math ops (b, i):

b + i = max =
INTEGER
b - i = max =
INTEGER
b * i = max =
INTEGER
b / i = float =
DOUBLE
b ^ i = float =
DOUBLE
b \ i = non-float =
INTEGER
b mod i = non-float =
INTEGER

bitops (b, i):

b shl i = non-float =
INTEGER
b shr i = non-float =
INTEGER
b and i = non-float =
INTEGER
b or i = non-float =
INTEGER
b xor i = non-float =
INTEGER
b eqv i = non-float =
INTEGER
b imp i = non-float =
INTEGER

relational ops (b, i):

b = i = integer =
INTEGER
b > i = integer =
INTEGER
b < i = integer =
INTEGER
b <> i = integer =
INTEGER
b <= i = integer =
INTEGER
b >= i = integer =
INTEGER
b andalso i = integer =
INTEGER
b orelse i = integer =
INTEGER

math ops (ub, i):

ub + i = max =
INTEGER
ub - i = max =
INTEGER
ub * i = max =
INTEGER
ub / i = float =
DOUBLE
ub ^ i = float =
DOUBLE
ub \ i = non-float =
INTEGER
ub mod i = non-float =
INTEGER

bitops (ub, i):

ub shl i = non-float =
INTEGER
ub shr i = non-float =
INTEGER
ub and i = non-float =
INTEGER
ub or i = non-float =
INTEGER
ub xor i = non-float =
INTEGER
ub eqv i = non-float =
INTEGER
ub imp i = non-float =
INTEGER

relational ops (ub, i):

ub = i = integer =
INTEGER
ub > i = integer =
INTEGER
ub < i = integer =
INTEGER
ub <> i = integer =
INTEGER
ub <= i = integer =
INTEGER
ub >= i = integer =
INTEGER
ub andalso i = integer =
INTEGER
ub orelse i = integer =
INTEGER

math ops (sh, i):

sh + i = max =
INTEGER
sh - i = max =
INTEGER
sh * i = max =
INTEGER
sh / i = float =
DOUBLE
sh ^ i = float =
DOUBLE
sh \ i = non-float =
INTEGER
sh mod i = non-float =
INTEGER

bitops (sh, i):

sh shl i = non-float =
INTEGER
sh shr i = non-float =
INTEGER
sh and i = non-float =
INTEGER
sh or i = non-float =
INTEGER
sh xor i = non-float =
INTEGER
sh eqv i = non-float =
INTEGER
sh imp i = non-float =
INTEGER

relational ops (sh, i):

sh = i = integer =
INTEGER
sh > i = integer =
INTEGER
sh < i = integer =
INTEGER
sh <> i = integer =
INTEGER
sh <= i = integer =
INTEGER
sh >= i = integer =
INTEGER
sh andalso i = integer =
INTEGER
sh orelse i = integer =
INTEGER

math ops (ush, i):

ush + i = max =
INTEGER
ush - i = max =
INTEGER
ush * i = max =
INTEGER
ush / i = float =
DOUBLE
ush ^ i = float =
DOUBLE
ush \ i = non-float =
INTEGER
ush mod i = non-float =
INTEGER

bitops (ush, i):

ush shl i = non-float =
INTEGER
ush shr i = non-float =
INTEGER
ush and i = non-float =
INTEGER
ush or i = non-float =
INTEGER
ush xor i = non-float =
INTEGER
ush eqv i = non-float =
INTEGER
ush imp i = non-float =
INTEGER

relational ops (ush, i):

ush = i = integer =
INTEGER
ush > i = integer =
INTEGER
ush < i = integer =
INTEGER
ush <> i = integer =
INTEGER
ush <= i = integer =
INTEGER
ush >= i = integer =
INTEGER
ush andalso i = integer =
INTEGER
ush orelse i = integer =
INTEGER

math ops (i, i):

i + i = max =
INTEGER
i - i = max =
INTEGER
i * i = max =
INTEGER
i / i = float =
DOUBLE
i ^ i = float =
DOUBLE
i \ i = non-float =
INTEGER
i mod i = non-float =
INTEGER

bitops (i, i):

i shl i = non-float =
INTEGER
i shr i = non-float =
INTEGER
i and i = non-float =
INTEGER
i or i = non-float =
INTEGER
i xor i = non-float =
INTEGER
i eqv i = non-float =
INTEGER
i imp i = non-float =
INTEGER

relational ops (i, i):

i = i = integer =
INTEGER
i > i = integer =
INTEGER
i < i = integer =
INTEGER
i <> i = integer =
INTEGER
i <= i = integer =
INTEGER
i >= i = integer =
INTEGER
i andalso i = integer =
INTEGER
i orelse i = integer =
INTEGER

math ops (ui, i):

ui + i = max =
UINTEGER
ui - i = max =
UINTEGER
ui * i = max =
UINTEGER
ui / i = float =
DOUBLE
ui ^ i = float =
DOUBLE
ui \ i = non-float =
UINTEGER
ui mod i = non-float =
UINTEGER

bitops (ui, i):

ui shl i = non-float =
UINTEGER
ui shr i = non-float =
UINTEGER
ui and i = non-float =
UINTEGER
ui or i = non-float =
UINTEGER
ui xor i = non-float =
UINTEGER
ui eqv i = non-float =
UINTEGER
ui imp i = non-float =
UINTEGER

relational ops (ui, i):

ui = i = integer =
INTEGER
ui > i = integer =
INTEGER
ui < i = integer =
INTEGER
ui <> i = integer =
INTEGER
ui <= i = integer =
INTEGER
ui >= i = integer =
INTEGER
ui andalso i = integer =
INTEGER
ui orelse i = integer =
INTEGER

math ops (l, i):

l + i = max =
INTEGER
l - i = max =
INTEGER
l * i = max =
INTEGER
l / i = float =
DOUBLE
l ^ i = float =
DOUBLE
l \ i = non-float =
INTEGER
l mod i = non-float =
INTEGER

bitops (l, i):

l shl i = non-float =
INTEGER
l shr i = non-float =
INTEGER
l and i = non-float =
INTEGER
l or i = non-float =
INTEGER
l xor i = non-float =
INTEGER
l eqv i = non-float =
INTEGER
l imp i = non-float =
INTEGER

relational ops (l, i):

l = i = integer =
INTEGER
l > i = integer =
INTEGER
l < i = integer =
INTEGER
l <> i = integer =
INTEGER
l <= i = integer =
INTEGER
l >= i = integer =
INTEGER
l andalso i = integer =
INTEGER
l orelse i = integer =
INTEGER

math ops (ul, i):

ul + i = max =
INTEGER
ul - i = max =
INTEGER
ul * i = max =
INTEGER
ul / i = float =
DOUBLE
ul ^ i = float =
DOUBLE
ul \ i = non-float =
INTEGER
ul mod i = non-float =
INTEGER

bitops (ul, i):

ul shl i = non-float =
INTEGER
ul shr i = non-float =
INTEGER
ul and i = non-float =
INTEGER
ul or i = non-float =
INTEGER
ul xor i = non-float =
INTEGER
ul eqv i = non-float =
INTEGER
ul imp i = non-float =
INTEGER

relational ops (ul, i):

ul = i = integer =
INTEGER
ul > i = integer =
INTEGER
ul < i = integer =
INTEGER
ul <> i = integer =
INTEGER
ul <= i = integer =
INTEGER
ul >= i = integer =
INTEGER
ul andalso i = integer =
INTEGER
ul orelse i = integer =
INTEGER

math ops (ll, i):

ll + i = max =
INTEGER
ll - i = max =
INTEGER
ll * i = max =
INTEGER
ll / i = float =
DOUBLE
ll ^ i = float =
DOUBLE
ll \ i = non-float =
INTEGER
ll mod i = non-float =
INTEGER

bitops (ll, i):

ll shl i = non-float =
INTEGER
ll shr i = non-float =
INTEGER
ll and i = non-float =
INTEGER
ll or i = non-float =
INTEGER
ll xor i = non-float =
INTEGER
ll eqv i = non-float =
INTEGER
ll imp i = non-float =
INTEGER

relational ops (ll, i):

ll = i = integer =
INTEGER
ll > i = integer =
INTEGER
ll < i = integer =
INTEGER
ll <> i = integer =
INTEGER
ll <= i = integer =
INTEGER
ll >= i = integer =
INTEGER
ll andalso i = integer =
INTEGER
ll orelse i = integer =
INTEGER

math ops (ull, i):

ull + i = max =
UINTEGER
ull - i = max =
UINTEGER
ull * i = max =
UINTEGER
ull / i = float =
DOUBLE
ull ^ i = float =
DOUBLE
ull \ i = non-float =
UINTEGER
ull mod i = non-float =
UINTEGER

bitops (ull, i):

ull shl i = non-float =
UINTEGER
ull shr i = non-float =
UINTEGER
ull and i = non-float =
UINTEGER
ull or i = non-float =
UINTEGER
ull xor i = non-float =
UINTEGER
ull eqv i = non-float =
UINTEGER
ull imp i = non-float =
UINTEGER

relational ops (ull, i):

ull = i = integer =
INTEGER
ull > i = integer =
INTEGER
ull < i = integer =
INTEGER
ull <> i = integer =
INTEGER
ull <= i = integer =
INTEGER
ull >= i = integer =
INTEGER
ull andalso i = integer =
INTEGER
ull orelse i = integer =
INTEGER

math ops (enum1a, i):

enum1a + i = max =
INTEGER
enum1a - i = max =
INTEGER
enum1a * i = max =
INTEGER
enum1a / i = float =
DOUBLE
enum1a ^ i = float =
DOUBLE
enum1a \ i = non-float =
INTEGER
enum1a mod i = non-float =
INTEGER

bitops (enum1a, i):

enum1a shl i = non-float =
INTEGER
enum1a shr i = non-float =
INTEGER
enum1a and i = non-float =
INTEGER
enum1a or i = non-float =
INTEGER
enum1a xor i = non-float =
INTEGER
enum1a eqv i = non-float =
INTEGER
enum1a imp i = non-float =
INTEGER

relational ops (enum1a, i):

enum1a = i = integer =
INTEGER
enum1a > i = integer =
INTEGER
enum1a < i = integer =
INTEGER
enum1a <> i = integer =
INTEGER
enum1a <= i = integer =
INTEGER
enum1a >= i = integer =
INTEGER
enum1a andalso i = integer =
INTEGER
enum1a orelse i = integer =
INTEGER

math ops (i, f):

i + f = max =
SINGLE
i - f = max =
SINGLE
i * f = max =
SINGLE
i / f = float =
DOUBLE
i ^ f = float =
DOUBLE
i \ f = non-float =
INTEGER
i mod f = non-float =
INTEGER

bitops (i, f):

i shl f = non-float =
INTEGER
i shr f = non-float =
INTEGER
i and f = non-float =
INTEGER
i or f = non-float =
INTEGER
i xor f = non-float =
INTEGER
i eqv f = non-float =
INTEGER
i imp f = non-float =
INTEGER

relational ops (i, f):

i = f = integer =
INTEGER
i > f = integer =
INTEGER
i < f = integer =
INTEGER
i <> f = integer =
INTEGER
i <= f = integer =
INTEGER
i >= f = integer =
INTEGER
i andalso f = integer =
INTEGER
i orelse f = integer =
INTEGER

math ops (i, d):

i + d = max =
DOUBLE
i - d = max =
DOUBLE
i * d = max =
DOUBLE
i / d = float =
DOUBLE
i ^ d = float =
DOUBLE
i \ d = non-float =
INTEGER
i mod d = non-float =
INTEGER

bitops (i, d):

i shl d = non-float =
INTEGER
i shr d = non-float =
INTEGER
i and d = non-float =
INTEGER
i or d = non-float =
INTEGER
i xor d = non-float =
INTEGER
i eqv d = non-float =
INTEGER
i imp d = non-float =
INTEGER

relational ops (i, d):

i = d = integer =
INTEGER
i > d = integer =
INTEGER
i < d = integer =
INTEGER
i <> d = integer =
INTEGER
i <= d = integer =
INTEGER
i >= d = integer =
INTEGER
i andalso d = integer =
INTEGER
i orelse d = integer =
INTEGER

math ops (f, i):

f + i = max =
SINGLE
f - i = max =
SINGLE
f * i = max =
SINGLE
f / i = float =
DOUBLE
f ^ i = float =
DOUBLE
f \ i = non-float =
INTEGER
f mod i = non-float =
INTEGER

bitops (f, i):

f shl i = non-float =
INTEGER
f shr i = non-float =
INTEGER
f and i = non-float =
INTEGER
f or i = non-float =
INTEGER
f xor i = non-float =
INTEGER
f eqv i = non-float =
INTEGER
f imp i = non-float =
INTEGER

relational ops (f, i):

f = i = integer =
INTEGER
f > i = integer =
INTEGER
f < i = integer =
INTEGER
f <> i = integer =
INTEGER
f <= i = integer =
INTEGER
f >= i = integer =
INTEGER
f andalso i = integer =
INTEGER
f orelse i = integer =
INTEGER

math ops (d, i):

d + i = max =
DOUBLE
d - i = max =
DOUBLE
d * i = max =
DOUBLE
d / i = float =
DOUBLE
d ^ i = float =
DOUBLE
d \ i = non-float =
INTEGER
d mod i = non-float =
INTEGER

bitops (d, i):

d shl i = non-float =
INTEGER
d shr i = non-float =
INTEGER
d and i = non-float =
INTEGER
d or i = non-float =
INTEGER
d xor i = non-float =
INTEGER
d eqv i = non-float =
INTEGER
d imp i = non-float =
INTEGER

relational ops (d, i):

d = i = integer =
INTEGER
d > i = integer =
INTEGER
d < i = integer =
INTEGER
d <> i = integer =
INTEGER
d <= i = integer =
INTEGER
d >= i = integer =
INTEGER
d andalso i = integer =
INTEGER
d orelse i = integer =
INTEGER

----- ui -----------------------------------------------------


math ops (ui, b):

ui + b = max =
UINTEGER
ui - b = max =
UINTEGER
ui * b = max =
UINTEGER
ui / b = float =
DOUBLE
ui ^ b = float =
DOUBLE
ui \ b = non-float =
UINTEGER
ui mod b = non-float =
UINTEGER

bitops (ui, b):

ui shl b = non-float =
UINTEGER
ui shr b = non-float =
UINTEGER
ui and b = non-float =
UINTEGER
ui or b = non-float =
UINTEGER
ui xor b = non-float =
UINTEGER
ui eqv b = non-float =
UINTEGER
ui imp b = non-float =
UINTEGER

relational ops (ui, b):

ui = b = integer =
INTEGER
ui > b = integer =
INTEGER
ui < b = integer =
INTEGER
ui <> b = integer =
INTEGER
ui <= b = integer =
INTEGER
ui >= b = integer =
INTEGER
ui andalso b = integer =
INTEGER
ui orelse b = integer =
INTEGER

math ops (ui, ub):

ui + ub = max =
UINTEGER
ui - ub = max =
UINTEGER
ui * ub = max =
UINTEGER
ui / ub = float =
DOUBLE
ui ^ ub = float =
DOUBLE
ui \ ub = non-float =
UINTEGER
ui mod ub = non-float =
UINTEGER

bitops (ui, ub):

ui shl ub = non-float =
UINTEGER
ui shr ub = non-float =
UINTEGER
ui and ub = non-float =
UINTEGER
ui or ub = non-float =
UINTEGER
ui xor ub = non-float =
UINTEGER
ui eqv ub = non-float =
UINTEGER
ui imp ub = non-float =
UINTEGER

relational ops (ui, ub):

ui = ub = integer =
INTEGER
ui > ub = integer =
INTEGER
ui < ub = integer =
INTEGER
ui <> ub = integer =
INTEGER
ui <= ub = integer =
INTEGER
ui >= ub = integer =
INTEGER
ui andalso ub = integer =
INTEGER
ui orelse ub = integer =
INTEGER

math ops (ui, sh):

ui + sh = max =
UINTEGER
ui - sh = max =
UINTEGER
ui * sh = max =
UINTEGER
ui / sh = float =
DOUBLE
ui ^ sh = float =
DOUBLE
ui \ sh = non-float =
UINTEGER
ui mod sh = non-float =
UINTEGER

bitops (ui, sh):

ui shl sh = non-float =
UINTEGER
ui shr sh = non-float =
UINTEGER
ui and sh = non-float =
UINTEGER
ui or sh = non-float =
UINTEGER
ui xor sh = non-float =
UINTEGER
ui eqv sh = non-float =
UINTEGER
ui imp sh = non-float =
UINTEGER

relational ops (ui, sh):

ui = sh = integer =
INTEGER
ui > sh = integer =
INTEGER
ui < sh = integer =
INTEGER
ui <> sh = integer =
INTEGER
ui <= sh = integer =
INTEGER
ui >= sh = integer =
INTEGER
ui andalso sh = integer =
INTEGER
ui orelse sh = integer =
INTEGER

math ops (ui, ush):

ui + ush = max =
UINTEGER
ui - ush = max =
UINTEGER
ui * ush = max =
UINTEGER
ui / ush = float =
DOUBLE
ui ^ ush = float =
DOUBLE
ui \ ush = non-float =
UINTEGER
ui mod ush = non-float =
UINTEGER

bitops (ui, ush):

ui shl ush = non-float =
UINTEGER
ui shr ush = non-float =
UINTEGER
ui and ush = non-float =
UINTEGER
ui or ush = non-float =
UINTEGER
ui xor ush = non-float =
UINTEGER
ui eqv ush = non-float =
UINTEGER
ui imp ush = non-float =
UINTEGER

relational ops (ui, ush):

ui = ush = integer =
INTEGER
ui > ush = integer =
INTEGER
ui < ush = integer =
INTEGER
ui <> ush = integer =
INTEGER
ui <= ush = integer =
INTEGER
ui >= ush = integer =
INTEGER
ui andalso ush = integer =
INTEGER
ui orelse ush = integer =
INTEGER

math ops (ui, i):

ui + i = max =
UINTEGER
ui - i = max =
UINTEGER
ui * i = max =
UINTEGER
ui / i = float =
DOUBLE
ui ^ i = float =
DOUBLE
ui \ i = non-float =
UINTEGER
ui mod i = non-float =
UINTEGER

bitops (ui, i):

ui shl i = non-float =
UINTEGER
ui shr i = non-float =
UINTEGER
ui and i = non-float =
UINTEGER
ui or i = non-float =
UINTEGER
ui xor i = non-float =
UINTEGER
ui eqv i = non-float =
UINTEGER
ui imp i = non-float =
UINTEGER

relational ops (ui, i):

ui = i = integer =
INTEGER
ui > i = integer =
INTEGER
ui < i = integer =
INTEGER
ui <> i = integer =
INTEGER
ui <= i = integer =
INTEGER
ui >= i = integer =
INTEGER
ui andalso i = integer =
INTEGER
ui orelse i = integer =
INTEGER

math ops (ui, ui):

ui + ui = max =
UINTEGER
ui - ui = max =
UINTEGER
ui * ui = max =
UINTEGER
ui / ui = float =
DOUBLE
ui ^ ui = float =
DOUBLE
ui \ ui = non-float =
UINTEGER
ui mod ui = non-float =
UINTEGER

bitops (ui, ui):

ui shl ui = non-float =
UINTEGER
ui shr ui = non-float =
UINTEGER
ui and ui = non-float =
UINTEGER
ui or ui = non-float =
UINTEGER
ui xor ui = non-float =
UINTEGER
ui eqv ui = non-float =
UINTEGER
ui imp ui = non-float =
UINTEGER

relational ops (ui, ui):

ui = ui = integer =
INTEGER
ui > ui = integer =
INTEGER
ui < ui = integer =
INTEGER
ui <> ui = integer =
INTEGER
ui <= ui = integer =
INTEGER
ui >= ui = integer =
INTEGER
ui andalso ui = integer =
INTEGER
ui orelse ui = integer =
INTEGER

math ops (ui, l):

ui + l = max =
UINTEGER
ui - l = max =
UINTEGER
ui * l = max =
UINTEGER
ui / l = float =
DOUBLE
ui ^ l = float =
DOUBLE
ui \ l = non-float =
UINTEGER
ui mod l = non-float =
UINTEGER

bitops (ui, l):

ui shl l = non-float =
UINTEGER
ui shr l = non-float =
UINTEGER
ui and l = non-float =
UINTEGER
ui or l = non-float =
UINTEGER
ui xor l = non-float =
UINTEGER
ui eqv l = non-float =
UINTEGER
ui imp l = non-float =
UINTEGER

relational ops (ui, l):

ui = l = integer =
INTEGER
ui > l = integer =
INTEGER
ui < l = integer =
INTEGER
ui <> l = integer =
INTEGER
ui <= l = integer =
INTEGER
ui >= l = integer =
INTEGER
ui andalso l = integer =
INTEGER
ui orelse l = integer =
INTEGER

math ops (ui, ul):

ui + ul = max =
UINTEGER
ui - ul = max =
UINTEGER
ui * ul = max =
UINTEGER
ui / ul = float =
DOUBLE
ui ^ ul = float =
DOUBLE
ui \ ul = non-float =
UINTEGER
ui mod ul = non-float =
UINTEGER

bitops (ui, ul):

ui shl ul = non-float =
UINTEGER
ui shr ul = non-float =
UINTEGER
ui and ul = non-float =
UINTEGER
ui or ul = non-float =
UINTEGER
ui xor ul = non-float =
UINTEGER
ui eqv ul = non-float =
UINTEGER
ui imp ul = non-float =
UINTEGER

relational ops (ui, ul):

ui = ul = integer =
INTEGER
ui > ul = integer =
INTEGER
ui < ul = integer =
INTEGER
ui <> ul = integer =
INTEGER
ui <= ul = integer =
INTEGER
ui >= ul = integer =
INTEGER
ui andalso ul = integer =
INTEGER
ui orelse ul = integer =
INTEGER

math ops (ui, ll):

ui + ll = max =
UINTEGER
ui - ll = max =
UINTEGER
ui * ll = max =
UINTEGER
ui / ll = float =
DOUBLE
ui ^ ll = float =
DOUBLE
ui \ ll = non-float =
UINTEGER
ui mod ll = non-float =
UINTEGER

bitops (ui, ll):

ui shl ll = non-float =
UINTEGER
ui shr ll = non-float =
UINTEGER
ui and ll = non-float =
UINTEGER
ui or ll = non-float =
UINTEGER
ui xor ll = non-float =
UINTEGER
ui eqv ll = non-float =
UINTEGER
ui imp ll = non-float =
UINTEGER

relational ops (ui, ll):

ui = ll = integer =
INTEGER
ui > ll = integer =
INTEGER
ui < ll = integer =
INTEGER
ui <> ll = integer =
INTEGER
ui <= ll = integer =
INTEGER
ui >= ll = integer =
INTEGER
ui andalso ll = integer =
INTEGER
ui orelse ll = integer =
INTEGER

math ops (ui, ull):

ui + ull = max =
UINTEGER
ui - ull = max =
UINTEGER
ui * ull = max =
UINTEGER
ui / ull = float =
DOUBLE
ui ^ ull = float =
DOUBLE
ui \ ull = non-float =
UINTEGER
ui mod ull = non-float =
UINTEGER

bitops (ui, ull):

ui shl ull = non-float =
UINTEGER
ui shr ull = non-float =
UINTEGER
ui and ull = non-float =
UINTEGER
ui or ull = non-float =
UINTEGER
ui xor ull = non-float =
UINTEGER
ui eqv ull = non-float =
UINTEGER
ui imp ull = non-float =
UINTEGER

relational ops (ui, ull):

ui = ull = integer =
INTEGER
ui > ull = integer =
INTEGER
ui < ull = integer =
INTEGER
ui <> ull = integer =
INTEGER
ui <= ull = integer =
INTEGER
ui >= ull = integer =
INTEGER
ui andalso ull = integer =
INTEGER
ui orelse ull = integer =
INTEGER

math ops (ui, enum1a):

ui + enum1a = max =
UINTEGER
ui - enum1a = max =
UINTEGER
ui * enum1a = max =
UINTEGER
ui / enum1a = float =
DOUBLE
ui ^ enum1a = float =
DOUBLE
ui \ enum1a = non-float =
UINTEGER
ui mod enum1a = non-float =
UINTEGER

bitops (ui, enum1a):

ui shl enum1a = non-float =
UINTEGER
ui shr enum1a = non-float =
UINTEGER
ui and enum1a = non-float =
UINTEGER
ui or enum1a = non-float =
UINTEGER
ui xor enum1a = non-float =
UINTEGER
ui eqv enum1a = non-float =
UINTEGER
ui imp enum1a = non-float =
UINTEGER

relational ops (ui, enum1a):

ui = enum1a = integer =
INTEGER
ui > enum1a = integer =
INTEGER
ui < enum1a = integer =
INTEGER
ui <> enum1a = integer =
INTEGER
ui <= enum1a = integer =
INTEGER
ui >= enum1a = integer =
INTEGER
ui andalso enum1a = integer =
INTEGER
ui orelse enum1a = integer =
INTEGER

math ops (b, ui):

b + ui = max =
UINTEGER
b - ui = max =
UINTEGER
b * ui = max =
UINTEGER
b / ui = float =
DOUBLE
b ^ ui = float =
DOUBLE
b \ ui = non-float =
UINTEGER
b mod ui = non-float =
UINTEGER

bitops (b, ui):

b shl ui = non-float =
UINTEGER
b shr ui = non-float =
UINTEGER
b and ui = non-float =
UINTEGER
b or ui = non-float =
UINTEGER
b xor ui = non-float =
UINTEGER
b eqv ui = non-float =
UINTEGER
b imp ui = non-float =
UINTEGER

relational ops (b, ui):

b = ui = integer =
INTEGER
b > ui = integer =
INTEGER
b < ui = integer =
INTEGER
b <> ui = integer =
INTEGER
b <= ui = integer =
INTEGER
b >= ui = integer =
INTEGER
b andalso ui = integer =
INTEGER
b orelse ui = integer =
INTEGER

math ops (ub, ui):

ub + ui = max =
UINTEGER
ub - ui = max =
UINTEGER
ub * ui = max =
UINTEGER
ub / ui = float =
DOUBLE
ub ^ ui = float =
DOUBLE
ub \ ui = non-float =
UINTEGER
ub mod ui = non-float =
UINTEGER

bitops (ub, ui):

ub shl ui = non-float =
UINTEGER
ub shr ui = non-float =
UINTEGER
ub and ui = non-float =
UINTEGER
ub or ui = non-float =
UINTEGER
ub xor ui = non-float =
UINTEGER
ub eqv ui = non-float =
UINTEGER
ub imp ui = non-float =
UINTEGER

relational ops (ub, ui):

ub = ui = integer =
INTEGER
ub > ui = integer =
INTEGER
ub < ui = integer =
INTEGER
ub <> ui = integer =
INTEGER
ub <= ui = integer =
INTEGER
ub >= ui = integer =
INTEGER
ub andalso ui = integer =
INTEGER
ub orelse ui = integer =
INTEGER

math ops (sh, ui):

sh + ui = max =
UINTEGER
sh - ui = max =
UINTEGER
sh * ui = max =
UINTEGER
sh / ui = float =
DOUBLE
sh ^ ui = float =
DOUBLE
sh \ ui = non-float =
UINTEGER
sh mod ui = non-float =
UINTEGER

bitops (sh, ui):

sh shl ui = non-float =
UINTEGER
sh shr ui = non-float =
UINTEGER
sh and ui = non-float =
UINTEGER
sh or ui = non-float =
UINTEGER
sh xor ui = non-float =
UINTEGER
sh eqv ui = non-float =
UINTEGER
sh imp ui = non-float =
UINTEGER

relational ops (sh, ui):

sh = ui = integer =
INTEGER
sh > ui = integer =
INTEGER
sh < ui = integer =
INTEGER
sh <> ui = integer =
INTEGER
sh <= ui = integer =
INTEGER
sh >= ui = integer =
INTEGER
sh andalso ui = integer =
INTEGER
sh orelse ui = integer =
INTEGER

math ops (ush, ui):

ush + ui = max =
UINTEGER
ush - ui = max =
UINTEGER
ush * ui = max =
UINTEGER
ush / ui = float =
DOUBLE
ush ^ ui = float =
DOUBLE
ush \ ui = non-float =
UINTEGER
ush mod ui = non-float =
UINTEGER

bitops (ush, ui):

ush shl ui = non-float =
UINTEGER
ush shr ui = non-float =
UINTEGER
ush and ui = non-float =
UINTEGER
ush or ui = non-float =
UINTEGER
ush xor ui = non-float =
UINTEGER
ush eqv ui = non-float =
UINTEGER
ush imp ui = non-float =
UINTEGER

relational ops (ush, ui):

ush = ui = integer =
INTEGER
ush > ui = integer =
INTEGER
ush < ui = integer =
INTEGER
ush <> ui = integer =
INTEGER
ush <= ui = integer =
INTEGER
ush >= ui = integer =
INTEGER
ush andalso ui = integer =
INTEGER
ush orelse ui = integer =
INTEGER

math ops (i, ui):

i + ui = max =
UINTEGER
i - ui = max =
UINTEGER
i * ui = max =
UINTEGER
i / ui = float =
DOUBLE
i ^ ui = float =
DOUBLE
i \ ui = non-float =
UINTEGER
i mod ui = non-float =
UINTEGER

bitops (i, ui):

i shl ui = non-float =
UINTEGER
i shr ui = non-float =
UINTEGER
i and ui = non-float =
UINTEGER
i or ui = non-float =
UINTEGER
i xor ui = non-float =
UINTEGER
i eqv ui = non-float =
UINTEGER
i imp ui = non-float =
UINTEGER

relational ops (i, ui):

i = ui = integer =
INTEGER
i > ui = integer =
INTEGER
i < ui = integer =
INTEGER
i <> ui = integer =
INTEGER
i <= ui = integer =
INTEGER
i >= ui = integer =
INTEGER
i andalso ui = integer =
INTEGER
i orelse ui = integer =
INTEGER

math ops (ui, ui):

ui + ui = max =
UINTEGER
ui - ui = max =
UINTEGER
ui * ui = max =
UINTEGER
ui / ui = float =
DOUBLE
ui ^ ui = float =
DOUBLE
ui \ ui = non-float =
UINTEGER
ui mod ui = non-float =
UINTEGER

bitops (ui, ui):

ui shl ui = non-float =
UINTEGER
ui shr ui = non-float =
UINTEGER
ui and ui = non-float =
UINTEGER
ui or ui = non-float =
UINTEGER
ui xor ui = non-float =
UINTEGER
ui eqv ui = non-float =
UINTEGER
ui imp ui = non-float =
UINTEGER

relational ops (ui, ui):

ui = ui = integer =
INTEGER
ui > ui = integer =
INTEGER
ui < ui = integer =
INTEGER
ui <> ui = integer =
INTEGER
ui <= ui = integer =
INTEGER
ui >= ui = integer =
INTEGER
ui andalso ui = integer =
INTEGER
ui orelse ui = integer =
INTEGER

math ops (l, ui):

l + ui = max =
UINTEGER
l - ui = max =
UINTEGER
l * ui = max =
UINTEGER
l / ui = float =
DOUBLE
l ^ ui = float =
DOUBLE
l \ ui = non-float =
UINTEGER
l mod ui = non-float =
UINTEGER

bitops (l, ui):

l shl ui = non-float =
UINTEGER
l shr ui = non-float =
UINTEGER
l and ui = non-float =
UINTEGER
l or ui = non-float =
UINTEGER
l xor ui = non-float =
UINTEGER
l eqv ui = non-float =
UINTEGER
l imp ui = non-float =
UINTEGER

relational ops (l, ui):

l = ui = integer =
INTEGER
l > ui = integer =
INTEGER
l < ui = integer =
INTEGER
l <> ui = integer =
INTEGER
l <= ui = integer =
INTEGER
l >= ui = integer =
INTEGER
l andalso ui = integer =
INTEGER
l orelse ui = integer =
INTEGER

math ops (ul, ui):

ul + ui = max =
UINTEGER
ul - ui = max =
UINTEGER
ul * ui = max =
UINTEGER
ul / ui = float =
DOUBLE
ul ^ ui = float =
DOUBLE
ul \ ui = non-float =
UINTEGER
ul mod ui = non-float =
UINTEGER

bitops (ul, ui):

ul shl ui = non-float =
UINTEGER
ul shr ui = non-float =
UINTEGER
ul and ui = non-float =
UINTEGER
ul or ui = non-float =
UINTEGER
ul xor ui = non-float =
UINTEGER
ul eqv ui = non-float =
UINTEGER
ul imp ui = non-float =
UINTEGER

relational ops (ul, ui):

ul = ui = integer =
INTEGER
ul > ui = integer =
INTEGER
ul < ui = integer =
INTEGER
ul <> ui = integer =
INTEGER
ul <= ui = integer =
INTEGER
ul >= ui = integer =
INTEGER
ul andalso ui = integer =
INTEGER
ul orelse ui = integer =
INTEGER

math ops (ll, ui):

ll + ui = max =
UINTEGER
ll - ui = max =
UINTEGER
ll * ui = max =
UINTEGER
ll / ui = float =
DOUBLE
ll ^ ui = float =
DOUBLE
ll \ ui = non-float =
UINTEGER
ll mod ui = non-float =
UINTEGER

bitops (ll, ui):

ll shl ui = non-float =
UINTEGER
ll shr ui = non-float =
UINTEGER
ll and ui = non-float =
UINTEGER
ll or ui = non-float =
UINTEGER
ll xor ui = non-float =
UINTEGER
ll eqv ui = non-float =
UINTEGER
ll imp ui = non-float =
UINTEGER

relational ops (ll, ui):

ll = ui = integer =
INTEGER
ll > ui = integer =
INTEGER
ll < ui = integer =
INTEGER
ll <> ui = integer =
INTEGER
ll <= ui = integer =
INTEGER
ll >= ui = integer =
INTEGER
ll andalso ui = integer =
INTEGER
ll orelse ui = integer =
INTEGER

math ops (ull, ui):

ull + ui = max =
UINTEGER
ull - ui = max =
UINTEGER
ull * ui = max =
UINTEGER
ull / ui = float =
DOUBLE
ull ^ ui = float =
DOUBLE
ull \ ui = non-float =
UINTEGER
ull mod ui = non-float =
UINTEGER

bitops (ull, ui):

ull shl ui = non-float =
UINTEGER
ull shr ui = non-float =
UINTEGER
ull and ui = non-float =
UINTEGER
ull or ui = non-float =
UINTEGER
ull xor ui = non-float =
UINTEGER
ull eqv ui = non-float =
UINTEGER
ull imp ui = non-float =
UINTEGER

relational ops (ull, ui):

ull = ui = integer =
INTEGER
ull > ui = integer =
INTEGER
ull < ui = integer =
INTEGER
ull <> ui = integer =
INTEGER
ull <= ui = integer =
INTEGER
ull >= ui = integer =
INTEGER
ull andalso ui = integer =
INTEGER
ull orelse ui = integer =
INTEGER

math ops (enum1a, ui):

enum1a + ui = max =
UINTEGER
enum1a - ui = max =
UINTEGER
enum1a * ui = max =
UINTEGER
enum1a / ui = float =
DOUBLE
enum1a ^ ui = float =
DOUBLE
enum1a \ ui = non-float =
UINTEGER
enum1a mod ui = non-float =
UINTEGER

bitops (enum1a, ui):

enum1a shl ui = non-float =
UINTEGER
enum1a shr ui = non-float =
UINTEGER
enum1a and ui = non-float =
UINTEGER
enum1a or ui = non-float =
UINTEGER
enum1a xor ui = non-float =
UINTEGER
enum1a eqv ui = non-float =
UINTEGER
enum1a imp ui = non-float =
UINTEGER

relational ops (enum1a, ui):

enum1a = ui = integer =
INTEGER
enum1a > ui = integer =
INTEGER
enum1a < ui = integer =
INTEGER
enum1a <> ui = integer =
INTEGER
enum1a <= ui = integer =
INTEGER
enum1a >= ui = integer =
INTEGER
enum1a andalso ui = integer =
INTEGER
enum1a orelse ui = integer =
INTEGER

math ops (ui, f):

ui + f = max =
SINGLE
ui - f = max =
SINGLE
ui * f = max =
SINGLE
ui / f = float =
DOUBLE
ui ^ f = float =
DOUBLE
ui \ f = non-float =
UINTEGER
ui mod f = non-float =
UINTEGER

bitops (ui, f):

ui shl f = non-float =
UINTEGER
ui shr f = non-float =
UINTEGER
ui and f = non-float =
UINTEGER
ui or f = non-float =
UINTEGER
ui xor f = non-float =
UINTEGER
ui eqv f = non-float =
UINTEGER
ui imp f = non-float =
UINTEGER

relational ops (ui, f):

ui = f = integer =
INTEGER
ui > f = integer =
INTEGER
ui < f = integer =
INTEGER
ui <> f = integer =
INTEGER
ui <= f = integer =
INTEGER
ui >= f = integer =
INTEGER
ui andalso f = integer =
INTEGER
ui orelse f = integer =
INTEGER

math ops (ui, d):

ui + d = max =
DOUBLE
ui - d = max =
DOUBLE
ui * d = max =
DOUBLE
ui / d = float =
DOUBLE
ui ^ d = float =
DOUBLE
ui \ d = non-float =
UINTEGER
ui mod d = non-float =
UINTEGER

bitops (ui, d):

ui shl d = non-float =
UINTEGER
ui shr d = non-float =
UINTEGER
ui and d = non-float =
UINTEGER
ui or d = non-float =
UINTEGER
ui xor d = non-float =
UINTEGER
ui eqv d = non-float =
UINTEGER
ui imp d = non-float =
UINTEGER

relational ops (ui, d):

ui = d = integer =
INTEGER
ui > d = integer =
INTEGER
ui < d = integer =
INTEGER
ui <> d = integer =
INTEGER
ui <= d = integer =
INTEGER
ui >= d = integer =
INTEGER
ui andalso d = integer =
INTEGER
ui orelse d = integer =
INTEGER

math ops (f, ui):

f + ui = max =
SINGLE
f - ui = max =
SINGLE
f * ui = max =
SINGLE
f / ui = float =
DOUBLE
f ^ ui = float =
DOUBLE
f \ ui = non-float =
UINTEGER
f mod ui = non-float =
UINTEGER

bitops (f, ui):

f shl ui = non-float =
UINTEGER
f shr ui = non-float =
UINTEGER
f and ui = non-float =
UINTEGER
f or ui = non-float =
UINTEGER
f xor ui = non-float =
UINTEGER
f eqv ui = non-float =
UINTEGER
f imp ui = non-float =
UINTEGER

relational ops (f, ui):

f = ui = integer =
INTEGER
f > ui = integer =
INTEGER
f < ui = integer =
INTEGER
f <> ui = integer =
INTEGER
f <= ui = integer =
INTEGER
f >= ui = integer =
INTEGER
f andalso ui = integer =
INTEGER
f orelse ui = integer =
INTEGER

math ops (d, ui):

d + ui = max =
DOUBLE
d - ui = max =
DOUBLE
d * ui = max =
DOUBLE
d / ui = float =
DOUBLE
d ^ ui = float =
DOUBLE
d \ ui = non-float =
UINTEGER
d mod ui = non-float =
UINTEGER

bitops (d, ui):

d shl ui = non-float =
UINTEGER
d shr ui = non-float =
UINTEGER
d and ui = non-float =
UINTEGER
d or ui = non-float =
UINTEGER
d xor ui = non-float =
UINTEGER
d eqv ui = non-float =
UINTEGER
d imp ui = non-float =
UINTEGER

relational ops (d, ui):

d = ui = integer =
INTEGER
d > ui = integer =
INTEGER
d < ui = integer =
INTEGER
d <> ui = integer =
INTEGER
d <= ui = integer =
INTEGER
d >= ui = integer =
INTEGER
d andalso ui = integer =
INTEGER
d orelse ui = integer =
INTEGER

----- l -----------------------------------------------------


math ops (l, b):

l + b = max =
INTEGER
l - b = max =
INTEGER
l * b = max =
INTEGER
l / b = float =
DOUBLE
l ^ b = float =
DOUBLE
l \ b = non-float =
INTEGER
l mod b = non-float =
INTEGER

bitops (l, b):

l shl b = non-float =
INTEGER
l shr b = non-float =
INTEGER
l and b = non-float =
INTEGER
l or b = non-float =
INTEGER
l xor b = non-float =
INTEGER
l eqv b = non-float =
INTEGER
l imp b = non-float =
INTEGER

relational ops (l, b):

l = b = integer =
INTEGER
l > b = integer =
INTEGER
l < b = integer =
INTEGER
l <> b = integer =
INTEGER
l <= b = integer =
INTEGER
l >= b = integer =
INTEGER
l andalso b = integer =
INTEGER
l orelse b = integer =
INTEGER

math ops (l, ub):

l + ub = max =
INTEGER
l - ub = max =
INTEGER
l * ub = max =
INTEGER
l / ub = float =
DOUBLE
l ^ ub = float =
DOUBLE
l \ ub = non-float =
INTEGER
l mod ub = non-float =
INTEGER

bitops (l, ub):

l shl ub = non-float =
INTEGER
l shr ub = non-float =
INTEGER
l and ub = non-float =
INTEGER
l or ub = non-float =
INTEGER
l xor ub = non-float =
INTEGER
l eqv ub = non-float =
INTEGER
l imp ub = non-float =
INTEGER

relational ops (l, ub):

l = ub = integer =
INTEGER
l > ub = integer =
INTEGER
l < ub = integer =
INTEGER
l <> ub = integer =
INTEGER
l <= ub = integer =
INTEGER
l >= ub = integer =
INTEGER
l andalso ub = integer =
INTEGER
l orelse ub = integer =
INTEGER

math ops (l, sh):

l + sh = max =
INTEGER
l - sh = max =
INTEGER
l * sh = max =
INTEGER
l / sh = float =
DOUBLE
l ^ sh = float =
DOUBLE
l \ sh = non-float =
INTEGER
l mod sh = non-float =
INTEGER

bitops (l, sh):

l shl sh = non-float =
INTEGER
l shr sh = non-float =
INTEGER
l and sh = non-float =
INTEGER
l or sh = non-float =
INTEGER
l xor sh = non-float =
INTEGER
l eqv sh = non-float =
INTEGER
l imp sh = non-float =
INTEGER

relational ops (l, sh):

l = sh = integer =
INTEGER
l > sh = integer =
INTEGER
l < sh = integer =
INTEGER
l <> sh = integer =
INTEGER
l <= sh = integer =
INTEGER
l >= sh = integer =
INTEGER
l andalso sh = integer =
INTEGER
l orelse sh = integer =
INTEGER

math ops (l, ush):

l + ush = max =
INTEGER
l - ush = max =
INTEGER
l * ush = max =
INTEGER
l / ush = float =
DOUBLE
l ^ ush = float =
DOUBLE
l \ ush = non-float =
INTEGER
l mod ush = non-float =
INTEGER

bitops (l, ush):

l shl ush = non-float =
INTEGER
l shr ush = non-float =
INTEGER
l and ush = non-float =
INTEGER
l or ush = non-float =
INTEGER
l xor ush = non-float =
INTEGER
l eqv ush = non-float =
INTEGER
l imp ush = non-float =
INTEGER

relational ops (l, ush):

l = ush = integer =
INTEGER
l > ush = integer =
INTEGER
l < ush = integer =
INTEGER
l <> ush = integer =
INTEGER
l <= ush = integer =
INTEGER
l >= ush = integer =
INTEGER
l andalso ush = integer =
INTEGER
l orelse ush = integer =
INTEGER

math ops (l, i):

l + i = max =
INTEGER
l - i = max =
INTEGER
l * i = max =
INTEGER
l / i = float =
DOUBLE
l ^ i = float =
DOUBLE
l \ i = non-float =
INTEGER
l mod i = non-float =
INTEGER

bitops (l, i):

l shl i = non-float =
INTEGER
l shr i = non-float =
INTEGER
l and i = non-float =
INTEGER
l or i = non-float =
INTEGER
l xor i = non-float =
INTEGER
l eqv i = non-float =
INTEGER
l imp i = non-float =
INTEGER

relational ops (l, i):

l = i = integer =
INTEGER
l > i = integer =
INTEGER
l < i = integer =
INTEGER
l <> i = integer =
INTEGER
l <= i = integer =
INTEGER
l >= i = integer =
INTEGER
l andalso i = integer =
INTEGER
l orelse i = integer =
INTEGER

math ops (l, ui):

l + ui = max =
UINTEGER
l - ui = max =
UINTEGER
l * ui = max =
UINTEGER
l / ui = float =
DOUBLE
l ^ ui = float =
DOUBLE
l \ ui = non-float =
UINTEGER
l mod ui = non-float =
UINTEGER

bitops (l, ui):

l shl ui = non-float =
UINTEGER
l shr ui = non-float =
UINTEGER
l and ui = non-float =
UINTEGER
l or ui = non-float =
UINTEGER
l xor ui = non-float =
UINTEGER
l eqv ui = non-float =
UINTEGER
l imp ui = non-float =
UINTEGER

relational ops (l, ui):

l = ui = integer =
INTEGER
l > ui = integer =
INTEGER
l < ui = integer =
INTEGER
l <> ui = integer =
INTEGER
l <= ui = integer =
INTEGER
l >= ui = integer =
INTEGER
l andalso ui = integer =
INTEGER
l orelse ui = integer =
INTEGER

math ops (l, l):

l + l = max =
INTEGER
l - l = max =
INTEGER
l * l = max =
INTEGER
l / l = float =
DOUBLE
l ^ l = float =
DOUBLE
l \ l = non-float =
INTEGER
l mod l = non-float =
INTEGER

bitops (l, l):

l shl l = non-float =
INTEGER
l shr l = non-float =
INTEGER
l and l = non-float =
INTEGER
l or l = non-float =
INTEGER
l xor l = non-float =
INTEGER
l eqv l = non-float =
INTEGER
l imp l = non-float =
INTEGER

relational ops (l, l):

l = l = integer =
INTEGER
l > l = integer =
INTEGER
l < l = integer =
INTEGER
l <> l = integer =
INTEGER
l <= l = integer =
INTEGER
l >= l = integer =
INTEGER
l andalso l = integer =
INTEGER
l orelse l = integer =
INTEGER

math ops (l, ul):

l + ul = max =
INTEGER
l - ul = max =
INTEGER
l * ul = max =
INTEGER
l / ul = float =
DOUBLE
l ^ ul = float =
DOUBLE
l \ ul = non-float =
INTEGER
l mod ul = non-float =
INTEGER

bitops (l, ul):

l shl ul = non-float =
INTEGER
l shr ul = non-float =
INTEGER
l and ul = non-float =
INTEGER
l or ul = non-float =
INTEGER
l xor ul = non-float =
INTEGER
l eqv ul = non-float =
INTEGER
l imp ul = non-float =
INTEGER

relational ops (l, ul):

l = ul = integer =
INTEGER
l > ul = integer =
INTEGER
l < ul = integer =
INTEGER
l <> ul = integer =
INTEGER
l <= ul = integer =
INTEGER
l >= ul = integer =
INTEGER
l andalso ul = integer =
INTEGER
l orelse ul = integer =
INTEGER

math ops (l, ll):

l + ll = max =
INTEGER
l - ll = max =
INTEGER
l * ll = max =
INTEGER
l / ll = float =
DOUBLE
l ^ ll = float =
DOUBLE
l \ ll = non-float =
INTEGER
l mod ll = non-float =
INTEGER

bitops (l, ll):

l shl ll = non-float =
INTEGER
l shr ll = non-float =
INTEGER
l and ll = non-float =
INTEGER
l or ll = non-float =
INTEGER
l xor ll = non-float =
INTEGER
l eqv ll = non-float =
INTEGER
l imp ll = non-float =
INTEGER

relational ops (l, ll):

l = ll = integer =
INTEGER
l > ll = integer =
INTEGER
l < ll = integer =
INTEGER
l <> ll = integer =
INTEGER
l <= ll = integer =
INTEGER
l >= ll = integer =
INTEGER
l andalso ll = integer =
INTEGER
l orelse ll = integer =
INTEGER

math ops (l, ull):

l + ull = max =
UINTEGER
l - ull = max =
UINTEGER
l * ull = max =
UINTEGER
l / ull = float =
DOUBLE
l ^ ull = float =
DOUBLE
l \ ull = non-float =
UINTEGER
l mod ull = non-float =
UINTEGER

bitops (l, ull):

l shl ull = non-float =
UINTEGER
l shr ull = non-float =
UINTEGER
l and ull = non-float =
UINTEGER
l or ull = non-float =
UINTEGER
l xor ull = non-float =
UINTEGER
l eqv ull = non-float =
UINTEGER
l imp ull = non-float =
UINTEGER

relational ops (l, ull):

l = ull = integer =
INTEGER
l > ull = integer =
INTEGER
l < ull = integer =
INTEGER
l <> ull = integer =
INTEGER
l <= ull = integer =
INTEGER
l >= ull = integer =
INTEGER
l andalso ull = integer =
INTEGER
l orelse ull = integer =
INTEGER

math ops (l, enum1a):

l + enum1a = max =
INTEGER
l - enum1a = max =
INTEGER
l * enum1a = max =
INTEGER
l / enum1a = float =
DOUBLE
l ^ enum1a = float =
DOUBLE
l \ enum1a = non-float =
INTEGER
l mod enum1a = non-float =
INTEGER

bitops (l, enum1a):

l shl enum1a = non-float =
INTEGER
l shr enum1a = non-float =
INTEGER
l and enum1a = non-float =
INTEGER
l or enum1a = non-float =
INTEGER
l xor enum1a = non-float =
INTEGER
l eqv enum1a = non-float =
INTEGER
l imp enum1a = non-float =
INTEGER

relational ops (l, enum1a):

l = enum1a = integer =
INTEGER
l > enum1a = integer =
INTEGER
l < enum1a = integer =
INTEGER
l <> enum1a = integer =
INTEGER
l <= enum1a = integer =
INTEGER
l >= enum1a = integer =
INTEGER
l andalso enum1a = integer =
INTEGER
l orelse enum1a = integer =
INTEGER

math ops (b, l):

b + l = max =
INTEGER
b - l = max =
INTEGER
b * l = max =
INTEGER
b / l = float =
DOUBLE
b ^ l = float =
DOUBLE
b \ l = non-float =
INTEGER
b mod l = non-float =
INTEGER

bitops (b, l):

b shl l = non-float =
INTEGER
b shr l = non-float =
INTEGER
b and l = non-float =
INTEGER
b or l = non-float =
INTEGER
b xor l = non-float =
INTEGER
b eqv l = non-float =
INTEGER
b imp l = non-float =
INTEGER

relational ops (b, l):

b = l = integer =
INTEGER
b > l = integer =
INTEGER
b < l = integer =
INTEGER
b <> l = integer =
INTEGER
b <= l = integer =
INTEGER
b >= l = integer =
INTEGER
b andalso l = integer =
INTEGER
b orelse l = integer =
INTEGER

math ops (ub, l):

ub + l = max =
INTEGER
ub - l = max =
INTEGER
ub * l = max =
INTEGER
ub / l = float =
DOUBLE
ub ^ l = float =
DOUBLE
ub \ l = non-float =
INTEGER
ub mod l = non-float =
INTEGER

bitops (ub, l):

ub shl l = non-float =
INTEGER
ub shr l = non-float =
INTEGER
ub and l = non-float =
INTEGER
ub or l = non-float =
INTEGER
ub xor l = non-float =
INTEGER
ub eqv l = non-float =
INTEGER
ub imp l = non-float =
INTEGER

relational ops (ub, l):

ub = l = integer =
INTEGER
ub > l = integer =
INTEGER
ub < l = integer =
INTEGER
ub <> l = integer =
INTEGER
ub <= l = integer =
INTEGER
ub >= l = integer =
INTEGER
ub andalso l = integer =
INTEGER
ub orelse l = integer =
INTEGER

math ops (sh, l):

sh + l = max =
INTEGER
sh - l = max =
INTEGER
sh * l = max =
INTEGER
sh / l = float =
DOUBLE
sh ^ l = float =
DOUBLE
sh \ l = non-float =
INTEGER
sh mod l = non-float =
INTEGER

bitops (sh, l):

sh shl l = non-float =
INTEGER
sh shr l = non-float =
INTEGER
sh and l = non-float =
INTEGER
sh or l = non-float =
INTEGER
sh xor l = non-float =
INTEGER
sh eqv l = non-float =
INTEGER
sh imp l = non-float =
INTEGER

relational ops (sh, l):

sh = l = integer =
INTEGER
sh > l = integer =
INTEGER
sh < l = integer =
INTEGER
sh <> l = integer =
INTEGER
sh <= l = integer =
INTEGER
sh >= l = integer =
INTEGER
sh andalso l = integer =
INTEGER
sh orelse l = integer =
INTEGER

math ops (ush, l):

ush + l = max =
INTEGER
ush - l = max =
INTEGER
ush * l = max =
INTEGER
ush / l = float =
DOUBLE
ush ^ l = float =
DOUBLE
ush \ l = non-float =
INTEGER
ush mod l = non-float =
INTEGER

bitops (ush, l):

ush shl l = non-float =
INTEGER
ush shr l = non-float =
INTEGER
ush and l = non-float =
INTEGER
ush or l = non-float =
INTEGER
ush xor l = non-float =
INTEGER
ush eqv l = non-float =
INTEGER
ush imp l = non-float =
INTEGER

relational ops (ush, l):

ush = l = integer =
INTEGER
ush > l = integer =
INTEGER
ush < l = integer =
INTEGER
ush <> l = integer =
INTEGER
ush <= l = integer =
INTEGER
ush >= l = integer =
INTEGER
ush andalso l = integer =
INTEGER
ush orelse l = integer =
INTEGER

math ops (i, l):

i + l = max =
INTEGER
i - l = max =
INTEGER
i * l = max =
INTEGER
i / l = float =
DOUBLE
i ^ l = float =
DOUBLE
i \ l = non-float =
INTEGER
i mod l = non-float =
INTEGER

bitops (i, l):

i shl l = non-float =
INTEGER
i shr l = non-float =
INTEGER
i and l = non-float =
INTEGER
i or l = non-float =
INTEGER
i xor l = non-float =
INTEGER
i eqv l = non-float =
INTEGER
i imp l = non-float =
INTEGER

relational ops (i, l):

i = l = integer =
INTEGER
i > l = integer =
INTEGER
i < l = integer =
INTEGER
i <> l = integer =
INTEGER
i <= l = integer =
INTEGER
i >= l = integer =
INTEGER
i andalso l = integer =
INTEGER
i orelse l = integer =
INTEGER

math ops (ui, l):

ui + l = max =
UINTEGER
ui - l = max =
UINTEGER
ui * l = max =
UINTEGER
ui / l = float =
DOUBLE
ui ^ l = float =
DOUBLE
ui \ l = non-float =
UINTEGER
ui mod l = non-float =
UINTEGER

bitops (ui, l):

ui shl l = non-float =
UINTEGER
ui shr l = non-float =
UINTEGER
ui and l = non-float =
UINTEGER
ui or l = non-float =
UINTEGER
ui xor l = non-float =
UINTEGER
ui eqv l = non-float =
UINTEGER
ui imp l = non-float =
UINTEGER

relational ops (ui, l):

ui = l = integer =
INTEGER
ui > l = integer =
INTEGER
ui < l = integer =
INTEGER
ui <> l = integer =
INTEGER
ui <= l = integer =
INTEGER
ui >= l = integer =
INTEGER
ui andalso l = integer =
INTEGER
ui orelse l = integer =
INTEGER

math ops (l, l):

l + l = max =
INTEGER
l - l = max =
INTEGER
l * l = max =
INTEGER
l / l = float =
DOUBLE
l ^ l = float =
DOUBLE
l \ l = non-float =
INTEGER
l mod l = non-float =
INTEGER

bitops (l, l):

l shl l = non-float =
INTEGER
l shr l = non-float =
INTEGER
l and l = non-float =
INTEGER
l or l = non-float =
INTEGER
l xor l = non-float =
INTEGER
l eqv l = non-float =
INTEGER
l imp l = non-float =
INTEGER

relational ops (l, l):

l = l = integer =
INTEGER
l > l = integer =
INTEGER
l < l = integer =
INTEGER
l <> l = integer =
INTEGER
l <= l = integer =
INTEGER
l >= l = integer =
INTEGER
l andalso l = integer =
INTEGER
l orelse l = integer =
INTEGER

math ops (ul, l):

ul + l = max =
INTEGER
ul - l = max =
INTEGER
ul * l = max =
INTEGER
ul / l = float =
DOUBLE
ul ^ l = float =
DOUBLE
ul \ l = non-float =
INTEGER
ul mod l = non-float =
INTEGER

bitops (ul, l):

ul shl l = non-float =
INTEGER
ul shr l = non-float =
INTEGER
ul and l = non-float =
INTEGER
ul or l = non-float =
INTEGER
ul xor l = non-float =
INTEGER
ul eqv l = non-float =
INTEGER
ul imp l = non-float =
INTEGER

relational ops (ul, l):

ul = l = integer =
INTEGER
ul > l = integer =
INTEGER
ul < l = integer =
INTEGER
ul <> l = integer =
INTEGER
ul <= l = integer =
INTEGER
ul >= l = integer =
INTEGER
ul andalso l = integer =
INTEGER
ul orelse l = integer =
INTEGER

math ops (ll, l):

ll + l = max =
INTEGER
ll - l = max =
INTEGER
ll * l = max =
INTEGER
ll / l = float =
DOUBLE
ll ^ l = float =
DOUBLE
ll \ l = non-float =
INTEGER
ll mod l = non-float =
INTEGER

bitops (ll, l):

ll shl l = non-float =
INTEGER
ll shr l = non-float =
INTEGER
ll and l = non-float =
INTEGER
ll or l = non-float =
INTEGER
ll xor l = non-float =
INTEGER
ll eqv l = non-float =
INTEGER
ll imp l = non-float =
INTEGER

relational ops (ll, l):

ll = l = integer =
INTEGER
ll > l = integer =
INTEGER
ll < l = integer =
INTEGER
ll <> l = integer =
INTEGER
ll <= l = integer =
INTEGER
ll >= l = integer =
INTEGER
ll andalso l = integer =
INTEGER
ll orelse l = integer =
INTEGER

math ops (ull, l):

ull + l = max =
UINTEGER
ull - l = max =
UINTEGER
ull * l = max =
UINTEGER
ull / l = float =
DOUBLE
ull ^ l = float =
DOUBLE
ull \ l = non-float =
UINTEGER
ull mod l = non-float =
UINTEGER

bitops (ull, l):

ull shl l = non-float =
UINTEGER
ull shr l = non-float =
UINTEGER
ull and l = non-float =
UINTEGER
ull or l = non-float =
UINTEGER
ull xor l = non-float =
UINTEGER
ull eqv l = non-float =
UINTEGER
ull imp l = non-float =
UINTEGER

relational ops (ull, l):

ull = l = integer =
INTEGER
ull > l = integer =
INTEGER
ull < l = integer =
INTEGER
ull <> l = integer =
INTEGER
ull <= l = integer =
INTEGER
ull >= l = integer =
INTEGER
ull andalso l = integer =
INTEGER
ull orelse l = integer =
INTEGER

math ops (enum1a, l):

enum1a + l = max =
INTEGER
enum1a - l = max =
INTEGER
enum1a * l = max =
INTEGER
enum1a / l = float =
DOUBLE
enum1a ^ l = float =
DOUBLE
enum1a \ l = non-float =
INTEGER
enum1a mod l = non-float =
INTEGER

bitops (enum1a, l):

enum1a shl l = non-float =
INTEGER
enum1a shr l = non-float =
INTEGER
enum1a and l = non-float =
INTEGER
enum1a or l = non-float =
INTEGER
enum1a xor l = non-float =
INTEGER
enum1a eqv l = non-float =
INTEGER
enum1a imp l = non-float =
INTEGER

relational ops (enum1a, l):

enum1a = l = integer =
INTEGER
enum1a > l = integer =
INTEGER
enum1a < l = integer =
INTEGER
enum1a <> l = integer =
INTEGER
enum1a <= l = integer =
INTEGER
enum1a >= l = integer =
INTEGER
enum1a andalso l = integer =
INTEGER
enum1a orelse l = integer =
INTEGER

math ops (l, f):

l + f = max =
SINGLE
l - f = max =
SINGLE
l * f = max =
SINGLE
l / f = float =
DOUBLE
l ^ f = float =
DOUBLE
l \ f = non-float =
INTEGER
l mod f = non-float =
INTEGER

bitops (l, f):

l shl f = non-float =
INTEGER
l shr f = non-float =
INTEGER
l and f = non-float =
INTEGER
l or f = non-float =
INTEGER
l xor f = non-float =
INTEGER
l eqv f = non-float =
INTEGER
l imp f = non-float =
INTEGER

relational ops (l, f):

l = f = integer =
INTEGER
l > f = integer =
INTEGER
l < f = integer =
INTEGER
l <> f = integer =
INTEGER
l <= f = integer =
INTEGER
l >= f = integer =
INTEGER
l andalso f = integer =
INTEGER
l orelse f = integer =
INTEGER

math ops (l, d):

l + d = max =
DOUBLE
l - d = max =
DOUBLE
l * d = max =
DOUBLE
l / d = float =
DOUBLE
l ^ d = float =
DOUBLE
l \ d = non-float =
INTEGER
l mod d = non-float =
INTEGER

bitops (l, d):

l shl d = non-float =
INTEGER
l shr d = non-float =
INTEGER
l and d = non-float =
INTEGER
l or d = non-float =
INTEGER
l xor d = non-float =
INTEGER
l eqv d = non-float =
INTEGER
l imp d = non-float =
INTEGER

relational ops (l, d):

l = d = integer =
INTEGER
l > d = integer =
INTEGER
l < d = integer =
INTEGER
l <> d = integer =
INTEGER
l <= d = integer =
INTEGER
l >= d = integer =
INTEGER
l andalso d = integer =
INTEGER
l orelse d = integer =
INTEGER

math ops (f, l):

f + l = max =
SINGLE
f - l = max =
SINGLE
f * l = max =
SINGLE
f / l = float =
DOUBLE
f ^ l = float =
DOUBLE
f \ l = non-float =
INTEGER
f mod l = non-float =
INTEGER

bitops (f, l):

f shl l = non-float =
INTEGER
f shr l = non-float =
INTEGER
f and l = non-float =
INTEGER
f or l = non-float =
INTEGER
f xor l = non-float =
INTEGER
f eqv l = non-float =
INTEGER
f imp l = non-float =
INTEGER

relational ops (f, l):

f = l = integer =
INTEGER
f > l = integer =
INTEGER
f < l = integer =
INTEGER
f <> l = integer =
INTEGER
f <= l = integer =
INTEGER
f >= l = integer =
INTEGER
f andalso l = integer =
INTEGER
f orelse l = integer =
INTEGER

math ops (d, l):

d + l = max =
DOUBLE
d - l = max =
DOUBLE
d * l = max =
DOUBLE
d / l = float =
DOUBLE
d ^ l = float =
DOUBLE
d \ l = non-float =
INTEGER
d mod l = non-float =
INTEGER

bitops (d, l):

d shl l = non-float =
INTEGER
d shr l = non-float =
INTEGER
d and l = non-float =
INTEGER
d or l = non-float =
INTEGER
d xor l = non-float =
INTEGER
d eqv l = non-float =
INTEGER
d imp l = non-float =
INTEGER

relational ops (d, l):

d = l = integer =
INTEGER
d > l = integer =
INTEGER
d < l = integer =
INTEGER
d <> l = integer =
INTEGER
d <= l = integer =
INTEGER
d >= l = integer =
INTEGER
d andalso l = integer =
INTEGER
d orelse l = integer =
INTEGER

----- ul -----------------------------------------------------


math ops (ul, b):

ul + b = max =
INTEGER
ul - b = max =
INTEGER
ul * b = max =
INTEGER
ul / b = float =
DOUBLE
ul ^ b = float =
DOUBLE
ul \ b = non-float =
INTEGER
ul mod b = non-float =
INTEGER

bitops (ul, b):

ul shl b = non-float =
INTEGER
ul shr b = non-float =
INTEGER
ul and b = non-float =
INTEGER
ul or b = non-float =
INTEGER
ul xor b = non-float =
INTEGER
ul eqv b = non-float =
INTEGER
ul imp b = non-float =
INTEGER

relational ops (ul, b):

ul = b = integer =
INTEGER
ul > b = integer =
INTEGER
ul < b = integer =
INTEGER
ul <> b = integer =
INTEGER
ul <= b = integer =
INTEGER
ul >= b = integer =
INTEGER
ul andalso b = integer =
INTEGER
ul orelse b = integer =
INTEGER

math ops (ul, ub):

ul + ub = max =
INTEGER
ul - ub = max =
INTEGER
ul * ub = max =
INTEGER
ul / ub = float =
DOUBLE
ul ^ ub = float =
DOUBLE
ul \ ub = non-float =
INTEGER
ul mod ub = non-float =
INTEGER

bitops (ul, ub):

ul shl ub = non-float =
INTEGER
ul shr ub = non-float =
INTEGER
ul and ub = non-float =
INTEGER
ul or ub = non-float =
INTEGER
ul xor ub = non-float =
INTEGER
ul eqv ub = non-float =
INTEGER
ul imp ub = non-float =
INTEGER

relational ops (ul, ub):

ul = ub = integer =
INTEGER
ul > ub = integer =
INTEGER
ul < ub = integer =
INTEGER
ul <> ub = integer =
INTEGER
ul <= ub = integer =
INTEGER
ul >= ub = integer =
INTEGER
ul andalso ub = integer =
INTEGER
ul orelse ub = integer =
INTEGER

math ops (ul, sh):

ul + sh = max =
INTEGER
ul - sh = max =
INTEGER
ul * sh = max =
INTEGER
ul / sh = float =
DOUBLE
ul ^ sh = float =
DOUBLE
ul \ sh = non-float =
INTEGER
ul mod sh = non-float =
INTEGER

bitops (ul, sh):

ul shl sh = non-float =
INTEGER
ul shr sh = non-float =
INTEGER
ul and sh = non-float =
INTEGER
ul or sh = non-float =
INTEGER
ul xor sh = non-float =
INTEGER
ul eqv sh = non-float =
INTEGER
ul imp sh = non-float =
INTEGER

relational ops (ul, sh):

ul = sh = integer =
INTEGER
ul > sh = integer =
INTEGER
ul < sh = integer =
INTEGER
ul <> sh = integer =
INTEGER
ul <= sh = integer =
INTEGER
ul >= sh = integer =
INTEGER
ul andalso sh = integer =
INTEGER
ul orelse sh = integer =
INTEGER

math ops (ul, ush):

ul + ush = max =
INTEGER
ul - ush = max =
INTEGER
ul * ush = max =
INTEGER
ul / ush = float =
DOUBLE
ul ^ ush = float =
DOUBLE
ul \ ush = non-float =
INTEGER
ul mod ush = non-float =
INTEGER

bitops (ul, ush):

ul shl ush = non-float =
INTEGER
ul shr ush = non-float =
INTEGER
ul and ush = non-float =
INTEGER
ul or ush = non-float =
INTEGER
ul xor ush = non-float =
INTEGER
ul eqv ush = non-float =
INTEGER
ul imp ush = non-float =
INTEGER

relational ops (ul, ush):

ul = ush = integer =
INTEGER
ul > ush = integer =
INTEGER
ul < ush = integer =
INTEGER
ul <> ush = integer =
INTEGER
ul <= ush = integer =
INTEGER
ul >= ush = integer =
INTEGER
ul andalso ush = integer =
INTEGER
ul orelse ush = integer =
INTEGER

math ops (ul, i):

ul + i = max =
INTEGER
ul - i = max =
INTEGER
ul * i = max =
INTEGER
ul / i = float =
DOUBLE
ul ^ i = float =
DOUBLE
ul \ i = non-float =
INTEGER
ul mod i = non-float =
INTEGER

bitops (ul, i):

ul shl i = non-float =
INTEGER
ul shr i = non-float =
INTEGER
ul and i = non-float =
INTEGER
ul or i = non-float =
INTEGER
ul xor i = non-float =
INTEGER
ul eqv i = non-float =
INTEGER
ul imp i = non-float =
INTEGER

relational ops (ul, i):

ul = i = integer =
INTEGER
ul > i = integer =
INTEGER
ul < i = integer =
INTEGER
ul <> i = integer =
INTEGER
ul <= i = integer =
INTEGER
ul >= i = integer =
INTEGER
ul andalso i = integer =
INTEGER
ul orelse i = integer =
INTEGER

math ops (ul, ui):

ul + ui = max =
UINTEGER
ul - ui = max =
UINTEGER
ul * ui = max =
UINTEGER
ul / ui = float =
DOUBLE
ul ^ ui = float =
DOUBLE
ul \ ui = non-float =
UINTEGER
ul mod ui = non-float =
UINTEGER

bitops (ul, ui):

ul shl ui = non-float =
UINTEGER
ul shr ui = non-float =
UINTEGER
ul and ui = non-float =
UINTEGER
ul or ui = non-float =
UINTEGER
ul xor ui = non-float =
UINTEGER
ul eqv ui = non-float =
UINTEGER
ul imp ui = non-float =
UINTEGER

relational ops (ul, ui):

ul = ui = integer =
INTEGER
ul > ui = integer =
INTEGER
ul < ui = integer =
INTEGER
ul <> ui = integer =
INTEGER
ul <= ui = integer =
INTEGER
ul >= ui = integer =
INTEGER
ul andalso ui = integer =
INTEGER
ul orelse ui = integer =
INTEGER

math ops (ul, l):

ul + l = max =
INTEGER
ul - l = max =
INTEGER
ul * l = max =
INTEGER
ul / l = float =
DOUBLE
ul ^ l = float =
DOUBLE
ul \ l = non-float =
INTEGER
ul mod l = non-float =
INTEGER

bitops (ul, l):

ul shl l = non-float =
INTEGER
ul shr l = non-float =
INTEGER
ul and l = non-float =
INTEGER
ul or l = non-float =
INTEGER
ul xor l = non-float =
INTEGER
ul eqv l = non-float =
INTEGER
ul imp l = non-float =
INTEGER

relational ops (ul, l):

ul = l = integer =
INTEGER
ul > l = integer =
INTEGER
ul < l = integer =
INTEGER
ul <> l = integer =
INTEGER
ul <= l = integer =
INTEGER
ul >= l = integer =
INTEGER
ul andalso l = integer =
INTEGER
ul orelse l = integer =
INTEGER

math ops (ul, ul):

ul + ul = max =
INTEGER
ul - ul = max =
INTEGER
ul * ul = max =
INTEGER
ul / ul = float =
DOUBLE
ul ^ ul = float =
DOUBLE
ul \ ul = non-float =
INTEGER
ul mod ul = non-float =
INTEGER

bitops (ul, ul):

ul shl ul = non-float =
INTEGER
ul shr ul = non-float =
INTEGER
ul and ul = non-float =
INTEGER
ul or ul = non-float =
INTEGER
ul xor ul = non-float =
INTEGER
ul eqv ul = non-float =
INTEGER
ul imp ul = non-float =
INTEGER

relational ops (ul, ul):

ul = ul = integer =
INTEGER
ul > ul = integer =
INTEGER
ul < ul = integer =
INTEGER
ul <> ul = integer =
INTEGER
ul <= ul = integer =
INTEGER
ul >= ul = integer =
INTEGER
ul andalso ul = integer =
INTEGER
ul orelse ul = integer =
INTEGER

math ops (ul, ll):

ul + ll = max =
INTEGER
ul - ll = max =
INTEGER
ul * ll = max =
INTEGER
ul / ll = float =
DOUBLE
ul ^ ll = float =
DOUBLE
ul \ ll = non-float =
INTEGER
ul mod ll = non-float =
INTEGER

bitops (ul, ll):

ul shl ll = non-float =
INTEGER
ul shr ll = non-float =
INTEGER
ul and ll = non-float =
INTEGER
ul or ll = non-float =
INTEGER
ul xor ll = non-float =
INTEGER
ul eqv ll = non-float =
INTEGER
ul imp ll = non-float =
INTEGER

relational ops (ul, ll):

ul = ll = integer =
INTEGER
ul > ll = integer =
INTEGER
ul < ll = integer =
INTEGER
ul <> ll = integer =
INTEGER
ul <= ll = integer =
INTEGER
ul >= ll = integer =
INTEGER
ul andalso ll = integer =
INTEGER
ul orelse ll = integer =
INTEGER

math ops (ul, ull):

ul + ull = max =
UINTEGER
ul - ull = max =
UINTEGER
ul * ull = max =
UINTEGER
ul / ull = float =
DOUBLE
ul ^ ull = float =
DOUBLE
ul \ ull = non-float =
UINTEGER
ul mod ull = non-float =
UINTEGER

bitops (ul, ull):

ul shl ull = non-float =
UINTEGER
ul shr ull = non-float =
UINTEGER
ul and ull = non-float =
UINTEGER
ul or ull = non-float =
UINTEGER
ul xor ull = non-float =
UINTEGER
ul eqv ull = non-float =
UINTEGER
ul imp ull = non-float =
UINTEGER

relational ops (ul, ull):

ul = ull = integer =
INTEGER
ul > ull = integer =
INTEGER
ul < ull = integer =
INTEGER
ul <> ull = integer =
INTEGER
ul <= ull = integer =
INTEGER
ul >= ull = integer =
INTEGER
ul andalso ull = integer =
INTEGER
ul orelse ull = integer =
INTEGER

math ops (ul, enum1a):

ul + enum1a = max =
INTEGER
ul - enum1a = max =
INTEGER
ul * enum1a = max =
INTEGER
ul / enum1a = float =
DOUBLE
ul ^ enum1a = float =
DOUBLE
ul \ enum1a = non-float =
INTEGER
ul mod enum1a = non-float =
INTEGER

bitops (ul, enum1a):

ul shl enum1a = non-float =
INTEGER
ul shr enum1a = non-float =
INTEGER
ul and enum1a = non-float =
INTEGER
ul or enum1a = non-float =
INTEGER
ul xor enum1a = non-float =
INTEGER
ul eqv enum1a = non-float =
INTEGER
ul imp enum1a = non-float =
INTEGER

relational ops (ul, enum1a):

ul = enum1a = integer =
INTEGER
ul > enum1a = integer =
INTEGER
ul < enum1a = integer =
INTEGER
ul <> enum1a = integer =
INTEGER
ul <= enum1a = integer =
INTEGER
ul >= enum1a = integer =
INTEGER
ul andalso enum1a = integer =
INTEGER
ul orelse enum1a = integer =
INTEGER

math ops (b, ul):

b + ul = max =
INTEGER
b - ul = max =
INTEGER
b * ul = max =
INTEGER
b / ul = float =
DOUBLE
b ^ ul = float =
DOUBLE
b \ ul = non-float =
INTEGER
b mod ul = non-float =
INTEGER

bitops (b, ul):

b shl ul = non-float =
INTEGER
b shr ul = non-float =
INTEGER
b and ul = non-float =
INTEGER
b or ul = non-float =
INTEGER
b xor ul = non-float =
INTEGER
b eqv ul = non-float =
INTEGER
b imp ul = non-float =
INTEGER

relational ops (b, ul):

b = ul = integer =
INTEGER
b > ul = integer =
INTEGER
b < ul = integer =
INTEGER
b <> ul = integer =
INTEGER
b <= ul = integer =
INTEGER
b >= ul = integer =
INTEGER
b andalso ul = integer =
INTEGER
b orelse ul = integer =
INTEGER

math ops (ub, ul):

ub + ul = max =
INTEGER
ub - ul = max =
INTEGER
ub * ul = max =
INTEGER
ub / ul = float =
DOUBLE
ub ^ ul = float =
DOUBLE
ub \ ul = non-float =
INTEGER
ub mod ul = non-float =
INTEGER

bitops (ub, ul):

ub shl ul = non-float =
INTEGER
ub shr ul = non-float =
INTEGER
ub and ul = non-float =
INTEGER
ub or ul = non-float =
INTEGER
ub xor ul = non-float =
INTEGER
ub eqv ul = non-float =
INTEGER
ub imp ul = non-float =
INTEGER

relational ops (ub, ul):

ub = ul = integer =
INTEGER
ub > ul = integer =
INTEGER
ub < ul = integer =
INTEGER
ub <> ul = integer =
INTEGER
ub <= ul = integer =
INTEGER
ub >= ul = integer =
INTEGER
ub andalso ul = integer =
INTEGER
ub orelse ul = integer =
INTEGER

math ops (sh, ul):

sh + ul = max =
INTEGER
sh - ul = max =
INTEGER
sh * ul = max =
INTEGER
sh / ul = float =
DOUBLE
sh ^ ul = float =
DOUBLE
sh \ ul = non-float =
INTEGER
sh mod ul = non-float =
INTEGER

bitops (sh, ul):

sh shl ul = non-float =
INTEGER
sh shr ul = non-float =
INTEGER
sh and ul = non-float =
INTEGER
sh or ul = non-float =
INTEGER
sh xor ul = non-float =
INTEGER
sh eqv ul = non-float =
INTEGER
sh imp ul = non-float =
INTEGER

relational ops (sh, ul):

sh = ul = integer =
INTEGER
sh > ul = integer =
INTEGER
sh < ul = integer =
INTEGER
sh <> ul = integer =
INTEGER
sh <= ul = integer =
INTEGER
sh >= ul = integer =
INTEGER
sh andalso ul = integer =
INTEGER
sh orelse ul = integer =
INTEGER

math ops (ush, ul):

ush + ul = max =
INTEGER
ush - ul = max =
INTEGER
ush * ul = max =
INTEGER
ush / ul = float =
DOUBLE
ush ^ ul = float =
DOUBLE
ush \ ul = non-float =
INTEGER
ush mod ul = non-float =
INTEGER

bitops (ush, ul):

ush shl ul = non-float =
INTEGER
ush shr ul = non-float =
INTEGER
ush and ul = non-float =
INTEGER
ush or ul = non-float =
INTEGER
ush xor ul = non-float =
INTEGER
ush eqv ul = non-float =
INTEGER
ush imp ul = non-float =
INTEGER

relational ops (ush, ul):

ush = ul = integer =
INTEGER
ush > ul = integer =
INTEGER
ush < ul = integer =
INTEGER
ush <> ul = integer =
INTEGER
ush <= ul = integer =
INTEGER
ush >= ul = integer =
INTEGER
ush andalso ul = integer =
INTEGER
ush orelse ul = integer =
INTEGER

math ops (i, ul):

i + ul = max =
INTEGER
i - ul = max =
INTEGER
i * ul = max =
INTEGER
i / ul = float =
DOUBLE
i ^ ul = float =
DOUBLE
i \ ul = non-float =
INTEGER
i mod ul = non-float =
INTEGER

bitops (i, ul):

i shl ul = non-float =
INTEGER
i shr ul = non-float =
INTEGER
i and ul = non-float =
INTEGER
i or ul = non-float =
INTEGER
i xor ul = non-float =
INTEGER
i eqv ul = non-float =
INTEGER
i imp ul = non-float =
INTEGER

relational ops (i, ul):

i = ul = integer =
INTEGER
i > ul = integer =
INTEGER
i < ul = integer =
INTEGER
i <> ul = integer =
INTEGER
i <= ul = integer =
INTEGER
i >= ul = integer =
INTEGER
i andalso ul = integer =
INTEGER
i orelse ul = integer =
INTEGER

math ops (ui, ul):

ui + ul = max =
UINTEGER
ui - ul = max =
UINTEGER
ui * ul = max =
UINTEGER
ui / ul = float =
DOUBLE
ui ^ ul = float =
DOUBLE
ui \ ul = non-float =
UINTEGER
ui mod ul = non-float =
UINTEGER

bitops (ui, ul):

ui shl ul = non-float =
UINTEGER
ui shr ul = non-float =
UINTEGER
ui and ul = non-float =
UINTEGER
ui or ul = non-float =
UINTEGER
ui xor ul = non-float =
UINTEGER
ui eqv ul = non-float =
UINTEGER
ui imp ul = non-float =
UINTEGER

relational ops (ui, ul):

ui = ul = integer =
INTEGER
ui > ul = integer =
INTEGER
ui < ul = integer =
INTEGER
ui <> ul = integer =
INTEGER
ui <= ul = integer =
INTEGER
ui >= ul = integer =
INTEGER
ui andalso ul = integer =
INTEGER
ui orelse ul = integer =
INTEGER

math ops (l, ul):

l + ul = max =
INTEGER
l - ul = max =
INTEGER
l * ul = max =
INTEGER
l / ul = float =
DOUBLE
l ^ ul = float =
DOUBLE
l \ ul = non-float =
INTEGER
l mod ul = non-float =
INTEGER

bitops (l, ul):

l shl ul = non-float =
INTEGER
l shr ul = non-float =
INTEGER
l and ul = non-float =
INTEGER
l or ul = non-float =
INTEGER
l xor ul = non-float =
INTEGER
l eqv ul = non-float =
INTEGER
l imp ul = non-float =
INTEGER

relational ops (l, ul):

l = ul = integer =
INTEGER
l > ul = integer =
INTEGER
l < ul = integer =
INTEGER
l <> ul = integer =
INTEGER
l <= ul = integer =
INTEGER
l >= ul = integer =
INTEGER
l andalso ul = integer =
INTEGER
l orelse ul = integer =
INTEGER

math ops (ul, ul):

ul + ul = max =
INTEGER
ul - ul = max =
INTEGER
ul * ul = max =
INTEGER
ul / ul = float =
DOUBLE
ul ^ ul = float =
DOUBLE
ul \ ul = non-float =
INTEGER
ul mod ul = non-float =
INTEGER

bitops (ul, ul):

ul shl ul = non-float =
INTEGER
ul shr ul = non-float =
INTEGER
ul and ul = non-float =
INTEGER
ul or ul = non-float =
INTEGER
ul xor ul = non-float =
INTEGER
ul eqv ul = non-float =
INTEGER
ul imp ul = non-float =
INTEGER

relational ops (ul, ul):

ul = ul = integer =
INTEGER
ul > ul = integer =
INTEGER
ul < ul = integer =
INTEGER
ul <> ul = integer =
INTEGER
ul <= ul = integer =
INTEGER
ul >= ul = integer =
INTEGER
ul andalso ul = integer =
INTEGER
ul orelse ul = integer =
INTEGER

math ops (ll, ul):

ll + ul = max =
INTEGER
ll - ul = max =
INTEGER
ll * ul = max =
INTEGER
ll / ul = float =
DOUBLE
ll ^ ul = float =
DOUBLE
ll \ ul = non-float =
INTEGER
ll mod ul = non-float =
INTEGER

bitops (ll, ul):

ll shl ul = non-float =
INTEGER
ll shr ul = non-float =
INTEGER
ll and ul = non-float =
INTEGER
ll or ul = non-float =
INTEGER
ll xor ul = non-float =
INTEGER
ll eqv ul = non-float =
INTEGER
ll imp ul = non-float =
INTEGER

relational ops (ll, ul):

ll = ul = integer =
INTEGER
ll > ul = integer =
INTEGER
ll < ul = integer =
INTEGER
ll <> ul = integer =
INTEGER
ll <= ul = integer =
INTEGER
ll >= ul = integer =
INTEGER
ll andalso ul = integer =
INTEGER
ll orelse ul = integer =
INTEGER

math ops (ull, ul):

ull + ul = max =
UINTEGER
ull - ul = max =
UINTEGER
ull * ul = max =
UINTEGER
ull / ul = float =
DOUBLE
ull ^ ul = float =
DOUBLE
ull \ ul = non-float =
UINTEGER
ull mod ul = non-float =
UINTEGER

bitops (ull, ul):

ull shl ul = non-float =
UINTEGER
ull shr ul = non-float =
UINTEGER
ull and ul = non-float =
UINTEGER
ull or ul = non-float =
UINTEGER
ull xor ul = non-float =
UINTEGER
ull eqv ul = non-float =
UINTEGER
ull imp ul = non-float =
UINTEGER

relational ops (ull, ul):

ull = ul = integer =
INTEGER
ull > ul = integer =
INTEGER
ull < ul = integer =
INTEGER
ull <> ul = integer =
INTEGER
ull <= ul = integer =
INTEGER
ull >= ul = integer =
INTEGER
ull andalso ul = integer =
INTEGER
ull orelse ul = integer =
INTEGER

math ops (enum1a, ul):

enum1a + ul = max =
INTEGER
enum1a - ul = max =
INTEGER
enum1a * ul = max =
INTEGER
enum1a / ul = float =
DOUBLE
enum1a ^ ul = float =
DOUBLE
enum1a \ ul = non-float =
INTEGER
enum1a mod ul = non-float =
INTEGER

bitops (enum1a, ul):

enum1a shl ul = non-float =
INTEGER
enum1a shr ul = non-float =
INTEGER
enum1a and ul = non-float =
INTEGER
enum1a or ul = non-float =
INTEGER
enum1a xor ul = non-float =
INTEGER
enum1a eqv ul = non-float =
INTEGER
enum1a imp ul = non-float =
INTEGER

relational ops (enum1a, ul):

enum1a = ul = integer =
INTEGER
enum1a > ul = integer =
INTEGER
enum1a < ul = integer =
INTEGER
enum1a <> ul = integer =
INTEGER
enum1a <= ul = integer =
INTEGER
enum1a >= ul = integer =
INTEGER
enum1a andalso ul = integer =
INTEGER
enum1a orelse ul = integer =
INTEGER

math ops (ul, f):

ul + f = max =
SINGLE
ul - f = max =
SINGLE
ul * f = max =
SINGLE
ul / f = float =
DOUBLE
ul ^ f = float =
DOUBLE
ul \ f = non-float =
INTEGER
ul mod f = non-float =
INTEGER

bitops (ul, f):

ul shl f = non-float =
INTEGER
ul shr f = non-float =
INTEGER
ul and f = non-float =
INTEGER
ul or f = non-float =
INTEGER
ul xor f = non-float =
INTEGER
ul eqv f = non-float =
INTEGER
ul imp f = non-float =
INTEGER

relational ops (ul, f):

ul = f = integer =
INTEGER
ul > f = integer =
INTEGER
ul < f = integer =
INTEGER
ul <> f = integer =
INTEGER
ul <= f = integer =
INTEGER
ul >= f = integer =
INTEGER
ul andalso f = integer =
INTEGER
ul orelse f = integer =
INTEGER

math ops (ul, d):

ul + d = max =
DOUBLE
ul - d = max =
DOUBLE
ul * d = max =
DOUBLE
ul / d = float =
DOUBLE
ul ^ d = float =
DOUBLE
ul \ d = non-float =
INTEGER
ul mod d = non-float =
INTEGER

bitops (ul, d):

ul shl d = non-float =
INTEGER
ul shr d = non-float =
INTEGER
ul and d = non-float =
INTEGER
ul or d = non-float =
INTEGER
ul xor d = non-float =
INTEGER
ul eqv d = non-float =
INTEGER
ul imp d = non-float =
INTEGER

relational ops (ul, d):

ul = d = integer =
INTEGER
ul > d = integer =
INTEGER
ul < d = integer =
INTEGER
ul <> d = integer =
INTEGER
ul <= d = integer =
INTEGER
ul >= d = integer =
INTEGER
ul andalso d = integer =
INTEGER
ul orelse d = integer =
INTEGER

math ops (f, ul):

f + ul = max =
SINGLE
f - ul = max =
SINGLE
f * ul = max =
SINGLE
f / ul = float =
DOUBLE
f ^ ul = float =
DOUBLE
f \ ul = non-float =
INTEGER
f mod ul = non-float =
INTEGER

bitops (f, ul):

f shl ul = non-float =
INTEGER
f shr ul = non-float =
INTEGER
f and ul = non-float =
INTEGER
f or ul = non-float =
INTEGER
f xor ul = non-float =
INTEGER
f eqv ul = non-float =
INTEGER
f imp ul = non-float =
INTEGER

relational ops (f, ul):

f = ul = integer =
INTEGER
f > ul = integer =
INTEGER
f < ul = integer =
INTEGER
f <> ul = integer =
INTEGER
f <= ul = integer =
INTEGER
f >= ul = integer =
INTEGER
f andalso ul = integer =
INTEGER
f orelse ul = integer =
INTEGER

math ops (d, ul):

d + ul = max =
DOUBLE
d - ul = max =
DOUBLE
d * ul = max =
DOUBLE
d / ul = float =
DOUBLE
d ^ ul = float =
DOUBLE
d \ ul = non-float =
INTEGER
d mod ul = non-float =
INTEGER

bitops (d, ul):

d shl ul = non-float =
INTEGER
d shr ul = non-float =
INTEGER
d and ul = non-float =
INTEGER
d or ul = non-float =
INTEGER
d xor ul = non-float =
INTEGER
d eqv ul = non-float =
INTEGER
d imp ul = non-float =
INTEGER

relational ops (d, ul):

d = ul = integer =
INTEGER
d > ul = integer =
INTEGER
d < ul = integer =
INTEGER
d <> ul = integer =
INTEGER
d <= ul = integer =
INTEGER
d >= ul = integer =
INTEGER
d andalso ul = integer =
INTEGER
d orelse ul = integer =
INTEGER

----- ll -----------------------------------------------------


math ops (ll, b):

ll + b = max =
INTEGER
ll - b = max =
INTEGER
ll * b = max =
INTEGER
ll / b = float =
DOUBLE
ll ^ b = float =
DOUBLE
ll \ b = non-float =
INTEGER
ll mod b = non-float =
INTEGER

bitops (ll, b):

ll shl b = non-float =
INTEGER
ll shr b = non-float =
INTEGER
ll and b = non-float =
INTEGER
ll or b = non-float =
INTEGER
ll xor b = non-float =
INTEGER
ll eqv b = non-float =
INTEGER
ll imp b = non-float =
INTEGER

relational ops (ll, b):

ll = b = integer =
INTEGER
ll > b = integer =
INTEGER
ll < b = integer =
INTEGER
ll <> b = integer =
INTEGER
ll <= b = integer =
INTEGER
ll >= b = integer =
INTEGER
ll andalso b = integer =
INTEGER
ll orelse b = integer =
INTEGER

math ops (ll, ub):

ll + ub = max =
INTEGER
ll - ub = max =
INTEGER
ll * ub = max =
INTEGER
ll / ub = float =
DOUBLE
ll ^ ub = float =
DOUBLE
ll \ ub = non-float =
INTEGER
ll mod ub = non-float =
INTEGER

bitops (ll, ub):

ll shl ub = non-float =
INTEGER
ll shr ub = non-float =
INTEGER
ll and ub = non-float =
INTEGER
ll or ub = non-float =
INTEGER
ll xor ub = non-float =
INTEGER
ll eqv ub = non-float =
INTEGER
ll imp ub = non-float =
INTEGER

relational ops (ll, ub):

ll = ub = integer =
INTEGER
ll > ub = integer =
INTEGER
ll < ub = integer =
INTEGER
ll <> ub = integer =
INTEGER
ll <= ub = integer =
INTEGER
ll >= ub = integer =
INTEGER
ll andalso ub = integer =
INTEGER
ll orelse ub = integer =
INTEGER

math ops (ll, sh):

ll + sh = max =
INTEGER
ll - sh = max =
INTEGER
ll * sh = max =
INTEGER
ll / sh = float =
DOUBLE
ll ^ sh = float =
DOUBLE
ll \ sh = non-float =
INTEGER
ll mod sh = non-float =
INTEGER

bitops (ll, sh):

ll shl sh = non-float =
INTEGER
ll shr sh = non-float =
INTEGER
ll and sh = non-float =
INTEGER
ll or sh = non-float =
INTEGER
ll xor sh = non-float =
INTEGER
ll eqv sh = non-float =
INTEGER
ll imp sh = non-float =
INTEGER

relational ops (ll, sh):

ll = sh = integer =
INTEGER
ll > sh = integer =
INTEGER
ll < sh = integer =
INTEGER
ll <> sh = integer =
INTEGER
ll <= sh = integer =
INTEGER
ll >= sh = integer =
INTEGER
ll andalso sh = integer =
INTEGER
ll orelse sh = integer =
INTEGER

math ops (ll, ush):

ll + ush = max =
INTEGER
ll - ush = max =
INTEGER
ll * ush = max =
INTEGER
ll / ush = float =
DOUBLE
ll ^ ush = float =
DOUBLE
ll \ ush = non-float =
INTEGER
ll mod ush = non-float =
INTEGER

bitops (ll, ush):

ll shl ush = non-float =
INTEGER
ll shr ush = non-float =
INTEGER
ll and ush = non-float =
INTEGER
ll or ush = non-float =
INTEGER
ll xor ush = non-float =
INTEGER
ll eqv ush = non-float =
INTEGER
ll imp ush = non-float =
INTEGER

relational ops (ll, ush):

ll = ush = integer =
INTEGER
ll > ush = integer =
INTEGER
ll < ush = integer =
INTEGER
ll <> ush = integer =
INTEGER
ll <= ush = integer =
INTEGER
ll >= ush = integer =
INTEGER
ll andalso ush = integer =
INTEGER
ll orelse ush = integer =
INTEGER

math ops (ll, i):

ll + i = max =
INTEGER
ll - i = max =
INTEGER
ll * i = max =
INTEGER
ll / i = float =
DOUBLE
ll ^ i = float =
DOUBLE
ll \ i = non-float =
INTEGER
ll mod i = non-float =
INTEGER

bitops (ll, i):

ll shl i = non-float =
INTEGER
ll shr i = non-float =
INTEGER
ll and i = non-float =
INTEGER
ll or i = non-float =
INTEGER
ll xor i = non-float =
INTEGER
ll eqv i = non-float =
INTEGER
ll imp i = non-float =
INTEGER

relational ops (ll, i):

ll = i = integer =
INTEGER
ll > i = integer =
INTEGER
ll < i = integer =
INTEGER
ll <> i = integer =
INTEGER
ll <= i = integer =
INTEGER
ll >= i = integer =
INTEGER
ll andalso i = integer =
INTEGER
ll orelse i = integer =
INTEGER

math ops (ll, ui):

ll + ui = max =
UINTEGER
ll - ui = max =
UINTEGER
ll * ui = max =
UINTEGER
ll / ui = float =
DOUBLE
ll ^ ui = float =
DOUBLE
ll \ ui = non-float =
UINTEGER
ll mod ui = non-float =
UINTEGER

bitops (ll, ui):

ll shl ui = non-float =
UINTEGER
ll shr ui = non-float =
UINTEGER
ll and ui = non-float =
UINTEGER
ll or ui = non-float =
UINTEGER
ll xor ui = non-float =
UINTEGER
ll eqv ui = non-float =
UINTEGER
ll imp ui = non-float =
UINTEGER

relational ops (ll, ui):

ll = ui = integer =
INTEGER
ll > ui = integer =
INTEGER
ll < ui = integer =
INTEGER
ll <> ui = integer =
INTEGER
ll <= ui = integer =
INTEGER
ll >= ui = integer =
INTEGER
ll andalso ui = integer =
INTEGER
ll orelse ui = integer =
INTEGER

math ops (ll, l):

ll + l = max =
INTEGER
ll - l = max =
INTEGER
ll * l = max =
INTEGER
ll / l = float =
DOUBLE
ll ^ l = float =
DOUBLE
ll \ l = non-float =
INTEGER
ll mod l = non-float =
INTEGER

bitops (ll, l):

ll shl l = non-float =
INTEGER
ll shr l = non-float =
INTEGER
ll and l = non-float =
INTEGER
ll or l = non-float =
INTEGER
ll xor l = non-float =
INTEGER
ll eqv l = non-float =
INTEGER
ll imp l = non-float =
INTEGER

relational ops (ll, l):

ll = l = integer =
INTEGER
ll > l = integer =
INTEGER
ll < l = integer =
INTEGER
ll <> l = integer =
INTEGER
ll <= l = integer =
INTEGER
ll >= l = integer =
INTEGER
ll andalso l = integer =
INTEGER
ll orelse l = integer =
INTEGER

math ops (ll, ul):

ll + ul = max =
INTEGER
ll - ul = max =
INTEGER
ll * ul = max =
INTEGER
ll / ul = float =
DOUBLE
ll ^ ul = float =
DOUBLE
ll \ ul = non-float =
INTEGER
ll mod ul = non-float =
INTEGER

bitops (ll, ul):

ll shl ul = non-float =
INTEGER
ll shr ul = non-float =
INTEGER
ll and ul = non-float =
INTEGER
ll or ul = non-float =
INTEGER
ll xor ul = non-float =
INTEGER
ll eqv ul = non-float =
INTEGER
ll imp ul = non-float =
INTEGER

relational ops (ll, ul):

ll = ul = integer =
INTEGER
ll > ul = integer =
INTEGER
ll < ul = integer =
INTEGER
ll <> ul = integer =
INTEGER
ll <= ul = integer =
INTEGER
ll >= ul = integer =
INTEGER
ll andalso ul = integer =
INTEGER
ll orelse ul = integer =
INTEGER

math ops (ll, ll):

ll + ll = max =
INTEGER
ll - ll = max =
INTEGER
ll * ll = max =
INTEGER
ll / ll = float =
DOUBLE
ll ^ ll = float =
DOUBLE
ll \ ll = non-float =
INTEGER
ll mod ll = non-float =
INTEGER

bitops (ll, ll):

ll shl ll = non-float =
INTEGER
ll shr ll = non-float =
INTEGER
ll and ll = non-float =
INTEGER
ll or ll = non-float =
INTEGER
ll xor ll = non-float =
INTEGER
ll eqv ll = non-float =
INTEGER
ll imp ll = non-float =
INTEGER

relational ops (ll, ll):

ll = ll = integer =
INTEGER
ll > ll = integer =
INTEGER
ll < ll = integer =
INTEGER
ll <> ll = integer =
INTEGER
ll <= ll = integer =
INTEGER
ll >= ll = integer =
INTEGER
ll andalso ll = integer =
INTEGER
ll orelse ll = integer =
INTEGER

math ops (ll, ull):

ll + ull = max =
UINTEGER
ll - ull = max =
UINTEGER
ll * ull = max =
UINTEGER
ll / ull = float =
DOUBLE
ll ^ ull = float =
DOUBLE
ll \ ull = non-float =
UINTEGER
ll mod ull = non-float =
UINTEGER

bitops (ll, ull):

ll shl ull = non-float =
UINTEGER
ll shr ull = non-float =
UINTEGER
ll and ull = non-float =
UINTEGER
ll or ull = non-float =
UINTEGER
ll xor ull = non-float =
UINTEGER
ll eqv ull = non-float =
UINTEGER
ll imp ull = non-float =
UINTEGER

relational ops (ll, ull):

ll = ull = integer =
INTEGER
ll > ull = integer =
INTEGER
ll < ull = integer =
INTEGER
ll <> ull = integer =
INTEGER
ll <= ull = integer =
INTEGER
ll >= ull = integer =
INTEGER
ll andalso ull = integer =
INTEGER
ll orelse ull = integer =
INTEGER

math ops (ll, enum1a):

ll + enum1a = max =
INTEGER
ll - enum1a = max =
INTEGER
ll * enum1a = max =
INTEGER
ll / enum1a = float =
DOUBLE
ll ^ enum1a = float =
DOUBLE
ll \ enum1a = non-float =
INTEGER
ll mod enum1a = non-float =
INTEGER

bitops (ll, enum1a):

ll shl enum1a = non-float =
INTEGER
ll shr enum1a = non-float =
INTEGER
ll and enum1a = non-float =
INTEGER
ll or enum1a = non-float =
INTEGER
ll xor enum1a = non-float =
INTEGER
ll eqv enum1a = non-float =
INTEGER
ll imp enum1a = non-float =
INTEGER

relational ops (ll, enum1a):

ll = enum1a = integer =
INTEGER
ll > enum1a = integer =
INTEGER
ll < enum1a = integer =
INTEGER
ll <> enum1a = integer =
INTEGER
ll <= enum1a = integer =
INTEGER
ll >= enum1a = integer =
INTEGER
ll andalso enum1a = integer =
INTEGER
ll orelse enum1a = integer =
INTEGER

math ops (b, ll):

b + ll = max =
INTEGER
b - ll = max =
INTEGER
b * ll = max =
INTEGER
b / ll = float =
DOUBLE
b ^ ll = float =
DOUBLE
b \ ll = non-float =
INTEGER
b mod ll = non-float =
INTEGER

bitops (b, ll):

b shl ll = non-float =
INTEGER
b shr ll = non-float =
INTEGER
b and ll = non-float =
INTEGER
b or ll = non-float =
INTEGER
b xor ll = non-float =
INTEGER
b eqv ll = non-float =
INTEGER
b imp ll = non-float =
INTEGER

relational ops (b, ll):

b = ll = integer =
INTEGER
b > ll = integer =
INTEGER
b < ll = integer =
INTEGER
b <> ll = integer =
INTEGER
b <= ll = integer =
INTEGER
b >= ll = integer =
INTEGER
b andalso ll = integer =
INTEGER
b orelse ll = integer =
INTEGER

math ops (ub, ll):

ub + ll = max =
INTEGER
ub - ll = max =
INTEGER
ub * ll = max =
INTEGER
ub / ll = float =
DOUBLE
ub ^ ll = float =
DOUBLE
ub \ ll = non-float =
INTEGER
ub mod ll = non-float =
INTEGER

bitops (ub, ll):

ub shl ll = non-float =
INTEGER
ub shr ll = non-float =
INTEGER
ub and ll = non-float =
INTEGER
ub or ll = non-float =
INTEGER
ub xor ll = non-float =
INTEGER
ub eqv ll = non-float =
INTEGER
ub imp ll = non-float =
INTEGER

relational ops (ub, ll):

ub = ll = integer =
INTEGER
ub > ll = integer =
INTEGER
ub < ll = integer =
INTEGER
ub <> ll = integer =
INTEGER
ub <= ll = integer =
INTEGER
ub >= ll = integer =
INTEGER
ub andalso ll = integer =
INTEGER
ub orelse ll = integer =
INTEGER

math ops (sh, ll):

sh + ll = max =
INTEGER
sh - ll = max =
INTEGER
sh * ll = max =
INTEGER
sh / ll = float =
DOUBLE
sh ^ ll = float =
DOUBLE
sh \ ll = non-float =
INTEGER
sh mod ll = non-float =
INTEGER

bitops (sh, ll):

sh shl ll = non-float =
INTEGER
sh shr ll = non-float =
INTEGER
sh and ll = non-float =
INTEGER
sh or ll = non-float =
INTEGER
sh xor ll = non-float =
INTEGER
sh eqv ll = non-float =
INTEGER
sh imp ll = non-float =
INTEGER

relational ops (sh, ll):

sh = ll = integer =
INTEGER
sh > ll = integer =
INTEGER
sh < ll = integer =
INTEGER
sh <> ll = integer =
INTEGER
sh <= ll = integer =
INTEGER
sh >= ll = integer =
INTEGER
sh andalso ll = integer =
INTEGER
sh orelse ll = integer =
INTEGER

math ops (ush, ll):

ush + ll = max =
INTEGER
ush - ll = max =
INTEGER
ush * ll = max =
INTEGER
ush / ll = float =
DOUBLE
ush ^ ll = float =
DOUBLE
ush \ ll = non-float =
INTEGER
ush mod ll = non-float =
INTEGER

bitops (ush, ll):

ush shl ll = non-float =
INTEGER
ush shr ll = non-float =
INTEGER
ush and ll = non-float =
INTEGER
ush or ll = non-float =
INTEGER
ush xor ll = non-float =
INTEGER
ush eqv ll = non-float =
INTEGER
ush imp ll = non-float =
INTEGER

relational ops (ush, ll):

ush = ll = integer =
INTEGER
ush > ll = integer =
INTEGER
ush < ll = integer =
INTEGER
ush <> ll = integer =
INTEGER
ush <= ll = integer =
INTEGER
ush >= ll = integer =
INTEGER
ush andalso ll = integer =
INTEGER
ush orelse ll = integer =
INTEGER

math ops (i, ll):

i + ll = max =
INTEGER
i - ll = max =
INTEGER
i * ll = max =
INTEGER
i / ll = float =
DOUBLE
i ^ ll = float =
DOUBLE
i \ ll = non-float =
INTEGER
i mod ll = non-float =
INTEGER

bitops (i, ll):

i shl ll = non-float =
INTEGER
i shr ll = non-float =
INTEGER
i and ll = non-float =
INTEGER
i or ll = non-float =
INTEGER
i xor ll = non-float =
INTEGER
i eqv ll = non-float =
INTEGER
i imp ll = non-float =
INTEGER

relational ops (i, ll):

i = ll = integer =
INTEGER
i > ll = integer =
INTEGER
i < ll = integer =
INTEGER
i <> ll = integer =
INTEGER
i <= ll = integer =
INTEGER
i >= ll = integer =
INTEGER
i andalso ll = integer =
INTEGER
i orelse ll = integer =
INTEGER

math ops (ui, ll):

ui + ll = max =
UINTEGER
ui - ll = max =
UINTEGER
ui * ll = max =
UINTEGER
ui / ll = float =
DOUBLE
ui ^ ll = float =
DOUBLE
ui \ ll = non-float =
UINTEGER
ui mod ll = non-float =
UINTEGER

bitops (ui, ll):

ui shl ll = non-float =
UINTEGER
ui shr ll = non-float =
UINTEGER
ui and ll = non-float =
UINTEGER
ui or ll = non-float =
UINTEGER
ui xor ll = non-float =
UINTEGER
ui eqv ll = non-float =
UINTEGER
ui imp ll = non-float =
UINTEGER

relational ops (ui, ll):

ui = ll = integer =
INTEGER
ui > ll = integer =
INTEGER
ui < ll = integer =
INTEGER
ui <> ll = integer =
INTEGER
ui <= ll = integer =
INTEGER
ui >= ll = integer =
INTEGER
ui andalso ll = integer =
INTEGER
ui orelse ll = integer =
INTEGER

math ops (l, ll):

l + ll = max =
INTEGER
l - ll = max =
INTEGER
l * ll = max =
INTEGER
l / ll = float =
DOUBLE
l ^ ll = float =
DOUBLE
l \ ll = non-float =
INTEGER
l mod ll = non-float =
INTEGER

bitops (l, ll):

l shl ll = non-float =
INTEGER
l shr ll = non-float =
INTEGER
l and ll = non-float =
INTEGER
l or ll = non-float =
INTEGER
l xor ll = non-float =
INTEGER
l eqv ll = non-float =
INTEGER
l imp ll = non-float =
INTEGER

relational ops (l, ll):

l = ll = integer =
INTEGER
l > ll = integer =
INTEGER
l < ll = integer =
INTEGER
l <> ll = integer =
INTEGER
l <= ll = integer =
INTEGER
l >= ll = integer =
INTEGER
l andalso ll = integer =
INTEGER
l orelse ll = integer =
INTEGER

math ops (ul, ll):

ul + ll = max =
INTEGER
ul - ll = max =
INTEGER
ul * ll = max =
INTEGER
ul / ll = float =
DOUBLE
ul ^ ll = float =
DOUBLE
ul \ ll = non-float =
INTEGER
ul mod ll = non-float =
INTEGER

bitops (ul, ll):

ul shl ll = non-float =
INTEGER
ul shr ll = non-float =
INTEGER
ul and ll = non-float =
INTEGER
ul or ll = non-float =
INTEGER
ul xor ll = non-float =
INTEGER
ul eqv ll = non-float =
INTEGER
ul imp ll = non-float =
INTEGER

relational ops (ul, ll):

ul = ll = integer =
INTEGER
ul > ll = integer =
INTEGER
ul < ll = integer =
INTEGER
ul <> ll = integer =
INTEGER
ul <= ll = integer =
INTEGER
ul >= ll = integer =
INTEGER
ul andalso ll = integer =
INTEGER
ul orelse ll = integer =
INTEGER

math ops (ll, ll):

ll + ll = max =
INTEGER
ll - ll = max =
INTEGER
ll * ll = max =
INTEGER
ll / ll = float =
DOUBLE
ll ^ ll = float =
DOUBLE
ll \ ll = non-float =
INTEGER
ll mod ll = non-float =
INTEGER

bitops (ll, ll):

ll shl ll = non-float =
INTEGER
ll shr ll = non-float =
INTEGER
ll and ll = non-float =
INTEGER
ll or ll = non-float =
INTEGER
ll xor ll = non-float =
INTEGER
ll eqv ll = non-float =
INTEGER
ll imp ll = non-float =
INTEGER

relational ops (ll, ll):

ll = ll = integer =
INTEGER
ll > ll = integer =
INTEGER
ll < ll = integer =
INTEGER
ll <> ll = integer =
INTEGER
ll <= ll = integer =
INTEGER
ll >= ll = integer =
INTEGER
ll andalso ll = integer =
INTEGER
ll orelse ll = integer =
INTEGER

math ops (ull, ll):

ull + ll = max =
UINTEGER
ull - ll = max =
UINTEGER
ull * ll = max =
UINTEGER
ull / ll = float =
DOUBLE
ull ^ ll = float =
DOUBLE
ull \ ll = non-float =
UINTEGER
ull mod ll = non-float =
UINTEGER

bitops (ull, ll):

ull shl ll = non-float =
UINTEGER
ull shr ll = non-float =
UINTEGER
ull and ll = non-float =
UINTEGER
ull or ll = non-float =
UINTEGER
ull xor ll = non-float =
UINTEGER
ull eqv ll = non-float =
UINTEGER
ull imp ll = non-float =
UINTEGER

relational ops (ull, ll):

ull = ll = integer =
INTEGER
ull > ll = integer =
INTEGER
ull < ll = integer =
INTEGER
ull <> ll = integer =
INTEGER
ull <= ll = integer =
INTEGER
ull >= ll = integer =
INTEGER
ull andalso ll = integer =
INTEGER
ull orelse ll = integer =
INTEGER

math ops (enum1a, ll):

enum1a + ll = max =
INTEGER
enum1a - ll = max =
INTEGER
enum1a * ll = max =
INTEGER
enum1a / ll = float =
DOUBLE
enum1a ^ ll = float =
DOUBLE
enum1a \ ll = non-float =
INTEGER
enum1a mod ll = non-float =
INTEGER

bitops (enum1a, ll):

enum1a shl ll = non-float =
INTEGER
enum1a shr ll = non-float =
INTEGER
enum1a and ll = non-float =
INTEGER
enum1a or ll = non-float =
INTEGER
enum1a xor ll = non-float =
INTEGER
enum1a eqv ll = non-float =
INTEGER
enum1a imp ll = non-float =
INTEGER

relational ops (enum1a, ll):

enum1a = ll = integer =
INTEGER
enum1a > ll = integer =
INTEGER
enum1a < ll = integer =
INTEGER
enum1a <> ll = integer =
INTEGER
enum1a <= ll = integer =
INTEGER
enum1a >= ll = integer =
INTEGER
enum1a andalso ll = integer =
INTEGER
enum1a orelse ll = integer =
INTEGER

math ops (ll, f):

ll + f = max =
SINGLE
ll - f = max =
SINGLE
ll * f = max =
SINGLE
ll / f = float =
DOUBLE
ll ^ f = float =
DOUBLE
ll \ f = non-float =
INTEGER
ll mod f = non-float =
INTEGER

bitops (ll, f):

ll shl f = non-float =
INTEGER
ll shr f = non-float =
INTEGER
ll and f = non-float =
INTEGER
ll or f = non-float =
INTEGER
ll xor f = non-float =
INTEGER
ll eqv f = non-float =
INTEGER
ll imp f = non-float =
INTEGER

relational ops (ll, f):

ll = f = integer =
INTEGER
ll > f = integer =
INTEGER
ll < f = integer =
INTEGER
ll <> f = integer =
INTEGER
ll <= f = integer =
INTEGER
ll >= f = integer =
INTEGER
ll andalso f = integer =
INTEGER
ll orelse f = integer =
INTEGER

math ops (ll, d):

ll + d = max =
DOUBLE
ll - d = max =
DOUBLE
ll * d = max =
DOUBLE
ll / d = float =
DOUBLE
ll ^ d = float =
DOUBLE
ll \ d = non-float =
INTEGER
ll mod d = non-float =
INTEGER

bitops (ll, d):

ll shl d = non-float =
INTEGER
ll shr d = non-float =
INTEGER
ll and d = non-float =
INTEGER
ll or d = non-float =
INTEGER
ll xor d = non-float =
INTEGER
ll eqv d = non-float =
INTEGER
ll imp d = non-float =
INTEGER

relational ops (ll, d):

ll = d = integer =
INTEGER
ll > d = integer =
INTEGER
ll < d = integer =
INTEGER
ll <> d = integer =
INTEGER
ll <= d = integer =
INTEGER
ll >= d = integer =
INTEGER
ll andalso d = integer =
INTEGER
ll orelse d = integer =
INTEGER

math ops (f, ll):

f + ll = max =
SINGLE
f - ll = max =
SINGLE
f * ll = max =
SINGLE
f / ll = float =
DOUBLE
f ^ ll = float =
DOUBLE
f \ ll = non-float =
INTEGER
f mod ll = non-float =
INTEGER

bitops (f, ll):

f shl ll = non-float =
INTEGER
f shr ll = non-float =
INTEGER
f and ll = non-float =
INTEGER
f or ll = non-float =
INTEGER
f xor ll = non-float =
INTEGER
f eqv ll = non-float =
INTEGER
f imp ll = non-float =
INTEGER

relational ops (f, ll):

f = ll = integer =
INTEGER
f > ll = integer =
INTEGER
f < ll = integer =
INTEGER
f <> ll = integer =
INTEGER
f <= ll = integer =
INTEGER
f >= ll = integer =
INTEGER
f andalso ll = integer =
INTEGER
f orelse ll = integer =
INTEGER

math ops (d, ll):

d + ll = max =
DOUBLE
d - ll = max =
DOUBLE
d * ll = max =
DOUBLE
d / ll = float =
DOUBLE
d ^ ll = float =
DOUBLE
d \ ll = non-float =
INTEGER
d mod ll = non-float =
INTEGER

bitops (d, ll):

d shl ll = non-float =
INTEGER
d shr ll = non-float =
INTEGER
d and ll = non-float =
INTEGER
d or ll = non-float =
INTEGER
d xor ll = non-float =
INTEGER
d eqv ll = non-float =
INTEGER
d imp ll = non-float =
INTEGER

relational ops (d, ll):

d = ll = integer =
INTEGER
d > ll = integer =
INTEGER
d < ll = integer =
INTEGER
d <> ll = integer =
INTEGER
d <= ll = integer =
INTEGER
d >= ll = integer =
INTEGER
d andalso ll = integer =
INTEGER
d orelse ll = integer =
INTEGER

----- ull -----------------------------------------------------


math ops (ull, b):

ull + b = max =
UINTEGER
ull - b = max =
UINTEGER
ull * b = max =
UINTEGER
ull / b = float =
DOUBLE
ull ^ b = float =
DOUBLE
ull \ b = non-float =
UINTEGER
ull mod b = non-float =
UINTEGER

bitops (ull, b):

ull shl b = non-float =
UINTEGER
ull shr b = non-float =
UINTEGER
ull and b = non-float =
UINTEGER
ull or b = non-float =
UINTEGER
ull xor b = non-float =
UINTEGER
ull eqv b = non-float =
UINTEGER
ull imp b = non-float =
UINTEGER

relational ops (ull, b):

ull = b = integer =
INTEGER
ull > b = integer =
INTEGER
ull < b = integer =
INTEGER
ull <> b = integer =
INTEGER
ull <= b = integer =
INTEGER
ull >= b = integer =
INTEGER
ull andalso b = integer =
INTEGER
ull orelse b = integer =
INTEGER

math ops (ull, ub):

ull + ub = max =
UINTEGER
ull - ub = max =
UINTEGER
ull * ub = max =
UINTEGER
ull / ub = float =
DOUBLE
ull ^ ub = float =
DOUBLE
ull \ ub = non-float =
UINTEGER
ull mod ub = non-float =
UINTEGER

bitops (ull, ub):

ull shl ub = non-float =
UINTEGER
ull shr ub = non-float =
UINTEGER
ull and ub = non-float =
UINTEGER
ull or ub = non-float =
UINTEGER
ull xor ub = non-float =
UINTEGER
ull eqv ub = non-float =
UINTEGER
ull imp ub = non-float =
UINTEGER

relational ops (ull, ub):

ull = ub = integer =
INTEGER
ull > ub = integer =
INTEGER
ull < ub = integer =
INTEGER
ull <> ub = integer =
INTEGER
ull <= ub = integer =
INTEGER
ull >= ub = integer =
INTEGER
ull andalso ub = integer =
INTEGER
ull orelse ub = integer =
INTEGER

math ops (ull, sh):

ull + sh = max =
UINTEGER
ull - sh = max =
UINTEGER
ull * sh = max =
UINTEGER
ull / sh = float =
DOUBLE
ull ^ sh = float =
DOUBLE
ull \ sh = non-float =
UINTEGER
ull mod sh = non-float =
UINTEGER

bitops (ull, sh):

ull shl sh = non-float =
UINTEGER
ull shr sh = non-float =
UINTEGER
ull and sh = non-float =
UINTEGER
ull or sh = non-float =
UINTEGER
ull xor sh = non-float =
UINTEGER
ull eqv sh = non-float =
UINTEGER
ull imp sh = non-float =
UINTEGER

relational ops (ull, sh):

ull = sh = integer =
INTEGER
ull > sh = integer =
INTEGER
ull < sh = integer =
INTEGER
ull <> sh = integer =
INTEGER
ull <= sh = integer =
INTEGER
ull >= sh = integer =
INTEGER
ull andalso sh = integer =
INTEGER
ull orelse sh = integer =
INTEGER

math ops (ull, ush):

ull + ush = max =
UINTEGER
ull - ush = max =
UINTEGER
ull * ush = max =
UINTEGER
ull / ush = float =
DOUBLE
ull ^ ush = float =
DOUBLE
ull \ ush = non-float =
UINTEGER
ull mod ush = non-float =
UINTEGER

bitops (ull, ush):

ull shl ush = non-float =
UINTEGER
ull shr ush = non-float =
UINTEGER
ull and ush = non-float =
UINTEGER
ull or ush = non-float =
UINTEGER
ull xor ush = non-float =
UINTEGER
ull eqv ush = non-float =
UINTEGER
ull imp ush = non-float =
UINTEGER

relational ops (ull, ush):

ull = ush = integer =
INTEGER
ull > ush = integer =
INTEGER
ull < ush = integer =
INTEGER
ull <> ush = integer =
INTEGER
ull <= ush = integer =
INTEGER
ull >= ush = integer =
INTEGER
ull andalso ush = integer =
INTEGER
ull orelse ush = integer =
INTEGER

math ops (ull, i):

ull + i = max =
UINTEGER
ull - i = max =
UINTEGER
ull * i = max =
UINTEGER
ull / i = float =
DOUBLE
ull ^ i = float =
DOUBLE
ull \ i = non-float =
UINTEGER
ull mod i = non-float =
UINTEGER

bitops (ull, i):

ull shl i = non-float =
UINTEGER
ull shr i = non-float =
UINTEGER
ull and i = non-float =
UINTEGER
ull or i = non-float =
UINTEGER
ull xor i = non-float =
UINTEGER
ull eqv i = non-float =
UINTEGER
ull imp i = non-float =
UINTEGER

relational ops (ull, i):

ull = i = integer =
INTEGER
ull > i = integer =
INTEGER
ull < i = integer =
INTEGER
ull <> i = integer =
INTEGER
ull <= i = integer =
INTEGER
ull >= i = integer =
INTEGER
ull andalso i = integer =
INTEGER
ull orelse i = integer =
INTEGER

math ops (ull, ui):

ull + ui = max =
UINTEGER
ull - ui = max =
UINTEGER
ull * ui = max =
UINTEGER
ull / ui = float =
DOUBLE
ull ^ ui = float =
DOUBLE
ull \ ui = non-float =
UINTEGER
ull mod ui = non-float =
UINTEGER

bitops (ull, ui):

ull shl ui = non-float =
UINTEGER
ull shr ui = non-float =
UINTEGER
ull and ui = non-float =
UINTEGER
ull or ui = non-float =
UINTEGER
ull xor ui = non-float =
UINTEGER
ull eqv ui = non-float =
UINTEGER
ull imp ui = non-float =
UINTEGER

relational ops (ull, ui):

ull = ui = integer =
INTEGER
ull > ui = integer =
INTEGER
ull < ui = integer =
INTEGER
ull <> ui = integer =
INTEGER
ull <= ui = integer =
INTEGER
ull >= ui = integer =
INTEGER
ull andalso ui = integer =
INTEGER
ull orelse ui = integer =
INTEGER

math ops (ull, l):

ull + l = max =
UINTEGER
ull - l = max =
UINTEGER
ull * l = max =
UINTEGER
ull / l = float =
DOUBLE
ull ^ l = float =
DOUBLE
ull \ l = non-float =
UINTEGER
ull mod l = non-float =
UINTEGER

bitops (ull, l):

ull shl l = non-float =
UINTEGER
ull shr l = non-float =
UINTEGER
ull and l = non-float =
UINTEGER
ull or l = non-float =
UINTEGER
ull xor l = non-float =
UINTEGER
ull eqv l = non-float =
UINTEGER
ull imp l = non-float =
UINTEGER

relational ops (ull, l):

ull = l = integer =
INTEGER
ull > l = integer =
INTEGER
ull < l = integer =
INTEGER
ull <> l = integer =
INTEGER
ull <= l = integer =
INTEGER
ull >= l = integer =
INTEGER
ull andalso l = integer =
INTEGER
ull orelse l = integer =
INTEGER

math ops (ull, ul):

ull + ul = max =
UINTEGER
ull - ul = max =
UINTEGER
ull * ul = max =
UINTEGER
ull / ul = float =
DOUBLE
ull ^ ul = float =
DOUBLE
ull \ ul = non-float =
UINTEGER
ull mod ul = non-float =
UINTEGER

bitops (ull, ul):

ull shl ul = non-float =
UINTEGER
ull shr ul = non-float =
UINTEGER
ull and ul = non-float =
UINTEGER
ull or ul = non-float =
UINTEGER
ull xor ul = non-float =
UINTEGER
ull eqv ul = non-float =
UINTEGER
ull imp ul = non-float =
UINTEGER

relational ops (ull, ul):

ull = ul = integer =
INTEGER
ull > ul = integer =
INTEGER
ull < ul = integer =
INTEGER
ull <> ul = integer =
INTEGER
ull <= ul = integer =
INTEGER
ull >= ul = integer =
INTEGER
ull andalso ul = integer =
INTEGER
ull orelse ul = integer =
INTEGER

math ops (ull, ll):

ull + ll = max =
UINTEGER
ull - ll = max =
UINTEGER
ull * ll = max =
UINTEGER
ull / ll = float =
DOUBLE
ull ^ ll = float =
DOUBLE
ull \ ll = non-float =
UINTEGER
ull mod ll = non-float =
UINTEGER

bitops (ull, ll):

ull shl ll = non-float =
UINTEGER
ull shr ll = non-float =
UINTEGER
ull and ll = non-float =
UINTEGER
ull or ll = non-float =
UINTEGER
ull xor ll = non-float =
UINTEGER
ull eqv ll = non-float =
UINTEGER
ull imp ll = non-float =
UINTEGER

relational ops (ull, ll):

ull = ll = integer =
INTEGER
ull > ll = integer =
INTEGER
ull < ll = integer =
INTEGER
ull <> ll = integer =
INTEGER
ull <= ll = integer =
INTEGER
ull >= ll = integer =
INTEGER
ull andalso ll = integer =
INTEGER
ull orelse ll = integer =
INTEGER

math ops (ull, ull):

ull + ull = max =
UINTEGER
ull - ull = max =
UINTEGER
ull * ull = max =
UINTEGER
ull / ull = float =
DOUBLE
ull ^ ull = float =
DOUBLE
ull \ ull = non-float =
UINTEGER
ull mod ull = non-float =
UINTEGER

bitops (ull, ull):

ull shl ull = non-float =
UINTEGER
ull shr ull = non-float =
UINTEGER
ull and ull = non-float =
UINTEGER
ull or ull = non-float =
UINTEGER
ull xor ull = non-float =
UINTEGER
ull eqv ull = non-float =
UINTEGER
ull imp ull = non-float =
UINTEGER

relational ops (ull, ull):

ull = ull = integer =
INTEGER
ull > ull = integer =
INTEGER
ull < ull = integer =
INTEGER
ull <> ull = integer =
INTEGER
ull <= ull = integer =
INTEGER
ull >= ull = integer =
INTEGER
ull andalso ull = integer =
INTEGER
ull orelse ull = integer =
INTEGER

math ops (ull, enum1a):

ull + enum1a = max =
UINTEGER
ull - enum1a = max =
UINTEGER
ull * enum1a = max =
UINTEGER
ull / enum1a = float =
DOUBLE
ull ^ enum1a = float =
DOUBLE
ull \ enum1a = non-float =
UINTEGER
ull mod enum1a = non-float =
UINTEGER

bitops (ull, enum1a):

ull shl enum1a = non-float =
UINTEGER
ull shr enum1a = non-float =
UINTEGER
ull and enum1a = non-float =
UINTEGER
ull or enum1a = non-float =
UINTEGER
ull xor enum1a = non-float =
UINTEGER
ull eqv enum1a = non-float =
UINTEGER
ull imp enum1a = non-float =
UINTEGER

relational ops (ull, enum1a):

ull = enum1a = integer =
INTEGER
ull > enum1a = integer =
INTEGER
ull < enum1a = integer =
INTEGER
ull <> enum1a = integer =
INTEGER
ull <= enum1a = integer =
INTEGER
ull >= enum1a = integer =
INTEGER
ull andalso enum1a = integer =
INTEGER
ull orelse enum1a = integer =
INTEGER

math ops (b, ull):

b + ull = max =
UINTEGER
b - ull = max =
UINTEGER
b * ull = max =
UINTEGER
b / ull = float =
DOUBLE
b ^ ull = float =
DOUBLE
b \ ull = non-float =
UINTEGER
b mod ull = non-float =
UINTEGER

bitops (b, ull):

b shl ull = non-float =
UINTEGER
b shr ull = non-float =
UINTEGER
b and ull = non-float =
UINTEGER
b or ull = non-float =
UINTEGER
b xor ull = non-float =
UINTEGER
b eqv ull = non-float =
UINTEGER
b imp ull = non-float =
UINTEGER

relational ops (b, ull):

b = ull = integer =
INTEGER
b > ull = integer =
INTEGER
b < ull = integer =
INTEGER
b <> ull = integer =
INTEGER
b <= ull = integer =
INTEGER
b >= ull = integer =
INTEGER
b andalso ull = integer =
INTEGER
b orelse ull = integer =
INTEGER

math ops (ub, ull):

ub + ull = max =
UINTEGER
ub - ull = max =
UINTEGER
ub * ull = max =
UINTEGER
ub / ull = float =
DOUBLE
ub ^ ull = float =
DOUBLE
ub \ ull = non-float =
UINTEGER
ub mod ull = non-float =
UINTEGER

bitops (ub, ull):

ub shl ull = non-float =
UINTEGER
ub shr ull = non-float =
UINTEGER
ub and ull = non-float =
UINTEGER
ub or ull = non-float =
UINTEGER
ub xor ull = non-float =
UINTEGER
ub eqv ull = non-float =
UINTEGER
ub imp ull = non-float =
UINTEGER

relational ops (ub, ull):

ub = ull = integer =
INTEGER
ub > ull = integer =
INTEGER
ub < ull = integer =
INTEGER
ub <> ull = integer =
INTEGER
ub <= ull = integer =
INTEGER
ub >= ull = integer =
INTEGER
ub andalso ull = integer =
INTEGER
ub orelse ull = integer =
INTEGER

math ops (sh, ull):

sh + ull = max =
UINTEGER
sh - ull = max =
UINTEGER
sh * ull = max =
UINTEGER
sh / ull = float =
DOUBLE
sh ^ ull = float =
DOUBLE
sh \ ull = non-float =
UINTEGER
sh mod ull = non-float =
UINTEGER

bitops (sh, ull):

sh shl ull = non-float =
UINTEGER
sh shr ull = non-float =
UINTEGER
sh and ull = non-float =
UINTEGER
sh or ull = non-float =
UINTEGER
sh xor ull = non-float =
UINTEGER
sh eqv ull = non-float =
UINTEGER
sh imp ull = non-float =
UINTEGER

relational ops (sh, ull):

sh = ull = integer =
INTEGER
sh > ull = integer =
INTEGER
sh < ull = integer =
INTEGER
sh <> ull = integer =
INTEGER
sh <= ull = integer =
INTEGER
sh >= ull = integer =
INTEGER
sh andalso ull = integer =
INTEGER
sh orelse ull = integer =
INTEGER

math ops (ush, ull):

ush + ull = max =
UINTEGER
ush - ull = max =
UINTEGER
ush * ull = max =
UINTEGER
ush / ull = float =
DOUBLE
ush ^ ull = float =
DOUBLE
ush \ ull = non-float =
UINTEGER
ush mod ull = non-float =
UINTEGER

bitops (ush, ull):

ush shl ull = non-float =
UINTEGER
ush shr ull = non-float =
UINTEGER
ush and ull = non-float =
UINTEGER
ush or ull = non-float =
UINTEGER
ush xor ull = non-float =
UINTEGER
ush eqv ull = non-float =
UINTEGER
ush imp ull = non-float =
UINTEGER

relational ops (ush, ull):

ush = ull = integer =
INTEGER
ush > ull = integer =
INTEGER
ush < ull = integer =
INTEGER
ush <> ull = integer =
INTEGER
ush <= ull = integer =
INTEGER
ush >= ull = integer =
INTEGER
ush andalso ull = integer =
INTEGER
ush orelse ull = integer =
INTEGER

math ops (i, ull):

i + ull = max =
UINTEGER
i - ull = max =
UINTEGER
i * ull = max =
UINTEGER
i / ull = float =
DOUBLE
i ^ ull = float =
DOUBLE
i \ ull = non-float =
UINTEGER
i mod ull = non-float =
UINTEGER

bitops (i, ull):

i shl ull = non-float =
UINTEGER
i shr ull = non-float =
UINTEGER
i and ull = non-float =
UINTEGER
i or ull = non-float =
UINTEGER
i xor ull = non-float =
UINTEGER
i eqv ull = non-float =
UINTEGER
i imp ull = non-float =
UINTEGER

relational ops (i, ull):

i = ull = integer =
INTEGER
i > ull = integer =
INTEGER
i < ull = integer =
INTEGER
i <> ull = integer =
INTEGER
i <= ull = integer =
INTEGER
i >= ull = integer =
INTEGER
i andalso ull = integer =
INTEGER
i orelse ull = integer =
INTEGER

math ops (ui, ull):

ui + ull = max =
UINTEGER
ui - ull = max =
UINTEGER
ui * ull = max =
UINTEGER
ui / ull = float =
DOUBLE
ui ^ ull = float =
DOUBLE
ui \ ull = non-float =
UINTEGER
ui mod ull = non-float =
UINTEGER

bitops (ui, ull):

ui shl ull = non-float =
UINTEGER
ui shr ull = non-float =
UINTEGER
ui and ull = non-float =
UINTEGER
ui or ull = non-float =
UINTEGER
ui xor ull = non-float =
UINTEGER
ui eqv ull = non-float =
UINTEGER
ui imp ull = non-float =
UINTEGER

relational ops (ui, ull):

ui = ull = integer =
INTEGER
ui > ull = integer =
INTEGER
ui < ull = integer =
INTEGER
ui <> ull = integer =
INTEGER
ui <= ull = integer =
INTEGER
ui >= ull = integer =
INTEGER
ui andalso ull = integer =
INTEGER
ui orelse ull = integer =
INTEGER

math ops (l, ull):

l + ull = max =
UINTEGER
l - ull = max =
UINTEGER
l * ull = max =
UINTEGER
l / ull = float =
DOUBLE
l ^ ull = float =
DOUBLE
l \ ull = non-float =
UINTEGER
l mod ull = non-float =
UINTEGER

bitops (l, ull):

l shl ull = non-float =
UINTEGER
l shr ull = non-float =
UINTEGER
l and ull = non-float =
UINTEGER
l or ull = non-float =
UINTEGER
l xor ull = non-float =
UINTEGER
l eqv ull = non-float =
UINTEGER
l imp ull = non-float =
UINTEGER

relational ops (l, ull):

l = ull = integer =
INTEGER
l > ull = integer =
INTEGER
l < ull = integer =
INTEGER
l <> ull = integer =
INTEGER
l <= ull = integer =
INTEGER
l >= ull = integer =
INTEGER
l andalso ull = integer =
INTEGER
l orelse ull = integer =
INTEGER

math ops (ul, ull):

ul + ull = max =
UINTEGER
ul - ull = max =
UINTEGER
ul * ull = max =
UINTEGER
ul / ull = float =
DOUBLE
ul ^ ull = float =
DOUBLE
ul \ ull = non-float =
UINTEGER
ul mod ull = non-float =
UINTEGER

bitops (ul, ull):

ul shl ull = non-float =
UINTEGER
ul shr ull = non-float =
UINTEGER
ul and ull = non-float =
UINTEGER
ul or ull = non-float =
UINTEGER
ul xor ull = non-float =
UINTEGER
ul eqv ull = non-float =
UINTEGER
ul imp ull = non-float =
UINTEGER

relational ops (ul, ull):

ul = ull = integer =
INTEGER
ul > ull = integer =
INTEGER
ul < ull = integer =
INTEGER
ul <> ull = integer =
INTEGER
ul <= ull = integer =
INTEGER
ul >= ull = integer =
INTEGER
ul andalso ull = integer =
INTEGER
ul orelse ull = integer =
INTEGER

math ops (ll, ull):

ll + ull = max =
UINTEGER
ll - ull = max =
UINTEGER
ll * ull = max =
UINTEGER
ll / ull = float =
DOUBLE
ll ^ ull = float =
DOUBLE
ll \ ull = non-float =
UINTEGER
ll mod ull = non-float =
UINTEGER

bitops (ll, ull):

ll shl ull = non-float =
UINTEGER
ll shr ull = non-float =
UINTEGER
ll and ull = non-float =
UINTEGER
ll or ull = non-float =
UINTEGER
ll xor ull = non-float =
UINTEGER
ll eqv ull = non-float =
UINTEGER
ll imp ull = non-float =
UINTEGER

relational ops (ll, ull):

ll = ull = integer =
INTEGER
ll > ull = integer =
INTEGER
ll < ull = integer =
INTEGER
ll <> ull = integer =
INTEGER
ll <= ull = integer =
INTEGER
ll >= ull = integer =
INTEGER
ll andalso ull = integer =
INTEGER
ll orelse ull = integer =
INTEGER

math ops (ull, ull):

ull + ull = max =
UINTEGER
ull - ull = max =
UINTEGER
ull * ull = max =
UINTEGER
ull / ull = float =
DOUBLE
ull ^ ull = float =
DOUBLE
ull \ ull = non-float =
UINTEGER
ull mod ull = non-float =
UINTEGER

bitops (ull, ull):

ull shl ull = non-float =
UINTEGER
ull shr ull = non-float =
UINTEGER
ull and ull = non-float =
UINTEGER
ull or ull = non-float =
UINTEGER
ull xor ull = non-float =
UINTEGER
ull eqv ull = non-float =
UINTEGER
ull imp ull = non-float =
UINTEGER

relational ops (ull, ull):

ull = ull = integer =
INTEGER
ull > ull = integer =
INTEGER
ull < ull = integer =
INTEGER
ull <> ull = integer =
INTEGER
ull <= ull = integer =
INTEGER
ull >= ull = integer =
INTEGER
ull andalso ull = integer =
INTEGER
ull orelse ull = integer =
INTEGER

math ops (enum1a, ull):

enum1a + ull = max =
UINTEGER
enum1a - ull = max =
UINTEGER
enum1a * ull = max =
UINTEGER
enum1a / ull = float =
DOUBLE
enum1a ^ ull = float =
DOUBLE
enum1a \ ull = non-float =
UINTEGER
enum1a mod ull = non-float =
UINTEGER

bitops (enum1a, ull):

enum1a shl ull = non-float =
UINTEGER
enum1a shr ull = non-float =
UINTEGER
enum1a and ull = non-float =
UINTEGER
enum1a or ull = non-float =
UINTEGER
enum1a xor ull = non-float =
UINTEGER
enum1a eqv ull = non-float =
UINTEGER
enum1a imp ull = non-float =
UINTEGER

relational ops (enum1a, ull):

enum1a = ull = integer =
INTEGER
enum1a > ull = integer =
INTEGER
enum1a < ull = integer =
INTEGER
enum1a <> ull = integer =
INTEGER
enum1a <= ull = integer =
INTEGER
enum1a >= ull = integer =
INTEGER
enum1a andalso ull = integer =
INTEGER
enum1a orelse ull = integer =
INTEGER

math ops (ull, f):

ull + f = max =
SINGLE
ull - f = max =
SINGLE
ull * f = max =
SINGLE
ull / f = float =
DOUBLE
ull ^ f = float =
DOUBLE
ull \ f = non-float =
UINTEGER
ull mod f = non-float =
UINTEGER

bitops (ull, f):

ull shl f = non-float =
UINTEGER
ull shr f = non-float =
UINTEGER
ull and f = non-float =
UINTEGER
ull or f = non-float =
UINTEGER
ull xor f = non-float =
UINTEGER
ull eqv f = non-float =
UINTEGER
ull imp f = non-float =
UINTEGER

relational ops (ull, f):

ull = f = integer =
INTEGER
ull > f = integer =
INTEGER
ull < f = integer =
INTEGER
ull <> f = integer =
INTEGER
ull <= f = integer =
INTEGER
ull >= f = integer =
INTEGER
ull andalso f = integer =
INTEGER
ull orelse f = integer =
INTEGER

math ops (ull, d):

ull + d = max =
DOUBLE
ull - d = max =
DOUBLE
ull * d = max =
DOUBLE
ull / d = float =
DOUBLE
ull ^ d = float =
DOUBLE
ull \ d = non-float =
UINTEGER
ull mod d = non-float =
UINTEGER

bitops (ull, d):

ull shl d = non-float =
UINTEGER
ull shr d = non-float =
UINTEGER
ull and d = non-float =
UINTEGER
ull or d = non-float =
UINTEGER
ull xor d = non-float =
UINTEGER
ull eqv d = non-float =
UINTEGER
ull imp d = non-float =
UINTEGER

relational ops (ull, d):

ull = d = integer =
INTEGER
ull > d = integer =
INTEGER
ull < d = integer =
INTEGER
ull <> d = integer =
INTEGER
ull <= d = integer =
INTEGER
ull >= d = integer =
INTEGER
ull andalso d = integer =
INTEGER
ull orelse d = integer =
INTEGER

math ops (f, ull):

f + ull = max =
SINGLE
f - ull = max =
SINGLE
f * ull = max =
SINGLE
f / ull = float =
DOUBLE
f ^ ull = float =
DOUBLE
f \ ull = non-float =
UINTEGER
f mod ull = non-float =
UINTEGER

bitops (f, ull):

f shl ull = non-float =
UINTEGER
f shr ull = non-float =
UINTEGER
f and ull = non-float =
UINTEGER
f or ull = non-float =
UINTEGER
f xor ull = non-float =
UINTEGER
f eqv ull = non-float =
UINTEGER
f imp ull = non-float =
UINTEGER

relational ops (f, ull):

f = ull = integer =
INTEGER
f > ull = integer =
INTEGER
f < ull = integer =
INTEGER
f <> ull = integer =
INTEGER
f <= ull = integer =
INTEGER
f >= ull = integer =
INTEGER
f andalso ull = integer =
INTEGER
f orelse ull = integer =
INTEGER

math ops (d, ull):

d + ull = max =
DOUBLE
d - ull = max =
DOUBLE
d * ull = max =
DOUBLE
d / ull = float =
DOUBLE
d ^ ull = float =
DOUBLE
d \ ull = non-float =
UINTEGER
d mod ull = non-float =
UINTEGER

bitops (d, ull):

d shl ull = non-float =
UINTEGER
d shr ull = non-float =
UINTEGER
d and ull = non-float =
UINTEGER
d or ull = non-float =
UINTEGER
d xor ull = non-float =
UINTEGER
d eqv ull = non-float =
UINTEGER
d imp ull = non-float =
UINTEGER

relational ops (d, ull):

d = ull = integer =
INTEGER
d > ull = integer =
INTEGER
d < ull = integer =
INTEGER
d <> ull = integer =
INTEGER
d <= ull = integer =
INTEGER
d >= ull = integer =
INTEGER
d andalso ull = integer =
INTEGER
d orelse ull = integer =
INTEGER

----- f -----------------------------------------------------


math ops (f, b):

f + b = max =
SINGLE
f - b = max =
SINGLE
f * b = max =
SINGLE
f / b = float =
DOUBLE
f ^ b = float =
DOUBLE
f \ b = non-float =
INTEGER
f mod b = non-float =
INTEGER

bitops (f, b):

f shl b = non-float =
INTEGER
f shr b = non-float =
INTEGER
f and b = non-float =
INTEGER
f or b = non-float =
INTEGER
f xor b = non-float =
INTEGER
f eqv b = non-float =
INTEGER
f imp b = non-float =
INTEGER

relational ops (f, b):

f = b = integer =
INTEGER
f > b = integer =
INTEGER
f < b = integer =
INTEGER
f <> b = integer =
INTEGER
f <= b = integer =
INTEGER
f >= b = integer =
INTEGER
f andalso b = integer =
INTEGER
f orelse b = integer =
INTEGER

math ops (f, ub):

f + ub = max =
SINGLE
f - ub = max =
SINGLE
f * ub = max =
SINGLE
f / ub = float =
DOUBLE
f ^ ub = float =
DOUBLE
f \ ub = non-float =
INTEGER
f mod ub = non-float =
INTEGER

bitops (f, ub):

f shl ub = non-float =
INTEGER
f shr ub = non-float =
INTEGER
f and ub = non-float =
INTEGER
f or ub = non-float =
INTEGER
f xor ub = non-float =
INTEGER
f eqv ub = non-float =
INTEGER
f imp ub = non-float =
INTEGER

relational ops (f, ub):

f = ub = integer =
INTEGER
f > ub = integer =
INTEGER
f < ub = integer =
INTEGER
f <> ub = integer =
INTEGER
f <= ub = integer =
INTEGER
f >= ub = integer =
INTEGER
f andalso ub = integer =
INTEGER
f orelse ub = integer =
INTEGER

math ops (f, sh):

f + sh = max =
SINGLE
f - sh = max =
SINGLE
f * sh = max =
SINGLE
f / sh = float =
DOUBLE
f ^ sh = float =
DOUBLE
f \ sh = non-float =
INTEGER
f mod sh = non-float =
INTEGER

bitops (f, sh):

f shl sh = non-float =
INTEGER
f shr sh = non-float =
INTEGER
f and sh = non-float =
INTEGER
f or sh = non-float =
INTEGER
f xor sh = non-float =
INTEGER
f eqv sh = non-float =
INTEGER
f imp sh = non-float =
INTEGER

relational ops (f, sh):

f = sh = integer =
INTEGER
f > sh = integer =
INTEGER
f < sh = integer =
INTEGER
f <> sh = integer =
INTEGER
f <= sh = integer =
INTEGER
f >= sh = integer =
INTEGER
f andalso sh = integer =
INTEGER
f orelse sh = integer =
INTEGER

math ops (f, ush):

f + ush = max =
SINGLE
f - ush = max =
SINGLE
f * ush = max =
SINGLE
f / ush = float =
DOUBLE
f ^ ush = float =
DOUBLE
f \ ush = non-float =
INTEGER
f mod ush = non-float =
INTEGER

bitops (f, ush):

f shl ush = non-float =
INTEGER
f shr ush = non-float =
INTEGER
f and ush = non-float =
INTEGER
f or ush = non-float =
INTEGER
f xor ush = non-float =
INTEGER
f eqv ush = non-float =
INTEGER
f imp ush = non-float =
INTEGER

relational ops (f, ush):

f = ush = integer =
INTEGER
f > ush = integer =
INTEGER
f < ush = integer =
INTEGER
f <> ush = integer =
INTEGER
f <= ush = integer =
INTEGER
f >= ush = integer =
INTEGER
f andalso ush = integer =
INTEGER
f orelse ush = integer =
INTEGER

math ops (f, i):

f + i = max =
SINGLE
f - i = max =
SINGLE
f * i = max =
SINGLE
f / i = float =
DOUBLE
f ^ i = float =
DOUBLE
f \ i = non-float =
INTEGER
f mod i = non-float =
INTEGER

bitops (f, i):

f shl i = non-float =
INTEGER
f shr i = non-float =
INTEGER
f and i = non-float =
INTEGER
f or i = non-float =
INTEGER
f xor i = non-float =
INTEGER
f eqv i = non-float =
INTEGER
f imp i = non-float =
INTEGER

relational ops (f, i):

f = i = integer =
INTEGER
f > i = integer =
INTEGER
f < i = integer =
INTEGER
f <> i = integer =
INTEGER
f <= i = integer =
INTEGER
f >= i = integer =
INTEGER
f andalso i = integer =
INTEGER
f orelse i = integer =
INTEGER

math ops (f, ui):

f + ui = max =
SINGLE
f - ui = max =
SINGLE
f * ui = max =
SINGLE
f / ui = float =
DOUBLE
f ^ ui = float =
DOUBLE
f \ ui = non-float =
UINTEGER
f mod ui = non-float =
UINTEGER

bitops (f, ui):

f shl ui = non-float =
UINTEGER
f shr ui = non-float =
UINTEGER
f and ui = non-float =
UINTEGER
f or ui = non-float =
UINTEGER
f xor ui = non-float =
UINTEGER
f eqv ui = non-float =
UINTEGER
f imp ui = non-float =
UINTEGER

relational ops (f, ui):

f = ui = integer =
INTEGER
f > ui = integer =
INTEGER
f < ui = integer =
INTEGER
f <> ui = integer =
INTEGER
f <= ui = integer =
INTEGER
f >= ui = integer =
INTEGER
f andalso ui = integer =
INTEGER
f orelse ui = integer =
INTEGER

math ops (f, l):

f + l = max =
SINGLE
f - l = max =
SINGLE
f * l = max =
SINGLE
f / l = float =
DOUBLE
f ^ l = float =
DOUBLE
f \ l = non-float =
INTEGER
f mod l = non-float =
INTEGER

bitops (f, l):

f shl l = non-float =
INTEGER
f shr l = non-float =
INTEGER
f and l = non-float =
INTEGER
f or l = non-float =
INTEGER
f xor l = non-float =
INTEGER
f eqv l = non-float =
INTEGER
f imp l = non-float =
INTEGER

relational ops (f, l):

f = l = integer =
INTEGER
f > l = integer =
INTEGER
f < l = integer =
INTEGER
f <> l = integer =
INTEGER
f <= l = integer =
INTEGER
f >= l = integer =
INTEGER
f andalso l = integer =
INTEGER
f orelse l = integer =
INTEGER

math ops (f, ul):

f + ul = max =
SINGLE
f - ul = max =
SINGLE
f * ul = max =
SINGLE
f / ul = float =
DOUBLE
f ^ ul = float =
DOUBLE
f \ ul = non-float =
INTEGER
f mod ul = non-float =
INTEGER

bitops (f, ul):

f shl ul = non-float =
INTEGER
f shr ul = non-float =
INTEGER
f and ul = non-float =
INTEGER
f or ul = non-float =
INTEGER
f xor ul = non-float =
INTEGER
f eqv ul = non-float =
INTEGER
f imp ul = non-float =
INTEGER

relational ops (f, ul):

f = ul = integer =
INTEGER
f > ul = integer =
INTEGER
f < ul = integer =
INTEGER
f <> ul = integer =
INTEGER
f <= ul = integer =
INTEGER
f >= ul = integer =
INTEGER
f andalso ul = integer =
INTEGER
f orelse ul = integer =
INTEGER

math ops (f, ll):

f + ll = max =
SINGLE
f - ll = max =
SINGLE
f * ll = max =
SINGLE
f / ll = float =
DOUBLE
f ^ ll = float =
DOUBLE
f \ ll = non-float =
INTEGER
f mod ll = non-float =
INTEGER

bitops (f, ll):

f shl ll = non-float =
INTEGER
f shr ll = non-float =
INTEGER
f and ll = non-float =
INTEGER
f or ll = non-float =
INTEGER
f xor ll = non-float =
INTEGER
f eqv ll = non-float =
INTEGER
f imp ll = non-float =
INTEGER

relational ops (f, ll):

f = ll = integer =
INTEGER
f > ll = integer =
INTEGER
f < ll = integer =
INTEGER
f <> ll = integer =
INTEGER
f <= ll = integer =
INTEGER
f >= ll = integer =
INTEGER
f andalso ll = integer =
INTEGER
f orelse ll = integer =
INTEGER

math ops (f, ull):

f + ull = max =
SINGLE
f - ull = max =
SINGLE
f * ull = max =
SINGLE
f / ull = float =
DOUBLE
f ^ ull = float =
DOUBLE
f \ ull = non-float =
UINTEGER
f mod ull = non-float =
UINTEGER

bitops (f, ull):

f shl ull = non-float =
UINTEGER
f shr ull = non-float =
UINTEGER
f and ull = non-float =
UINTEGER
f or ull = non-float =
UINTEGER
f xor ull = non-float =
UINTEGER
f eqv ull = non-float =
UINTEGER
f imp ull = non-float =
UINTEGER

relational ops (f, ull):

f = ull = integer =
INTEGER
f > ull = integer =
INTEGER
f < ull = integer =
INTEGER
f <> ull = integer =
INTEGER
f <= ull = integer =
INTEGER
f >= ull = integer =
INTEGER
f andalso ull = integer =
INTEGER
f orelse ull = integer =
INTEGER

math ops (f, enum1a):

f + enum1a = max =
SINGLE
f - enum1a = max =
SINGLE
f * enum1a = max =
SINGLE
f / enum1a = float =
DOUBLE
f ^ enum1a = float =
DOUBLE
f \ enum1a = non-float =
INTEGER
f mod enum1a = non-float =
INTEGER

bitops (f, enum1a):

f shl enum1a = non-float =
INTEGER
f shr enum1a = non-float =
INTEGER
f and enum1a = non-float =
INTEGER
f or enum1a = non-float =
INTEGER
f xor enum1a = non-float =
INTEGER
f eqv enum1a = non-float =
INTEGER
f imp enum1a = non-float =
INTEGER

relational ops (f, enum1a):

f = enum1a = integer =
INTEGER
f > enum1a = integer =
INTEGER
f < enum1a = integer =
INTEGER
f <> enum1a = integer =
INTEGER
f <= enum1a = integer =
INTEGER
f >= enum1a = integer =
INTEGER
f andalso enum1a = integer =
INTEGER
f orelse enum1a = integer =
INTEGER

math ops (b, f):

b + f = max =
SINGLE
b - f = max =
SINGLE
b * f = max =
SINGLE
b / f = float =
DOUBLE
b ^ f = float =
DOUBLE
b \ f = non-float =
INTEGER
b mod f = non-float =
INTEGER

bitops (b, f):

b shl f = non-float =
INTEGER
b shr f = non-float =
INTEGER
b and f = non-float =
INTEGER
b or f = non-float =
INTEGER
b xor f = non-float =
INTEGER
b eqv f = non-float =
INTEGER
b imp f = non-float =
INTEGER

relational ops (b, f):

b = f = integer =
INTEGER
b > f = integer =
INTEGER
b < f = integer =
INTEGER
b <> f = integer =
INTEGER
b <= f = integer =
INTEGER
b >= f = integer =
INTEGER
b andalso f = integer =
INTEGER
b orelse f = integer =
INTEGER

math ops (ub, f):

ub + f = max =
SINGLE
ub - f = max =
SINGLE
ub * f = max =
SINGLE
ub / f = float =
DOUBLE
ub ^ f = float =
DOUBLE
ub \ f = non-float =
INTEGER
ub mod f = non-float =
INTEGER

bitops (ub, f):

ub shl f = non-float =
INTEGER
ub shr f = non-float =
INTEGER
ub and f = non-float =
INTEGER
ub or f = non-float =
INTEGER
ub xor f = non-float =
INTEGER
ub eqv f = non-float =
INTEGER
ub imp f = non-float =
INTEGER

relational ops (ub, f):

ub = f = integer =
INTEGER
ub > f = integer =
INTEGER
ub < f = integer =
INTEGER
ub <> f = integer =
INTEGER
ub <= f = integer =
INTEGER
ub >= f = integer =
INTEGER
ub andalso f = integer =
INTEGER
ub orelse f = integer =
INTEGER

math ops (sh, f):

sh + f = max =
SINGLE
sh - f = max =
SINGLE
sh * f = max =
SINGLE
sh / f = float =
DOUBLE
sh ^ f = float =
DOUBLE
sh \ f = non-float =
INTEGER
sh mod f = non-float =
INTEGER

bitops (sh, f):

sh shl f = non-float =
INTEGER
sh shr f = non-float =
INTEGER
sh and f = non-float =
INTEGER
sh or f = non-float =
INTEGER
sh xor f = non-float =
INTEGER
sh eqv f = non-float =
INTEGER
sh imp f = non-float =
INTEGER

relational ops (sh, f):

sh = f = integer =
INTEGER
sh > f = integer =
INTEGER
sh < f = integer =
INTEGER
sh <> f = integer =
INTEGER
sh <= f = integer =
INTEGER
sh >= f = integer =
INTEGER
sh andalso f = integer =
INTEGER
sh orelse f = integer =
INTEGER

math ops (ush, f):

ush + f = max =
SINGLE
ush - f = max =
SINGLE
ush * f = max =
SINGLE
ush / f = float =
DOUBLE
ush ^ f = float =
DOUBLE
ush \ f = non-float =
INTEGER
ush mod f = non-float =
INTEGER

bitops (ush, f):

ush shl f = non-float =
INTEGER
ush shr f = non-float =
INTEGER
ush and f = non-float =
INTEGER
ush or f = non-float =
INTEGER
ush xor f = non-float =
INTEGER
ush eqv f = non-float =
INTEGER
ush imp f = non-float =
INTEGER

relational ops (ush, f):

ush = f = integer =
INTEGER
ush > f = integer =
INTEGER
ush < f = integer =
INTEGER
ush <> f = integer =
INTEGER
ush <= f = integer =
INTEGER
ush >= f = integer =
INTEGER
ush andalso f = integer =
INTEGER
ush orelse f = integer =
INTEGER

math ops (i, f):

i + f = max =
SINGLE
i - f = max =
SINGLE
i * f = max =
SINGLE
i / f = float =
DOUBLE
i ^ f = float =
DOUBLE
i \ f = non-float =
INTEGER
i mod f = non-float =
INTEGER

bitops (i, f):

i shl f = non-float =
INTEGER
i shr f = non-float =
INTEGER
i and f = non-float =
INTEGER
i or f = non-float =
INTEGER
i xor f = non-float =
INTEGER
i eqv f = non-float =
INTEGER
i imp f = non-float =
INTEGER

relational ops (i, f):

i = f = integer =
INTEGER
i > f = integer =
INTEGER
i < f = integer =
INTEGER
i <> f = integer =
INTEGER
i <= f = integer =
INTEGER
i >= f = integer =
INTEGER
i andalso f = integer =
INTEGER
i orelse f = integer =
INTEGER

math ops (ui, f):

ui + f = max =
SINGLE
ui - f = max =
SINGLE
ui * f = max =
SINGLE
ui / f = float =
DOUBLE
ui ^ f = float =
DOUBLE
ui \ f = non-float =
UINTEGER
ui mod f = non-float =
UINTEGER

bitops (ui, f):

ui shl f = non-float =
UINTEGER
ui shr f = non-float =
UINTEGER
ui and f = non-float =
UINTEGER
ui or f = non-float =
UINTEGER
ui xor f = non-float =
UINTEGER
ui eqv f = non-float =
UINTEGER
ui imp f = non-float =
UINTEGER

relational ops (ui, f):

ui = f = integer =
INTEGER
ui > f = integer =
INTEGER
ui < f = integer =
INTEGER
ui <> f = integer =
INTEGER
ui <= f = integer =
INTEGER
ui >= f = integer =
INTEGER
ui andalso f = integer =
INTEGER
ui orelse f = integer =
INTEGER

math ops (l, f):

l + f = max =
SINGLE
l - f = max =
SINGLE
l * f = max =
SINGLE
l / f = float =
DOUBLE
l ^ f = float =
DOUBLE
l \ f = non-float =
INTEGER
l mod f = non-float =
INTEGER

bitops (l, f):

l shl f = non-float =
INTEGER
l shr f = non-float =
INTEGER
l and f = non-float =
INTEGER
l or f = non-float =
INTEGER
l xor f = non-float =
INTEGER
l eqv f = non-float =
INTEGER
l imp f = non-float =
INTEGER

relational ops (l, f):

l = f = integer =
INTEGER
l > f = integer =
INTEGER
l < f = integer =
INTEGER
l <> f = integer =
INTEGER
l <= f = integer =
INTEGER
l >= f = integer =
INTEGER
l andalso f = integer =
INTEGER
l orelse f = integer =
INTEGER

math ops (ul, f):

ul + f = max =
SINGLE
ul - f = max =
SINGLE
ul * f = max =
SINGLE
ul / f = float =
DOUBLE
ul ^ f = float =
DOUBLE
ul \ f = non-float =
INTEGER
ul mod f = non-float =
INTEGER

bitops (ul, f):

ul shl f = non-float =
INTEGER
ul shr f = non-float =
INTEGER
ul and f = non-float =
INTEGER
ul or f = non-float =
INTEGER
ul xor f = non-float =
INTEGER
ul eqv f = non-float =
INTEGER
ul imp f = non-float =
INTEGER

relational ops (ul, f):

ul = f = integer =
INTEGER
ul > f = integer =
INTEGER
ul < f = integer =
INTEGER
ul <> f = integer =
INTEGER
ul <= f = integer =
INTEGER
ul >= f = integer =
INTEGER
ul andalso f = integer =
INTEGER
ul orelse f = integer =
INTEGER

math ops (ll, f):

ll + f = max =
SINGLE
ll - f = max =
SINGLE
ll * f = max =
SINGLE
ll / f = float =
DOUBLE
ll ^ f = float =
DOUBLE
ll \ f = non-float =
INTEGER
ll mod f = non-float =
INTEGER

bitops (ll, f):

ll shl f = non-float =
INTEGER
ll shr f = non-float =
INTEGER
ll and f = non-float =
INTEGER
ll or f = non-float =
INTEGER
ll xor f = non-float =
INTEGER
ll eqv f = non-float =
INTEGER
ll imp f = non-float =
INTEGER

relational ops (ll, f):

ll = f = integer =
INTEGER
ll > f = integer =
INTEGER
ll < f = integer =
INTEGER
ll <> f = integer =
INTEGER
ll <= f = integer =
INTEGER
ll >= f = integer =
INTEGER
ll andalso f = integer =
INTEGER
ll orelse f = integer =
INTEGER

math ops (ull, f):

ull + f = max =
SINGLE
ull - f = max =
SINGLE
ull * f = max =
SINGLE
ull / f = float =
DOUBLE
ull ^ f = float =
DOUBLE
ull \ f = non-float =
UINTEGER
ull mod f = non-float =
UINTEGER

bitops (ull, f):

ull shl f = non-float =
UINTEGER
ull shr f = non-float =
UINTEGER
ull and f = non-float =
UINTEGER
ull or f = non-float =
UINTEGER
ull xor f = non-float =
UINTEGER
ull eqv f = non-float =
UINTEGER
ull imp f = non-float =
UINTEGER

relational ops (ull, f):

ull = f = integer =
INTEGER
ull > f = integer =
INTEGER
ull < f = integer =
INTEGER
ull <> f = integer =
INTEGER
ull <= f = integer =
INTEGER
ull >= f = integer =
INTEGER
ull andalso f = integer =
INTEGER
ull orelse f = integer =
INTEGER

math ops (enum1a, f):

enum1a + f = max =
SINGLE
enum1a - f = max =
SINGLE
enum1a * f = max =
SINGLE
enum1a / f = float =
DOUBLE
enum1a ^ f = float =
DOUBLE
enum1a \ f = non-float =
INTEGER
enum1a mod f = non-float =
INTEGER

bitops (enum1a, f):

enum1a shl f = non-float =
INTEGER
enum1a shr f = non-float =
INTEGER
enum1a and f = non-float =
INTEGER
enum1a or f = non-float =
INTEGER
enum1a xor f = non-float =
INTEGER
enum1a eqv f = non-float =
INTEGER
enum1a imp f = non-float =
INTEGER

relational ops (enum1a, f):

enum1a = f = integer =
INTEGER
enum1a > f = integer =
INTEGER
enum1a < f = integer =
INTEGER
enum1a <> f = integer =
INTEGER
enum1a <= f = integer =
INTEGER
enum1a >= f = integer =
INTEGER
enum1a andalso f = integer =
INTEGER
enum1a orelse f = integer =
INTEGER

math ops (f, f):

f + f = max =
SINGLE
f - f = max =
SINGLE
f * f = max =
SINGLE
f / f = float =
SINGLE
f ^ f = float =
DOUBLE
f \ f = non-float =
INTEGER
f mod f = non-float =
INTEGER

bitops (f, f):

f shl f = non-float =
INTEGER
f shr f = non-float =
INTEGER
f and f = non-float =
INTEGER
f or f = non-float =
INTEGER
f xor f = non-float =
INTEGER
f eqv f = non-float =
INTEGER
f imp f = non-float =
INTEGER

relational ops (f, f):

f = f = integer =
INTEGER
f > f = integer =
INTEGER
f < f = integer =
INTEGER
f <> f = integer =
INTEGER
f <= f = integer =
INTEGER
f >= f = integer =
INTEGER
f andalso f = integer =
INTEGER
f orelse f = integer =
INTEGER

math ops (f, d):

f + d = max =
DOUBLE
f - d = max =
DOUBLE
f * d = max =
DOUBLE
f / d = float =
DOUBLE
f ^ d = float =
DOUBLE
f \ d = non-float =
INTEGER
f mod d = non-float =
INTEGER

bitops (f, d):

f shl d = non-float =
INTEGER
f shr d = non-float =
INTEGER
f and d = non-float =
INTEGER
f or d = non-float =
INTEGER
f xor d = non-float =
INTEGER
f eqv d = non-float =
INTEGER
f imp d = non-float =
INTEGER

relational ops (f, d):

f = d = integer =
INTEGER
f > d = integer =
INTEGER
f < d = integer =
INTEGER
f <> d = integer =
INTEGER
f <= d = integer =
INTEGER
f >= d = integer =
INTEGER
f andalso d = integer =
INTEGER
f orelse d = integer =
INTEGER

math ops (f, f):

f + f = max =
SINGLE
f - f = max =
SINGLE
f * f = max =
SINGLE
f / f = float =
SINGLE
f ^ f = float =
DOUBLE
f \ f = non-float =
INTEGER
f mod f = non-float =
INTEGER

bitops (f, f):

f shl f = non-float =
INTEGER
f shr f = non-float =
INTEGER
f and f = non-float =
INTEGER
f or f = non-float =
INTEGER
f xor f = non-float =
INTEGER
f eqv f = non-float =
INTEGER
f imp f = non-float =
INTEGER

relational ops (f, f):

f = f = integer =
INTEGER
f > f = integer =
INTEGER
f < f = integer =
INTEGER
f <> f = integer =
INTEGER
f <= f = integer =
INTEGER
f >= f = integer =
INTEGER
f andalso f = integer =
INTEGER
f orelse f = integer =
INTEGER

math ops (d, f):

d + f = max =
DOUBLE
d - f = max =
DOUBLE
d * f = max =
DOUBLE
d / f = float =
DOUBLE
d ^ f = float =
DOUBLE
d \ f = non-float =
INTEGER
d mod f = non-float =
INTEGER

bitops (d, f):

d shl f = non-float =
INTEGER
d shr f = non-float =
INTEGER
d and f = non-float =
INTEGER
d or f = non-float =
INTEGER
d xor f = non-float =
INTEGER
d eqv f = non-float =
INTEGER
d imp f = non-float =
INTEGER

relational ops (d, f):

d = f = integer =
INTEGER
d > f = integer =
INTEGER
d < f = integer =
INTEGER
d <> f = integer =
INTEGER
d <= f = integer =
INTEGER
d >= f = integer =
INTEGER
d andalso f = integer =
INTEGER
d orelse f = integer =
INTEGER

----- d -----------------------------------------------------


math ops (d, b):

d + b = max =
DOUBLE
d - b = max =
DOUBLE
d * b = max =
DOUBLE
d / b = float =
DOUBLE
d ^ b = float =
DOUBLE
d \ b = non-float =
INTEGER
d mod b = non-float =
INTEGER

bitops (d, b):

d shl b = non-float =
INTEGER
d shr b = non-float =
INTEGER
d and b = non-float =
INTEGER
d or b = non-float =
INTEGER
d xor b = non-float =
INTEGER
d eqv b = non-float =
INTEGER
d imp b = non-float =
INTEGER

relational ops (d, b):

d = b = integer =
INTEGER
d > b = integer =
INTEGER
d < b = integer =
INTEGER
d <> b = integer =
INTEGER
d <= b = integer =
INTEGER
d >= b = integer =
INTEGER
d andalso b = integer =
INTEGER
d orelse b = integer =
INTEGER

math ops (d, ub):

d + ub = max =
DOUBLE
d - ub = max =
DOUBLE
d * ub = max =
DOUBLE
d / ub = float =
DOUBLE
d ^ ub = float =
DOUBLE
d \ ub = non-float =
INTEGER
d mod ub = non-float =
INTEGER

bitops (d, ub):

d shl ub = non-float =
INTEGER
d shr ub = non-float =
INTEGER
d and ub = non-float =
INTEGER
d or ub = non-float =
INTEGER
d xor ub = non-float =
INTEGER
d eqv ub = non-float =
INTEGER
d imp ub = non-float =
INTEGER

relational ops (d, ub):

d = ub = integer =
INTEGER
d > ub = integer =
INTEGER
d < ub = integer =
INTEGER
d <> ub = integer =
INTEGER
d <= ub = integer =
INTEGER
d >= ub = integer =
INTEGER
d andalso ub = integer =
INTEGER
d orelse ub = integer =
INTEGER

math ops (d, sh):

d + sh = max =
DOUBLE
d - sh = max =
DOUBLE
d * sh = max =
DOUBLE
d / sh = float =
DOUBLE
d ^ sh = float =
DOUBLE
d \ sh = non-float =
INTEGER
d mod sh = non-float =
INTEGER

bitops (d, sh):

d shl sh = non-float =
INTEGER
d shr sh = non-float =
INTEGER
d and sh = non-float =
INTEGER
d or sh = non-float =
INTEGER
d xor sh = non-float =
INTEGER
d eqv sh = non-float =
INTEGER
d imp sh = non-float =
INTEGER

relational ops (d, sh):

d = sh = integer =
INTEGER
d > sh = integer =
INTEGER
d < sh = integer =
INTEGER
d <> sh = integer =
INTEGER
d <= sh = integer =
INTEGER
d >= sh = integer =
INTEGER
d andalso sh = integer =
INTEGER
d orelse sh = integer =
INTEGER

math ops (d, ush):

d + ush = max =
DOUBLE
d - ush = max =
DOUBLE
d * ush = max =
DOUBLE
d / ush = float =
DOUBLE
d ^ ush = float =
DOUBLE
d \ ush = non-float =
INTEGER
d mod ush = non-float =
INTEGER

bitops (d, ush):

d shl ush = non-float =
INTEGER
d shr ush = non-float =
INTEGER
d and ush = non-float =
INTEGER
d or ush = non-float =
INTEGER
d xor ush = non-float =
INTEGER
d eqv ush = non-float =
INTEGER
d imp ush = non-float =
INTEGER

relational ops (d, ush):

d = ush = integer =
INTEGER
d > ush = integer =
INTEGER
d < ush = integer =
INTEGER
d <> ush = integer =
INTEGER
d <= ush = integer =
INTEGER
d >= ush = integer =
INTEGER
d andalso ush = integer =
INTEGER
d orelse ush = integer =
INTEGER

math ops (d, i):

d + i = max =
DOUBLE
d - i = max =
DOUBLE
d * i = max =
DOUBLE
d / i = float =
DOUBLE
d ^ i = float =
DOUBLE
d \ i = non-float =
INTEGER
d mod i = non-float =
INTEGER

bitops (d, i):

d shl i = non-float =
INTEGER
d shr i = non-float =
INTEGER
d and i = non-float =
INTEGER
d or i = non-float =
INTEGER
d xor i = non-float =
INTEGER
d eqv i = non-float =
INTEGER
d imp i = non-float =
INTEGER

relational ops (d, i):

d = i = integer =
INTEGER
d > i = integer =
INTEGER
d < i = integer =
INTEGER
d <> i = integer =
INTEGER
d <= i = integer =
INTEGER
d >= i = integer =
INTEGER
d andalso i = integer =
INTEGER
d orelse i = integer =
INTEGER

math ops (d, ui):

d + ui = max =
DOUBLE
d - ui = max =
DOUBLE
d * ui = max =
DOUBLE
d / ui = float =
DOUBLE
d ^ ui = float =
DOUBLE
d \ ui = non-float =
UINTEGER
d mod ui = non-float =
UINTEGER

bitops (d, ui):

d shl ui = non-float =
UINTEGER
d shr ui = non-float =
UINTEGER
d and ui = non-float =
UINTEGER
d or ui = non-float =
UINTEGER
d xor ui = non-float =
UINTEGER
d eqv ui = non-float =
UINTEGER
d imp ui = non-float =
UINTEGER

relational ops (d, ui):

d = ui = integer =
INTEGER
d > ui = integer =
INTEGER
d < ui = integer =
INTEGER
d <> ui = integer =
INTEGER
d <= ui = integer =
INTEGER
d >= ui = integer =
INTEGER
d andalso ui = integer =
INTEGER
d orelse ui = integer =
INTEGER

math ops (d, l):

d + l = max =
DOUBLE
d - l = max =
DOUBLE
d * l = max =
DOUBLE
d / l = float =
DOUBLE
d ^ l = float =
DOUBLE
d \ l = non-float =
INTEGER
d mod l = non-float =
INTEGER

bitops (d, l):

d shl l = non-float =
INTEGER
d shr l = non-float =
INTEGER
d and l = non-float =
INTEGER
d or l = non-float =
INTEGER
d xor l = non-float =
INTEGER
d eqv l = non-float =
INTEGER
d imp l = non-float =
INTEGER

relational ops (d, l):

d = l = integer =
INTEGER
d > l = integer =
INTEGER
d < l = integer =
INTEGER
d <> l = integer =
INTEGER
d <= l = integer =
INTEGER
d >= l = integer =
INTEGER
d andalso l = integer =
INTEGER
d orelse l = integer =
INTEGER

math ops (d, ul):

d + ul = max =
DOUBLE
d - ul = max =
DOUBLE
d * ul = max =
DOUBLE
d / ul = float =
DOUBLE
d ^ ul = float =
DOUBLE
d \ ul = non-float =
INTEGER
d mod ul = non-float =
INTEGER

bitops (d, ul):

d shl ul = non-float =
INTEGER
d shr ul = non-float =
INTEGER
d and ul = non-float =
INTEGER
d or ul = non-float =
INTEGER
d xor ul = non-float =
INTEGER
d eqv ul = non-float =
INTEGER
d imp ul = non-float =
INTEGER

relational ops (d, ul):

d = ul = integer =
INTEGER
d > ul = integer =
INTEGER
d < ul = integer =
INTEGER
d <> ul = integer =
INTEGER
d <= ul = integer =
INTEGER
d >= ul = integer =
INTEGER
d andalso ul = integer =
INTEGER
d orelse ul = integer =
INTEGER

math ops (d, ll):

d + ll = max =
DOUBLE
d - ll = max =
DOUBLE
d * ll = max =
DOUBLE
d / ll = float =
DOUBLE
d ^ ll = float =
DOUBLE
d \ ll = non-float =
INTEGER
d mod ll = non-float =
INTEGER

bitops (d, ll):

d shl ll = non-float =
INTEGER
d shr ll = non-float =
INTEGER
d and ll = non-float =
INTEGER
d or ll = non-float =
INTEGER
d xor ll = non-float =
INTEGER
d eqv ll = non-float =
INTEGER
d imp ll = non-float =
INTEGER

relational ops (d, ll):

d = ll = integer =
INTEGER
d > ll = integer =
INTEGER
d < ll = integer =
INTEGER
d <> ll = integer =
INTEGER
d <= ll = integer =
INTEGER
d >= ll = integer =
INTEGER
d andalso ll = integer =
INTEGER
d orelse ll = integer =
INTEGER

math ops (d, ull):

d + ull = max =
DOUBLE
d - ull = max =
DOUBLE
d * ull = max =
DOUBLE
d / ull = float =
DOUBLE
d ^ ull = float =
DOUBLE
d \ ull = non-float =
UINTEGER
d mod ull = non-float =
UINTEGER

bitops (d, ull):

d shl ull = non-float =
UINTEGER
d shr ull = non-float =
UINTEGER
d and ull = non-float =
UINTEGER
d or ull = non-float =
UINTEGER
d xor ull = non-float =
UINTEGER
d eqv ull = non-float =
UINTEGER
d imp ull = non-float =
UINTEGER

relational ops (d, ull):

d = ull = integer =
INTEGER
d > ull = integer =
INTEGER
d < ull = integer =
INTEGER
d <> ull = integer =
INTEGER
d <= ull = integer =
INTEGER
d >= ull = integer =
INTEGER
d andalso ull = integer =
INTEGER
d orelse ull = integer =
INTEGER

math ops (d, enum1a):

d + enum1a = max =
DOUBLE
d - enum1a = max =
DOUBLE
d * enum1a = max =
DOUBLE
d / enum1a = float =
DOUBLE
d ^ enum1a = float =
DOUBLE
d \ enum1a = non-float =
INTEGER
d mod enum1a = non-float =
INTEGER

bitops (d, enum1a):

d shl enum1a = non-float =
INTEGER
d shr enum1a = non-float =
INTEGER
d and enum1a = non-float =
INTEGER
d or enum1a = non-float =
INTEGER
d xor enum1a = non-float =
INTEGER
d eqv enum1a = non-float =
INTEGER
d imp enum1a = non-float =
INTEGER

relational ops (d, enum1a):

d = enum1a = integer =
INTEGER
d > enum1a = integer =
INTEGER
d < enum1a = integer =
INTEGER
d <> enum1a = integer =
INTEGER
d <= enum1a = integer =
INTEGER
d >= enum1a = integer =
INTEGER
d andalso enum1a = integer =
INTEGER
d orelse enum1a = integer =
INTEGER

math ops (b, d):

b + d = max =
DOUBLE
b - d = max =
DOUBLE
b * d = max =
DOUBLE
b / d = float =
DOUBLE
b ^ d = float =
DOUBLE
b \ d = non-float =
INTEGER
b mod d = non-float =
INTEGER

bitops (b, d):

b shl d = non-float =
INTEGER
b shr d = non-float =
INTEGER
b and d = non-float =
INTEGER
b or d = non-float =
INTEGER
b xor d = non-float =
INTEGER
b eqv d = non-float =
INTEGER
b imp d = non-float =
INTEGER

relational ops (b, d):

b = d = integer =
INTEGER
b > d = integer =
INTEGER
b < d = integer =
INTEGER
b <> d = integer =
INTEGER
b <= d = integer =
INTEGER
b >= d = integer =
INTEGER
b andalso d = integer =
INTEGER
b orelse d = integer =
INTEGER

math ops (ub, d):

ub + d = max =
DOUBLE
ub - d = max =
DOUBLE
ub * d = max =
DOUBLE
ub / d = float =
DOUBLE
ub ^ d = float =
DOUBLE
ub \ d = non-float =
INTEGER
ub mod d = non-float =
INTEGER

bitops (ub, d):

ub shl d = non-float =
INTEGER
ub shr d = non-float =
INTEGER
ub and d = non-float =
INTEGER
ub or d = non-float =
INTEGER
ub xor d = non-float =
INTEGER
ub eqv d = non-float =
INTEGER
ub imp d = non-float =
INTEGER

relational ops (ub, d):

ub = d = integer =
INTEGER
ub > d = integer =
INTEGER
ub < d = integer =
INTEGER
ub <> d = integer =
INTEGER
ub <= d = integer =
INTEGER
ub >= d = integer =
INTEGER
ub andalso d = integer =
INTEGER
ub orelse d = integer =
INTEGER

math ops (sh, d):

sh + d = max =
DOUBLE
sh - d = max =
DOUBLE
sh * d = max =
DOUBLE
sh / d = float =
DOUBLE
sh ^ d = float =
DOUBLE
sh \ d = non-float =
INTEGER
sh mod d = non-float =
INTEGER

bitops (sh, d):

sh shl d = non-float =
INTEGER
sh shr d = non-float =
INTEGER
sh and d = non-float =
INTEGER
sh or d = non-float =
INTEGER
sh xor d = non-float =
INTEGER
sh eqv d = non-float =
INTEGER
sh imp d = non-float =
INTEGER

relational ops (sh, d):

sh = d = integer =
INTEGER
sh > d = integer =
INTEGER
sh < d = integer =
INTEGER
sh <> d = integer =
INTEGER
sh <= d = integer =
INTEGER
sh >= d = integer =
INTEGER
sh andalso d = integer =
INTEGER
sh orelse d = integer =
INTEGER

math ops (ush, d):

ush + d = max =
DOUBLE
ush - d = max =
DOUBLE
ush * d = max =
DOUBLE
ush / d = float =
DOUBLE
ush ^ d = float =
DOUBLE
ush \ d = non-float =
INTEGER
ush mod d = non-float =
INTEGER

bitops (ush, d):

ush shl d = non-float =
INTEGER
ush shr d = non-float =
INTEGER
ush and d = non-float =
INTEGER
ush or d = non-float =
INTEGER
ush xor d = non-float =
INTEGER
ush eqv d = non-float =
INTEGER
ush imp d = non-float =
INTEGER

relational ops (ush, d):

ush = d = integer =
INTEGER
ush > d = integer =
INTEGER
ush < d = integer =
INTEGER
ush <> d = integer =
INTEGER
ush <= d = integer =
INTEGER
ush >= d = integer =
INTEGER
ush andalso d = integer =
INTEGER
ush orelse d = integer =
INTEGER

math ops (i, d):

i + d = max =
DOUBLE
i - d = max =
DOUBLE
i * d = max =
DOUBLE
i / d = float =
DOUBLE
i ^ d = float =
DOUBLE
i \ d = non-float =
INTEGER
i mod d = non-float =
INTEGER

bitops (i, d):

i shl d = non-float =
INTEGER
i shr d = non-float =
INTEGER
i and d = non-float =
INTEGER
i or d = non-float =
INTEGER
i xor d = non-float =
INTEGER
i eqv d = non-float =
INTEGER
i imp d = non-float =
INTEGER

relational ops (i, d):

i = d = integer =
INTEGER
i > d = integer =
INTEGER
i < d = integer =
INTEGER
i <> d = integer =
INTEGER
i <= d = integer =
INTEGER
i >= d = integer =
INTEGER
i andalso d = integer =
INTEGER
i orelse d = integer =
INTEGER

math ops (ui, d):

ui + d = max =
DOUBLE
ui - d = max =
DOUBLE
ui * d = max =
DOUBLE
ui / d = float =
DOUBLE
ui ^ d = float =
DOUBLE
ui \ d = non-float =
UINTEGER
ui mod d = non-float =
UINTEGER

bitops (ui, d):

ui shl d = non-float =
UINTEGER
ui shr d = non-float =
UINTEGER
ui and d = non-float =
UINTEGER
ui or d = non-float =
UINTEGER
ui xor d = non-float =
UINTEGER
ui eqv d = non-float =
UINTEGER
ui imp d = non-float =
UINTEGER

relational ops (ui, d):

ui = d = integer =
INTEGER
ui > d = integer =
INTEGER
ui < d = integer =
INTEGER
ui <> d = integer =
INTEGER
ui <= d = integer =
INTEGER
ui >= d = integer =
INTEGER
ui andalso d = integer =
INTEGER
ui orelse d = integer =
INTEGER

math ops (l, d):

l + d = max =
DOUBLE
l - d = max =
DOUBLE
l * d = max =
DOUBLE
l / d = float =
DOUBLE
l ^ d = float =
DOUBLE
l \ d = non-float =
INTEGER
l mod d = non-float =
INTEGER

bitops (l, d):

l shl d = non-float =
INTEGER
l shr d = non-float =
INTEGER
l and d = non-float =
INTEGER
l or d = non-float =
INTEGER
l xor d = non-float =
INTEGER
l eqv d = non-float =
INTEGER
l imp d = non-float =
INTEGER

relational ops (l, d):

l = d = integer =
INTEGER
l > d = integer =
INTEGER
l < d = integer =
INTEGER
l <> d = integer =
INTEGER
l <= d = integer =
INTEGER
l >= d = integer =
INTEGER
l andalso d = integer =
INTEGER
l orelse d = integer =
INTEGER

math ops (ul, d):

ul + d = max =
DOUBLE
ul - d = max =
DOUBLE
ul * d = max =
DOUBLE
ul / d = float =
DOUBLE
ul ^ d = float =
DOUBLE
ul \ d = non-float =
INTEGER
ul mod d = non-float =
INTEGER

bitops (ul, d):

ul shl d = non-float =
INTEGER
ul shr d = non-float =
INTEGER
ul and d = non-float =
INTEGER
ul or d = non-float =
INTEGER
ul xor d = non-float =
INTEGER
ul eqv d = non-float =
INTEGER
ul imp d = non-float =
INTEGER

relational ops (ul, d):

ul = d = integer =
INTEGER
ul > d = integer =
INTEGER
ul < d = integer =
INTEGER
ul <> d = integer =
INTEGER
ul <= d = integer =
INTEGER
ul >= d = integer =
INTEGER
ul andalso d = integer =
INTEGER
ul orelse d = integer =
INTEGER

math ops (ll, d):

ll + d = max =
DOUBLE
ll - d = max =
DOUBLE
ll * d = max =
DOUBLE
ll / d = float =
DOUBLE
ll ^ d = float =
DOUBLE
ll \ d = non-float =
INTEGER
ll mod d = non-float =
INTEGER

bitops (ll, d):

ll shl d = non-float =
INTEGER
ll shr d = non-float =
INTEGER
ll and d = non-float =
INTEGER
ll or d = non-float =
INTEGER
ll xor d = non-float =
INTEGER
ll eqv d = non-float =
INTEGER
ll imp d = non-float =
INTEGER

relational ops (ll, d):

ll = d = integer =
INTEGER
ll > d = integer =
INTEGER
ll < d = integer =
INTEGER
ll <> d = integer =
INTEGER
ll <= d = integer =
INTEGER
ll >= d = integer =
INTEGER
ll andalso d = integer =
INTEGER
ll orelse d = integer =
INTEGER

math ops (ull, d):

ull + d = max =
DOUBLE
ull - d = max =
DOUBLE
ull * d = max =
DOUBLE
ull / d = float =
DOUBLE
ull ^ d = float =
DOUBLE
ull \ d = non-float =
UINTEGER
ull mod d = non-float =
UINTEGER

bitops (ull, d):

ull shl d = non-float =
UINTEGER
ull shr d = non-float =
UINTEGER
ull and d = non-float =
UINTEGER
ull or d = non-float =
UINTEGER
ull xor d = non-float =
UINTEGER
ull eqv d = non-float =
UINTEGER
ull imp d = non-float =
UINTEGER

relational ops (ull, d):

ull = d = integer =
INTEGER
ull > d = integer =
INTEGER
ull < d = integer =
INTEGER
ull <> d = integer =
INTEGER
ull <= d = integer =
INTEGER
ull >= d = integer =
INTEGER
ull andalso d = integer =
INTEGER
ull orelse d = integer =
INTEGER

math ops (enum1a, d):

enum1a + d = max =
DOUBLE
enum1a - d = max =
DOUBLE
enum1a * d = max =
DOUBLE
enum1a / d = float =
DOUBLE
enum1a ^ d = float =
DOUBLE
enum1a \ d = non-float =
INTEGER
enum1a mod d = non-float =
INTEGER

bitops (enum1a, d):

enum1a shl d = non-float =
INTEGER
enum1a shr d = non-float =
INTEGER
enum1a and d = non-float =
INTEGER
enum1a or d = non-float =
INTEGER
enum1a xor d = non-float =
INTEGER
enum1a eqv d = non-float =
INTEGER
enum1a imp d = non-float =
INTEGER

relational ops (enum1a, d):

enum1a = d = integer =
INTEGER
enum1a > d = integer =
INTEGER
enum1a < d = integer =
INTEGER
enum1a <> d = integer =
INTEGER
enum1a <= d = integer =
INTEGER
enum1a >= d = integer =
INTEGER
enum1a andalso d = integer =
INTEGER
enum1a orelse d = integer =
INTEGER

math ops (d, f):

d + f = max =
DOUBLE
d - f = max =
DOUBLE
d * f = max =
DOUBLE
d / f = float =
DOUBLE
d ^ f = float =
DOUBLE
d \ f = non-float =
INTEGER
d mod f = non-float =
INTEGER

bitops (d, f):

d shl f = non-float =
INTEGER
d shr f = non-float =
INTEGER
d and f = non-float =
INTEGER
d or f = non-float =
INTEGER
d xor f = non-float =
INTEGER
d eqv f = non-float =
INTEGER
d imp f = non-float =
INTEGER

relational ops (d, f):

d = f = integer =
INTEGER
d > f = integer =
INTEGER
d < f = integer =
INTEGER
d <> f = integer =
INTEGER
d <= f = integer =
INTEGER
d >= f = integer =
INTEGER
d andalso f = integer =
INTEGER
d orelse f = integer =
INTEGER

math ops (d, d):

d + d = max =
DOUBLE
d - d = max =
DOUBLE
d * d = max =
DOUBLE
d / d = float =
DOUBLE
d ^ d = float =
DOUBLE
d \ d = non-float =
INTEGER
d mod d = non-float =
INTEGER

bitops (d, d):

d shl d = non-float =
INTEGER
d shr d = non-float =
INTEGER
d and d = non-float =
INTEGER
d or d = non-float =
INTEGER
d xor d = non-float =
INTEGER
d eqv d = non-float =
INTEGER
d imp d = non-float =
INTEGER

relational ops (d, d):

d = d = integer =
INTEGER
d > d = integer =
INTEGER
d < d = integer =
INTEGER
d <> d = integer =
INTEGER
d <= d = integer =
INTEGER
d >= d = integer =
INTEGER
d andalso d = integer =
INTEGER
d orelse d = integer =
INTEGER

math ops (f, d):

f + d = max =
DOUBLE
f - d = max =
DOUBLE
f * d = max =
DOUBLE
f / d = float =
DOUBLE
f ^ d = float =
DOUBLE
f \ d = non-float =
INTEGER
f mod d = non-float =
INTEGER

bitops (f, d):

f shl d = non-float =
INTEGER
f shr d = non-float =
INTEGER
f and d = non-float =
INTEGER
f or d = non-float =
INTEGER
f xor d = non-float =
INTEGER
f eqv d = non-float =
INTEGER
f imp d = non-float =
INTEGER

relational ops (f, d):

f = d = integer =
INTEGER
f > d = integer =
INTEGER
f < d = integer =
INTEGER
f <> d = integer =
INTEGER
f <= d = integer =
INTEGER
f >= d = integer =
INTEGER
f andalso d = integer =
INTEGER
f orelse d = integer =
INTEGER

math ops (d, d):

d + d = max =
DOUBLE
d - d = max =
DOUBLE
d * d = max =
DOUBLE
d / d = float =
DOUBLE
d ^ d = float =
DOUBLE
d \ d = non-float =
INTEGER
d mod d = non-float =
INTEGER

bitops (d, d):

d shl d = non-float =
INTEGER
d shr d = non-float =
INTEGER
d and d = non-float =
INTEGER
d or d = non-float =
INTEGER
d xor d = non-float =
INTEGER
d eqv d = non-float =
INTEGER
d imp d = non-float =
INTEGER

relational ops (d, d):

d = d = integer =
INTEGER
d > d = integer =
INTEGER
d < d = integer =
INTEGER
d <> d = integer =
INTEGER
d <= d = integer =
INTEGER
d >= d = integer =
INTEGER
d andalso d = integer =
INTEGER
d orelse d = integer =
INTEGER

----------------------------------------------------------------------
enums:
----------------------------------------------------------------------


----- enum1a -----------------------------------------------------


math ops (enum1a, b):

enum1a + b = max =
INTEGER
enum1a - b = max =
INTEGER
enum1a * b = max =
INTEGER
enum1a / b = float =
DOUBLE
enum1a ^ b = float =
DOUBLE
enum1a \ b = non-float =
INTEGER
enum1a mod b = non-float =
INTEGER

bitops (enum1a, b):

enum1a shl b = non-float =
INTEGER
enum1a shr b = non-float =
INTEGER
enum1a and b = non-float =
INTEGER
enum1a or b = non-float =
INTEGER
enum1a xor b = non-float =
INTEGER
enum1a eqv b = non-float =
INTEGER
enum1a imp b = non-float =
INTEGER

relational ops (enum1a, b):

enum1a = b = integer =
INTEGER
enum1a > b = integer =
INTEGER
enum1a < b = integer =
INTEGER
enum1a <> b = integer =
INTEGER
enum1a <= b = integer =
INTEGER
enum1a >= b = integer =
INTEGER
enum1a andalso b = integer =
INTEGER
enum1a orelse b = integer =
INTEGER

math ops (enum1a, ub):

enum1a + ub = max =
INTEGER
enum1a - ub = max =
INTEGER
enum1a * ub = max =
INTEGER
enum1a / ub = float =
DOUBLE
enum1a ^ ub = float =
DOUBLE
enum1a \ ub = non-float =
INTEGER
enum1a mod ub = non-float =
INTEGER

bitops (enum1a, ub):

enum1a shl ub = non-float =
INTEGER
enum1a shr ub = non-float =
INTEGER
enum1a and ub = non-float =
INTEGER
enum1a or ub = non-float =
INTEGER
enum1a xor ub = non-float =
INTEGER
enum1a eqv ub = non-float =
INTEGER
enum1a imp ub = non-float =
INTEGER

relational ops (enum1a, ub):

enum1a = ub = integer =
INTEGER
enum1a > ub = integer =
INTEGER
enum1a < ub = integer =
INTEGER
enum1a <> ub = integer =
INTEGER
enum1a <= ub = integer =
INTEGER
enum1a >= ub = integer =
INTEGER
enum1a andalso ub = integer =
INTEGER
enum1a orelse ub = integer =
INTEGER

math ops (enum1a, sh):

enum1a + sh = max =
INTEGER
enum1a - sh = max =
INTEGER
enum1a * sh = max =
INTEGER
enum1a / sh = float =
DOUBLE
enum1a ^ sh = float =
DOUBLE
enum1a \ sh = non-float =
INTEGER
enum1a mod sh = non-float =
INTEGER

bitops (enum1a, sh):

enum1a shl sh = non-float =
INTEGER
enum1a shr sh = non-float =
INTEGER
enum1a and sh = non-float =
INTEGER
enum1a or sh = non-float =
INTEGER
enum1a xor sh = non-float =
INTEGER
enum1a eqv sh = non-float =
INTEGER
enum1a imp sh = non-float =
INTEGER

relational ops (enum1a, sh):

enum1a = sh = integer =
INTEGER
enum1a > sh = integer =
INTEGER
enum1a < sh = integer =
INTEGER
enum1a <> sh = integer =
INTEGER
enum1a <= sh = integer =
INTEGER
enum1a >= sh = integer =
INTEGER
enum1a andalso sh = integer =
INTEGER
enum1a orelse sh = integer =
INTEGER

math ops (enum1a, ush):

enum1a + ush = max =
INTEGER
enum1a - ush = max =
INTEGER
enum1a * ush = max =
INTEGER
enum1a / ush = float =
DOUBLE
enum1a ^ ush = float =
DOUBLE
enum1a \ ush = non-float =
INTEGER
enum1a mod ush = non-float =
INTEGER

bitops (enum1a, ush):

enum1a shl ush = non-float =
INTEGER
enum1a shr ush = non-float =
INTEGER
enum1a and ush = non-float =
INTEGER
enum1a or ush = non-float =
INTEGER
enum1a xor ush = non-float =
INTEGER
enum1a eqv ush = non-float =
INTEGER
enum1a imp ush = non-float =
INTEGER

relational ops (enum1a, ush):

enum1a = ush = integer =
INTEGER
enum1a > ush = integer =
INTEGER
enum1a < ush = integer =
INTEGER
enum1a <> ush = integer =
INTEGER
enum1a <= ush = integer =
INTEGER
enum1a >= ush = integer =
INTEGER
enum1a andalso ush = integer =
INTEGER
enum1a orelse ush = integer =
INTEGER

math ops (enum1a, i):

enum1a + i = max =
INTEGER
enum1a - i = max =
INTEGER
enum1a * i = max =
INTEGER
enum1a / i = float =
DOUBLE
enum1a ^ i = float =
DOUBLE
enum1a \ i = non-float =
INTEGER
enum1a mod i = non-float =
INTEGER

bitops (enum1a, i):

enum1a shl i = non-float =
INTEGER
enum1a shr i = non-float =
INTEGER
enum1a and i = non-float =
INTEGER
enum1a or i = non-float =
INTEGER
enum1a xor i = non-float =
INTEGER
enum1a eqv i = non-float =
INTEGER
enum1a imp i = non-float =
INTEGER

relational ops (enum1a, i):

enum1a = i = integer =
INTEGER
enum1a > i = integer =
INTEGER
enum1a < i = integer =
INTEGER
enum1a <> i = integer =
INTEGER
enum1a <= i = integer =
INTEGER
enum1a >= i = integer =
INTEGER
enum1a andalso i = integer =
INTEGER
enum1a orelse i = integer =
INTEGER

math ops (enum1a, ui):

enum1a + ui = max =
UINTEGER
enum1a - ui = max =
UINTEGER
enum1a * ui = max =
UINTEGER
enum1a / ui = float =
DOUBLE
enum1a ^ ui = float =
DOUBLE
enum1a \ ui = non-float =
UINTEGER
enum1a mod ui = non-float =
UINTEGER

bitops (enum1a, ui):

enum1a shl ui = non-float =
UINTEGER
enum1a shr ui = non-float =
UINTEGER
enum1a and ui = non-float =
UINTEGER
enum1a or ui = non-float =
UINTEGER
enum1a xor ui = non-float =
UINTEGER
enum1a eqv ui = non-float =
UINTEGER
enum1a imp ui = non-float =
UINTEGER

relational ops (enum1a, ui):

enum1a = ui = integer =
INTEGER
enum1a > ui = integer =
INTEGER
enum1a < ui = integer =
INTEGER
enum1a <> ui = integer =
INTEGER
enum1a <= ui = integer =
INTEGER
enum1a >= ui = integer =
INTEGER
enum1a andalso ui = integer =
INTEGER
enum1a orelse ui = integer =
INTEGER

math ops (enum1a, l):

enum1a + l = max =
INTEGER
enum1a - l = max =
INTEGER
enum1a * l = max =
INTEGER
enum1a / l = float =
DOUBLE
enum1a ^ l = float =
DOUBLE
enum1a \ l = non-float =
INTEGER
enum1a mod l = non-float =
INTEGER

bitops (enum1a, l):

enum1a shl l = non-float =
INTEGER
enum1a shr l = non-float =
INTEGER
enum1a and l = non-float =
INTEGER
enum1a or l = non-float =
INTEGER
enum1a xor l = non-float =
INTEGER
enum1a eqv l = non-float =
INTEGER
enum1a imp l = non-float =
INTEGER

relational ops (enum1a, l):

enum1a = l = integer =
INTEGER
enum1a > l = integer =
INTEGER
enum1a < l = integer =
INTEGER
enum1a <> l = integer =
INTEGER
enum1a <= l = integer =
INTEGER
enum1a >= l = integer =
INTEGER
enum1a andalso l = integer =
INTEGER
enum1a orelse l = integer =
INTEGER

math ops (enum1a, ul):

enum1a + ul = max =
INTEGER
enum1a - ul = max =
INTEGER
enum1a * ul = max =
INTEGER
enum1a / ul = float =
DOUBLE
enum1a ^ ul = float =
DOUBLE
enum1a \ ul = non-float =
INTEGER
enum1a mod ul = non-float =
INTEGER

bitops (enum1a, ul):

enum1a shl ul = non-float =
INTEGER
enum1a shr ul = non-float =
INTEGER
enum1a and ul = non-float =
INTEGER
enum1a or ul = non-float =
INTEGER
enum1a xor ul = non-float =
INTEGER
enum1a eqv ul = non-float =
INTEGER
enum1a imp ul = non-float =
INTEGER

relational ops (enum1a, ul):

enum1a = ul = integer =
INTEGER
enum1a > ul = integer =
INTEGER
enum1a < ul = integer =
INTEGER
enum1a <> ul = integer =
INTEGER
enum1a <= ul = integer =
INTEGER
enum1a >= ul = integer =
INTEGER
enum1a andalso ul = integer =
INTEGER
enum1a orelse ul = integer =
INTEGER

math ops (enum1a, ll):

enum1a + ll = max =
INTEGER
enum1a - ll = max =
INTEGER
enum1a * ll = max =
INTEGER
enum1a / ll = float =
DOUBLE
enum1a ^ ll = float =
DOUBLE
enum1a \ ll = non-float =
INTEGER
enum1a mod ll = non-float =
INTEGER

bitops (enum1a, ll):

enum1a shl ll = non-float =
INTEGER
enum1a shr ll = non-float =
INTEGER
enum1a and ll = non-float =
INTEGER
enum1a or ll = non-float =
INTEGER
enum1a xor ll = non-float =
INTEGER
enum1a eqv ll = non-float =
INTEGER
enum1a imp ll = non-float =
INTEGER

relational ops (enum1a, ll):

enum1a = ll = integer =
INTEGER
enum1a > ll = integer =
INTEGER
enum1a < ll = integer =
INTEGER
enum1a <> ll = integer =
INTEGER
enum1a <= ll = integer =
INTEGER
enum1a >= ll = integer =
INTEGER
enum1a andalso ll = integer =
INTEGER
enum1a orelse ll = integer =
INTEGER

math ops (enum1a, ull):

enum1a + ull = max =
UINTEGER
enum1a - ull = max =
UINTEGER
enum1a * ull = max =
UINTEGER
enum1a / ull = float =
DOUBLE
enum1a ^ ull = float =
DOUBLE
enum1a \ ull = non-float =
UINTEGER
enum1a mod ull = non-float =
UINTEGER

bitops (enum1a, ull):

enum1a shl ull = non-float =
UINTEGER
enum1a shr ull = non-float =
UINTEGER
enum1a and ull = non-float =
UINTEGER
enum1a or ull = non-float =
UINTEGER
enum1a xor ull = non-float =
UINTEGER
enum1a eqv ull = non-float =
UINTEGER
enum1a imp ull = non-float =
UINTEGER

relational ops (enum1a, ull):

enum1a = ull = integer =
INTEGER
enum1a > ull = integer =
INTEGER
enum1a < ull = integer =
INTEGER
enum1a <> ull = integer =
INTEGER
enum1a <= ull = integer =
INTEGER
enum1a >= ull = integer =
INTEGER
enum1a andalso ull = integer =
INTEGER
enum1a orelse ull = integer =
INTEGER

math ops (enum1a, enum1a):

enum1a + enum1a = max =
INTEGER
enum1a - enum1a = max =
INTEGER
enum1a * enum1a = max =
INTEGER
enum1a / enum1a = float =
DOUBLE
enum1a ^ enum1a = float =
DOUBLE
enum1a \ enum1a = non-float =
INTEGER
enum1a mod enum1a = non-float =
INTEGER

bitops (enum1a, enum1a):

enum1a shl enum1a = non-float =
INTEGER
enum1a shr enum1a = non-float =
INTEGER
enum1a and enum1a = non-float =
INTEGER
enum1a or enum1a = non-float =
INTEGER
enum1a xor enum1a = non-float =
INTEGER
enum1a eqv enum1a = non-float =
INTEGER
enum1a imp enum1a = non-float =
INTEGER

relational ops (enum1a, enum1a):

enum1a = enum1a = integer =
INTEGER
enum1a > enum1a = integer =
INTEGER
enum1a < enum1a = integer =
INTEGER
enum1a <> enum1a = integer =
INTEGER
enum1a <= enum1a = integer =
INTEGER
enum1a >= enum1a = integer =
INTEGER
enum1a andalso enum1a = integer =
INTEGER
enum1a orelse enum1a = integer =
INTEGER

math ops (b, enum1a):

b + enum1a = max =
INTEGER
b - enum1a = max =
INTEGER
b * enum1a = max =
INTEGER
b / enum1a = float =
DOUBLE
b ^ enum1a = float =
DOUBLE
b \ enum1a = non-float =
INTEGER
b mod enum1a = non-float =
INTEGER

bitops (b, enum1a):

b shl enum1a = non-float =
INTEGER
b shr enum1a = non-float =
INTEGER
b and enum1a = non-float =
INTEGER
b or enum1a = non-float =
INTEGER
b xor enum1a = non-float =
INTEGER
b eqv enum1a = non-float =
INTEGER
b imp enum1a = non-float =
INTEGER

relational ops (b, enum1a):

b = enum1a = integer =
INTEGER
b > enum1a = integer =
INTEGER
b < enum1a = integer =
INTEGER
b <> enum1a = integer =
INTEGER
b <= enum1a = integer =
INTEGER
b >= enum1a = integer =
INTEGER
b andalso enum1a = integer =
INTEGER
b orelse enum1a = integer =
INTEGER

math ops (ub, enum1a):

ub + enum1a = max =
INTEGER
ub - enum1a = max =
INTEGER
ub * enum1a = max =
INTEGER
ub / enum1a = float =
DOUBLE
ub ^ enum1a = float =
DOUBLE
ub \ enum1a = non-float =
INTEGER
ub mod enum1a = non-float =
INTEGER

bitops (ub, enum1a):

ub shl enum1a = non-float =
INTEGER
ub shr enum1a = non-float =
INTEGER
ub and enum1a = non-float =
INTEGER
ub or enum1a = non-float =
INTEGER
ub xor enum1a = non-float =
INTEGER
ub eqv enum1a = non-float =
INTEGER
ub imp enum1a = non-float =
INTEGER

relational ops (ub, enum1a):

ub = enum1a = integer =
INTEGER
ub > enum1a = integer =
INTEGER
ub < enum1a = integer =
INTEGER
ub <> enum1a = integer =
INTEGER
ub <= enum1a = integer =
INTEGER
ub >= enum1a = integer =
INTEGER
ub andalso enum1a = integer =
INTEGER
ub orelse enum1a = integer =
INTEGER

math ops (sh, enum1a):

sh + enum1a = max =
INTEGER
sh - enum1a = max =
INTEGER
sh * enum1a = max =
INTEGER
sh / enum1a = float =
DOUBLE
sh ^ enum1a = float =
DOUBLE
sh \ enum1a = non-float =
INTEGER
sh mod enum1a = non-float =
INTEGER

bitops (sh, enum1a):

sh shl enum1a = non-float =
INTEGER
sh shr enum1a = non-float =
INTEGER
sh and enum1a = non-float =
INTEGER
sh or enum1a = non-float =
INTEGER
sh xor enum1a = non-float =
INTEGER
sh eqv enum1a = non-float =
INTEGER
sh imp enum1a = non-float =
INTEGER

relational ops (sh, enum1a):

sh = enum1a = integer =
INTEGER
sh > enum1a = integer =
INTEGER
sh < enum1a = integer =
INTEGER
sh <> enum1a = integer =
INTEGER
sh <= enum1a = integer =
INTEGER
sh >= enum1a = integer =
INTEGER
sh andalso enum1a = integer =
INTEGER
sh orelse enum1a = integer =
INTEGER

math ops (ush, enum1a):

ush + enum1a = max =
INTEGER
ush - enum1a = max =
INTEGER
ush * enum1a = max =
INTEGER
ush / enum1a = float =
DOUBLE
ush ^ enum1a = float =
DOUBLE
ush \ enum1a = non-float =
INTEGER
ush mod enum1a = non-float =
INTEGER

bitops (ush, enum1a):

ush shl enum1a = non-float =
INTEGER
ush shr enum1a = non-float =
INTEGER
ush and enum1a = non-float =
INTEGER
ush or enum1a = non-float =
INTEGER
ush xor enum1a = non-float =
INTEGER
ush eqv enum1a = non-float =
INTEGER
ush imp enum1a = non-float =
INTEGER

relational ops (ush, enum1a):

ush = enum1a = integer =
INTEGER
ush > enum1a = integer =
INTEGER
ush < enum1a = integer =
INTEGER
ush <> enum1a = integer =
INTEGER
ush <= enum1a = integer =
INTEGER
ush >= enum1a = integer =
INTEGER
ush andalso enum1a = integer =
INTEGER
ush orelse enum1a = integer =
INTEGER

math ops (i, enum1a):

i + enum1a = max =
INTEGER
i - enum1a = max =
INTEGER
i * enum1a = max =
INTEGER
i / enum1a = float =
DOUBLE
i ^ enum1a = float =
DOUBLE
i \ enum1a = non-float =
INTEGER
i mod enum1a = non-float =
INTEGER

bitops (i, enum1a):

i shl enum1a = non-float =
INTEGER
i shr enum1a = non-float =
INTEGER
i and enum1a = non-float =
INTEGER
i or enum1a = non-float =
INTEGER
i xor enum1a = non-float =
INTEGER
i eqv enum1a = non-float =
INTEGER
i imp enum1a = non-float =
INTEGER

relational ops (i, enum1a):

i = enum1a = integer =
INTEGER
i > enum1a = integer =
INTEGER
i < enum1a = integer =
INTEGER
i <> enum1a = integer =
INTEGER
i <= enum1a = integer =
INTEGER
i >= enum1a = integer =
INTEGER
i andalso enum1a = integer =
INTEGER
i orelse enum1a = integer =
INTEGER

math ops (ui, enum1a):

ui + enum1a = max =
UINTEGER
ui - enum1a = max =
UINTEGER
ui * enum1a = max =
UINTEGER
ui / enum1a = float =
DOUBLE
ui ^ enum1a = float =
DOUBLE
ui \ enum1a = non-float =
UINTEGER
ui mod enum1a = non-float =
UINTEGER

bitops (ui, enum1a):

ui shl enum1a = non-float =
UINTEGER
ui shr enum1a = non-float =
UINTEGER
ui and enum1a = non-float =
UINTEGER
ui or enum1a = non-float =
UINTEGER
ui xor enum1a = non-float =
UINTEGER
ui eqv enum1a = non-float =
UINTEGER
ui imp enum1a = non-float =
UINTEGER

relational ops (ui, enum1a):

ui = enum1a = integer =
INTEGER
ui > enum1a = integer =
INTEGER
ui < enum1a = integer =
INTEGER
ui <> enum1a = integer =
INTEGER
ui <= enum1a = integer =
INTEGER
ui >= enum1a = integer =
INTEGER
ui andalso enum1a = integer =
INTEGER
ui orelse enum1a = integer =
INTEGER

math ops (l, enum1a):

l + enum1a = max =
INTEGER
l - enum1a = max =
INTEGER
l * enum1a = max =
INTEGER
l / enum1a = float =
DOUBLE
l ^ enum1a = float =
DOUBLE
l \ enum1a = non-float =
INTEGER
l mod enum1a = non-float =
INTEGER

bitops (l, enum1a):

l shl enum1a = non-float =
INTEGER
l shr enum1a = non-float =
INTEGER
l and enum1a = non-float =
INTEGER
l or enum1a = non-float =
INTEGER
l xor enum1a = non-float =
INTEGER
l eqv enum1a = non-float =
INTEGER
l imp enum1a = non-float =
INTEGER

relational ops (l, enum1a):

l = enum1a = integer =
INTEGER
l > enum1a = integer =
INTEGER
l < enum1a = integer =
INTEGER
l <> enum1a = integer =
INTEGER
l <= enum1a = integer =
INTEGER
l >= enum1a = integer =
INTEGER
l andalso enum1a = integer =
INTEGER
l orelse enum1a = integer =
INTEGER

math ops (ul, enum1a):

ul + enum1a = max =
INTEGER
ul - enum1a = max =
INTEGER
ul * enum1a = max =
INTEGER
ul / enum1a = float =
DOUBLE
ul ^ enum1a = float =
DOUBLE
ul \ enum1a = non-float =
INTEGER
ul mod enum1a = non-float =
INTEGER

bitops (ul, enum1a):

ul shl enum1a = non-float =
INTEGER
ul shr enum1a = non-float =
INTEGER
ul and enum1a = non-float =
INTEGER
ul or enum1a = non-float =
INTEGER
ul xor enum1a = non-float =
INTEGER
ul eqv enum1a = non-float =
INTEGER
ul imp enum1a = non-float =
INTEGER

relational ops (ul, enum1a):

ul = enum1a = integer =
INTEGER
ul > enum1a = integer =
INTEGER
ul < enum1a = integer =
INTEGER
ul <> enum1a = integer =
INTEGER
ul <= enum1a = integer =
INTEGER
ul >= enum1a = integer =
INTEGER
ul andalso enum1a = integer =
INTEGER
ul orelse enum1a = integer =
INTEGER

math ops (ll, enum1a):

ll + enum1a = max =
INTEGER
ll - enum1a = max =
INTEGER
ll * enum1a = max =
INTEGER
ll / enum1a = float =
DOUBLE
ll ^ enum1a = float =
DOUBLE
ll \ enum1a = non-float =
INTEGER
ll mod enum1a = non-float =
INTEGER

bitops (ll, enum1a):

ll shl enum1a = non-float =
INTEGER
ll shr enum1a = non-float =
INTEGER
ll and enum1a = non-float =
INTEGER
ll or enum1a = non-float =
INTEGER
ll xor enum1a = non-float =
INTEGER
ll eqv enum1a = non-float =
INTEGER
ll imp enum1a = non-float =
INTEGER

relational ops (ll, enum1a):

ll = enum1a = integer =
INTEGER
ll > enum1a = integer =
INTEGER
ll < enum1a = integer =
INTEGER
ll <> enum1a = integer =
INTEGER
ll <= enum1a = integer =
INTEGER
ll >= enum1a = integer =
INTEGER
ll andalso enum1a = integer =
INTEGER
ll orelse enum1a = integer =
INTEGER

math ops (ull, enum1a):

ull + enum1a = max =
UINTEGER
ull - enum1a = max =
UINTEGER
ull * enum1a = max =
UINTEGER
ull / enum1a = float =
DOUBLE
ull ^ enum1a = float =
DOUBLE
ull \ enum1a = non-float =
UINTEGER
ull mod enum1a = non-float =
UINTEGER

bitops (ull, enum1a):

ull shl enum1a = non-float =
UINTEGER
ull shr enum1a = non-float =
UINTEGER
ull and enum1a = non-float =
UINTEGER
ull or enum1a = non-float =
UINTEGER
ull xor enum1a = non-float =
UINTEGER
ull eqv enum1a = non-float =
UINTEGER
ull imp enum1a = non-float =
UINTEGER

relational ops (ull, enum1a):

ull = enum1a = integer =
INTEGER
ull > enum1a = integer =
INTEGER
ull < enum1a = integer =
INTEGER
ull <> enum1a = integer =
INTEGER
ull <= enum1a = integer =
INTEGER
ull >= enum1a = integer =
INTEGER
ull andalso enum1a = integer =
INTEGER
ull orelse enum1a = integer =
INTEGER

math ops (enum1a, enum1a):

enum1a + enum1a = max =
INTEGER
enum1a - enum1a = max =
INTEGER
enum1a * enum1a = max =
INTEGER
enum1a / enum1a = float =
DOUBLE
enum1a ^ enum1a = float =
DOUBLE
enum1a \ enum1a = non-float =
INTEGER
enum1a mod enum1a = non-float =
INTEGER

bitops (enum1a, enum1a):

enum1a shl enum1a = non-float =
INTEGER
enum1a shr enum1a = non-float =
INTEGER
enum1a and enum1a = non-float =
INTEGER
enum1a or enum1a = non-float =
INTEGER
enum1a xor enum1a = non-float =
INTEGER
enum1a eqv enum1a = non-float =
INTEGER
enum1a imp enum1a = non-float =
INTEGER

relational ops (enum1a, enum1a):

enum1a = enum1a = integer =
INTEGER
enum1a > enum1a = integer =
INTEGER
enum1a < enum1a = integer =
INTEGER
enum1a <> enum1a = integer =
INTEGER
enum1a <= enum1a = integer =
INTEGER
enum1a >= enum1a = integer =
INTEGER
enum1a andalso enum1a = integer =
INTEGER
enum1a orelse enum1a = integer =
INTEGER

enum1 + enum2 =
INTEGER

----------------------------------------------------------------------
pointers:
----------------------------------------------------------------------


ptr ops (pi, i):

pi + i = ptr =
INTEGER PTR
i + pi = ptr =
INTEGER PTR
pi - i = ptr =
INTEGER PTR

relational (pi, i):

pi = i = integer =
INTEGER
pi > i = integer =
INTEGER
pi < i = integer =
INTEGER
pi <> i = integer =
INTEGER
pi <= i = integer =
INTEGER
pi >= i = integer =
INTEGER
pi andalso i = integer =
INTEGER
pi orelse i = integer =
INTEGER

relational (i, pi):

i = pi = integer =
INTEGER
i > pi = integer =
INTEGER
i < pi = integer =
INTEGER
i <> pi = integer =
INTEGER
i <= pi = integer =
INTEGER
i >= pi = integer =
INTEGER
i andalso pi = integer =
INTEGER
i orelse pi = integer =
INTEGER

ptr ops (pi, ui):

pi + ui = ptr =
INTEGER PTR
ui + pi = ptr =
INTEGER PTR
pi - ui = ptr =
INTEGER PTR

relational (pi, ui):

pi = ui = integer =
INTEGER
pi > ui = integer =
INTEGER
pi < ui = integer =
INTEGER
pi <> ui = integer =
INTEGER
pi <= ui = integer =
INTEGER
pi >= ui = integer =
INTEGER
pi andalso ui = integer =
INTEGER
pi orelse ui = integer =
INTEGER

relational (ui, pi):

ui = pi = integer =
INTEGER
ui > pi = integer =
INTEGER
ui < pi = integer =
INTEGER
ui <> pi = integer =
INTEGER
ui <= pi = integer =
INTEGER
ui >= pi = integer =
INTEGER
ui andalso pi = integer =
INTEGER
ui orelse pi = integer =
INTEGER

ptr ops (pi, enum1a):

pi + enum1a = ptr =
INTEGER PTR
enum1a + pi = ptr =
INTEGER PTR
pi - enum1a = ptr =
INTEGER PTR

relational (pi, enum1a):

pi = enum1a = integer =
INTEGER
pi > enum1a = integer =
INTEGER
pi < enum1a = integer =
INTEGER
pi <> enum1a = integer =
INTEGER
pi <= enum1a = integer =
INTEGER
pi >= enum1a = integer =
INTEGER
pi andalso enum1a = integer =
INTEGER
pi orelse enum1a = integer =
INTEGER

relational (enum1a, pi):

enum1a = pi = integer =
INTEGER
enum1a > pi = integer =
INTEGER
enum1a < pi = integer =
INTEGER
enum1a <> pi = integer =
INTEGER
enum1a <= pi = integer =
INTEGER
enum1a >= pi = integer =
INTEGER
enum1a andalso pi = integer =
INTEGER
enum1a orelse pi = integer =
INTEGER

ptr ops (ppi, i):

ppi + i = ptr =
INTEGER PTR PTR
i + ppi = ptr =
INTEGER PTR PTR
ppi - i = ptr =
INTEGER PTR PTR

relational (ppi, i):

ppi = i = integer =
INTEGER
ppi > i = integer =
INTEGER
ppi < i = integer =
INTEGER
ppi <> i = integer =
INTEGER
ppi <= i = integer =
INTEGER
ppi >= i = integer =
INTEGER
ppi andalso i = integer =
INTEGER
ppi orelse i = integer =
INTEGER

relational (i, ppi):

i = ppi = integer =
INTEGER
i > ppi = integer =
INTEGER
i < ppi = integer =
INTEGER
i <> ppi = integer =
INTEGER
i <= ppi = integer =
INTEGER
i >= ppi = integer =
INTEGER
i andalso ppi = integer =
INTEGER
i orelse ppi = integer =
INTEGER

ptr ops (ppi, ui):

ppi + ui = ptr =
INTEGER PTR PTR
ui + ppi = ptr =
INTEGER PTR PTR
ppi - ui = ptr =
INTEGER PTR PTR

relational (ppi, ui):

ppi = ui = integer =
INTEGER
ppi > ui = integer =
INTEGER
ppi < ui = integer =
INTEGER
ppi <> ui = integer =
INTEGER
ppi <= ui = integer =
INTEGER
ppi >= ui = integer =
INTEGER
ppi andalso ui = integer =
INTEGER
ppi orelse ui = integer =
INTEGER

relational (ui, ppi):

ui = ppi = integer =
INTEGER
ui > ppi = integer =
INTEGER
ui < ppi = integer =
INTEGER
ui <> ppi = integer =
INTEGER
ui <= ppi = integer =
INTEGER
ui >= ppi = integer =
INTEGER
ui andalso ppi = integer =
INTEGER
ui orelse ppi = integer =
INTEGER

ptr ops (ppi, enum1a):

ppi + enum1a = ptr =
INTEGER PTR PTR
enum1a + ppi = ptr =
INTEGER PTR PTR
ppi - enum1a = ptr =
INTEGER PTR PTR

relational (ppi, enum1a):

ppi = enum1a = integer =
INTEGER
ppi > enum1a = integer =
INTEGER
ppi < enum1a = integer =
INTEGER
ppi <> enum1a = integer =
INTEGER
ppi <= enum1a = integer =
INTEGER
ppi >= enum1a = integer =
INTEGER
ppi andalso enum1a = integer =
INTEGER
ppi orelse enum1a = integer =
INTEGER

relational (enum1a, ppi):

enum1a = ppi = integer =
INTEGER
enum1a > ppi = integer =
INTEGER
enum1a < ppi = integer =
INTEGER
enum1a <> ppi = integer =
INTEGER
enum1a <= ppi = integer =
INTEGER
enum1a >= ppi = integer =
INTEGER
enum1a andalso ppi = integer =
INTEGER
enum1a orelse ppi = integer =
INTEGER

ptr ops (pudt, i):

pudt + i = ptr =
UDT PTR
i + pudt = ptr =
UDT PTR
pudt - i = ptr =
UDT PTR

relational (pudt, i):

pudt = i = integer =
INTEGER
pudt > i = integer =
INTEGER
pudt < i = integer =
INTEGER
pudt <> i = integer =
INTEGER
pudt <= i = integer =
INTEGER
pudt >= i = integer =
INTEGER
pudt andalso i = integer =
INTEGER
pudt orelse i = integer =
INTEGER

relational (i, pudt):

i = pudt = integer =
INTEGER
i > pudt = integer =
INTEGER
i < pudt = integer =
INTEGER
i <> pudt = integer =
INTEGER
i <= pudt = integer =
INTEGER
i >= pudt = integer =
INTEGER
i andalso pudt = integer =
INTEGER
i orelse pudt = integer =
INTEGER

ptr ops (pudt, ui):

pudt + ui = ptr =
UDT PTR
ui + pudt = ptr =
UDT PTR
pudt - ui = ptr =
UDT PTR

relational (pudt, ui):

pudt = ui = integer =
INTEGER
pudt > ui = integer =
INTEGER
pudt < ui = integer =
INTEGER
pudt <> ui = integer =
INTEGER
pudt <= ui = integer =
INTEGER
pudt >= ui = integer =
INTEGER
pudt andalso ui = integer =
INTEGER
pudt orelse ui = integer =
INTEGER

relational (ui, pudt):

ui = pudt = integer =
INTEGER
ui > pudt = integer =
INTEGER
ui < pudt = integer =
INTEGER
ui <> pudt = integer =
INTEGER
ui <= pudt = integer =
INTEGER
ui >= pudt = integer =
INTEGER
ui andalso pudt = integer =
INTEGER
ui orelse pudt = integer =
INTEGER

ptr ops (pudt, enum1a):

pudt + enum1a = ptr =
UDT PTR
enum1a + pudt = ptr =
UDT PTR
pudt - enum1a = ptr =
UDT PTR

relational (pudt, enum1a):

pudt = enum1a = integer =
INTEGER
pudt > enum1a = integer =
INTEGER
pudt < enum1a = integer =
INTEGER
pudt <> enum1a = integer =
INTEGER
pudt <= enum1a = integer =
INTEGER
pudt >= enum1a = integer =
INTEGER
pudt andalso enum1a = integer =
INTEGER
pudt orelse enum1a = integer =
INTEGER

relational (enum1a, pudt):

enum1a = pudt = integer =
INTEGER
enum1a > pudt = integer =
INTEGER
enum1a < pudt = integer =
INTEGER
enum1a <> pudt = integer =
INTEGER
enum1a <= pudt = integer =
INTEGER
enum1a >= pudt = integer =
INTEGER
enum1a andalso pudt = integer =
INTEGER
enum1a orelse pudt = integer =
INTEGER

UOPs

cbyte(0):
not:
INTEGER
negation:
INTEGER
abs:
INTEGER
sgn:
INTEGER
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
INTEGER
fix:
INTEGER
frac:
INTEGER

b:
not:
INTEGER
negation:
INTEGER
abs:
INTEGER
sgn:
LONG
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
INTEGER
fix:
INTEGER
frac:
INTEGER

cubyte(0):
not:
INTEGER
negation:
INTEGER
abs:
INTEGER
sgn:
INTEGER
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
INTEGER
fix:
INTEGER
frac:
INTEGER

ub:
not:
INTEGER
negation:
INTEGER
abs:
INTEGER
sgn:
LONG
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
INTEGER
fix:
INTEGER
frac:
INTEGER

cshort(0):
not:
INTEGER
negation:
INTEGER
abs:
INTEGER
sgn:
INTEGER
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
INTEGER
fix:
INTEGER
frac:
INTEGER

sh:
not:
INTEGER
negation:
INTEGER
abs:
INTEGER
sgn:
LONG
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
INTEGER
fix:
INTEGER
frac:
INTEGER

cushort(0):
not:
INTEGER
negation:
INTEGER
abs:
INTEGER
sgn:
INTEGER
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
INTEGER
fix:
INTEGER
frac:
INTEGER

ush:
not:
INTEGER
negation:
INTEGER
abs:
INTEGER
sgn:
LONG
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
INTEGER
fix:
INTEGER
frac:
INTEGER

0l:
not:
INTEGER
negation:
INTEGER
abs:
INTEGER
sgn:
INTEGER
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
INTEGER
fix:
INTEGER
frac:
INTEGER

l:
not:
INTEGER
negation:
INTEGER
abs:
INTEGER
sgn:
LONG
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
INTEGER
fix:
INTEGER
frac:
INTEGER

0ul:
not:
INTEGER
negation:
INTEGER
abs:
INTEGER
sgn:
INTEGER
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
INTEGER
fix:
INTEGER
frac:
INTEGER

ul:
not:
INTEGER
negation:
INTEGER
abs:
INTEGER
sgn:
LONG
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
INTEGER
fix:
INTEGER
frac:
INTEGER

0ll:
not:
INTEGER
negation:
INTEGER
abs:
INTEGER
sgn:
INTEGER
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
INTEGER
fix:
INTEGER
frac:
INTEGER

ll:
not:
INTEGER
negation:
INTEGER
abs:
INTEGER
sgn:
LONG
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
INTEGER
fix:
INTEGER
frac:
INTEGER

0ull:
not:
UINTEGER
negation:
INTEGER
abs:
UINTEGER
sgn:
INTEGER
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
UINTEGER
fix:
UINTEGER
frac:
UINTEGER

ull:
not:
UINTEGER
negation:
INTEGER
abs:
UINTEGER
sgn:
LONG
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
UINTEGER
fix:
UINTEGER
frac:
UINTEGER

0:
not:
INTEGER
negation:
INTEGER
abs:
INTEGER
sgn:
INTEGER
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
INTEGER
fix:
INTEGER
frac:
INTEGER

i:
not:
INTEGER
negation:
INTEGER
abs:
INTEGER
sgn:
LONG
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
INTEGER
fix:
INTEGER
frac:
INTEGER

0u:
not:
UINTEGER
negation:
INTEGER
abs:
UINTEGER
sgn:
INTEGER
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
UINTEGER
fix:
UINTEGER
frac:
UINTEGER

ui:
not:
UINTEGER
negation:
INTEGER
abs:
UINTEGER
sgn:
LONG
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
UINTEGER
fix:
UINTEGER
frac:
UINTEGER

0.0f:
not:
INTEGER
negation:
SINGLE
abs:
SINGLE
sgn:
SINGLE
sin:
SINGLE
asin:
SINGLE
cos:
SINGLE
acos:
SINGLE
tan:
SINGLE
atn:
SINGLE
sqr:
SINGLE
log:
SINGLE
exp:
SINGLE
int:
SINGLE
fix:
SINGLE
frac:
SINGLE

f:
not:
INTEGER
negation:
SINGLE
abs:
SINGLE
sgn:
LONG
sin:
SINGLE
asin:
SINGLE
cos:
SINGLE
acos:
SINGLE
tan:
SINGLE
atn:
SINGLE
sqr:
SINGLE
log:
SINGLE
exp:
SINGLE
int:
SINGLE
fix:
SINGLE
frac:
SINGLE

0.0d:
not:
INTEGER
negation:
DOUBLE
abs:
DOUBLE
sgn:
DOUBLE
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
DOUBLE
fix:
DOUBLE
frac:
DOUBLE

d:
not:
INTEGER
negation:
DOUBLE
abs:
DOUBLE
sgn:
LONG
sin:
DOUBLE
asin:
DOUBLE
cos:
DOUBLE
acos:
DOUBLE
tan:
DOUBLE
atn:
DOUBLE
sqr:
DOUBLE
log:
DOUBLE
exp:
DOUBLE
int:
DOUBLE
fix:
DOUBLE
frac:
DOUBLE
